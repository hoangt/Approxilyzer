!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.6	//
ADDR_OVERLAP_STALL_STAGE	dynamic.h	/^    ADDR_OVERLAP_STALL_STAGE,$/;"	e	enum:dynamic_inst_t::stage_t
AGU	diagnosis.h	/^			   AGU,$/;"	e	enum:loc_id_t
ALEX_ARCH_MIS_DEBUG	arf.C	78;"	d	file:
ALEX_DEBUG_MEMOP	memop.C	85;"	d	file:
ALEX_DEBUG_VALUE_BEFORE_SAVE	memop.C	86;"	d	file:
ALEX_DEPERR_DEBUG	arf.C	76;"	d	file:
ALEX_MMU_DEBUG	pseq.C	109;"	d	file:
ALEX_OS_MIS	arf.C	77;"	d	file:
ALEX_REG_TYPE_CHK_FAIL	arf.C	79;"	d	file:
ALEX_SNET_DEBUG	pseq.C	108;"	d	file:
AM64	pseq.C	122;"	d	file:
ANALYSIS_INTERVAL	diagnosis.C	20;"	d	file:
ARCH_INUSE_STATE	pseq.h	2380;"	d
ARCH_STATE	pseq.h	2377;"	d
Access	cache.C	/^bool generic_cache_template<BlockType>::Access(miss_t *m) {$/;"	f	class:generic_cache_template
AddressMapping	pstate.h	/^typedef map<la_t, pa_t> AddressMapping;$/;"	t
AddressStatTable	memstat.h	/^typedef map<pa_t, cache_line_stat_t *>  AddressStatTable;$/;"	t
AddressTranslationMap	dtlb.h	/^typedef map<la_t, dtlb_entry_t *>  AddressTranslationMap;$/;"	t
Allocate	mshr.C	/^miss_t::Allocate(pa_t a, cache_t *c, mshr_priority_t p, waiter_t *w) {$/;"	f	class:miss_t
Allocate	mshr.C	/^stream_t::Allocate(pa_t prefetch_addr, word_t o, bool pos) {$/;"	f	class:stream_t
AppendFreeMSHR	mshr.h	/^  void    AppendFreeMSHR(miss_t* m) {$/;"	f	class:mshr_t
AppendFreeStream	mshr.h	/^  void    AppendFreeStream(stream_t* s) {$/;"	f	class:mshr_t
BIG_ENDIAN_HOST	hfa.C	/^uint32 BIG_ENDIAN_HOST = false;$/;"	v
BIG_ENDIAN_TARGET	hfa.C	/^uint32 BIG_ENDIAN_TARGET = false;$/;"	v
BlockAddress	cache.h	/^  inline pa_t   BlockAddress(pa_t a) { return (a & ~(pa_t)block_mask); }$/;"	f	class:generic_cache_template
BreakpointTable	system.h	/^typedef map<breakpoint_id_t, breakpoint_action_t *> BreakpointTable;$/;"	t
BusTransferDone	mshr.C	/^mshr_t::BusTransferDone(miss_t* m) {$/;"	f	class:mshr_t
CACHE_BLK_DIRTY	cache.h	/^const byte_t CACHE_BLK_DIRTY  = 0x2;$/;"	v
CACHE_BLK_LOCKED	cache.h	/^const byte_t CACHE_BLK_LOCKED = 0x4;$/;"	v
CACHE_BLK_VALID	cache.h	/^const byte_t CACHE_BLK_VALID  = 0x1;$/;"	v
CACHE_MISS_STAGE	dynamic.h	/^    CACHE_MISS_STAGE,$/;"	e	enum:dynamic_inst_t::stage_t
CACHE_NOTREADY_STAGE	dynamic.h	/^    CACHE_NOTREADY_STAGE,$/;"	e	enum:dynamic_inst_t::stage_t
CC_ARF	arf.h	70;"	d
CC_REG_FILE	regfile.h	72;"	d
CHAIN_MAX_DEPTH	chain.h	/^const int32 CHAIN_MAX_DEPTH   = 9;$/;"	v
CHAIN_MEMORY_LATENCY	chain.C	80;"	d	file:
CNT_IDX	pseq.h	73;"	d
COMPLETE_STAGE	dynamic.h	/^    COMPLETE_STAGE,$/;"	e	enum:dynamic_inst_t::stage_t
COMPLEX_OPERATION	statici.C	290;"	d	file:
CONFIG_IN_SIMICS	hfa.C	/^uint32 CONFIG_IN_SIMICS = false;$/;"	v
CONFIG_MULTIPROCESSOR	hfa.C	/^uint32 CONFIG_MULTIPROCESSOR = false;$/;"	v
CONFIG_WITH_RUBY	hfa.C	/^uint32 CONFIG_WITH_RUBY = false;$/;"	v
CONTROL_ARF	arf.h	69;"	d
CONTROL_OP_GET	dx.C	83;"	d	file:
CONTROL_OP_GET	ix.C	85;"	d	file:
CONTROL_OP_TYPE	dx.C	82;"	d	file:
CONTROL_OP_TYPE	ix.C	84;"	d	file:
CONTROL_REG_FILE	regfile.h	71;"	d
CORE_ID	system.h	/^  int CORE_ID;$/;"	m	class:system_t
CRC16_BlockChecksum	crc16.C	/^unsigned short CRC16_BlockChecksum( void *data, int length ) {$/;"	f
CRC16_FinishChecksum	crc16.C	/^void CRC16_FinishChecksum( unsigned short &crcvalue ) {$/;"	f
CRC16_INIT_VALUE	crc16.C	12;"	d	file:
CRC16_InitChecksum	crc16.C	/^void CRC16_InitChecksum( unsigned short &crcvalue ) {$/;"	f
CRC16_UpdateChecksum	crc16.C	/^void CRC16_UpdateChecksum( unsigned short &crcvalue, void *data, int length ) {$/;"	f
CRC16_XOR_VALUE	crc16.C	13;"	d	file:
CRC_CHECK	diagnosis.C	37;"	d	file:
CacheAccessDone	mshr.C	/^mshr_t::CacheAccessDone(miss_t* m) {$/;"	f	class:mshr_t
Castout	mshr.C	/^stream_t::Castout(miss_t *miss) {$/;"	f	class:stream_t
Change	inv-defs.h	/^  }Change;$/;"	m	struct:Invariant	typeref:union:Invariant::__anon15
Change	inv-defs.h	/^  }Change;$/;"	m	struct:MulRangeInvariant	typeref:union:MulRangeInvariant::__anon18
Complete	memop.C	/^atomic_inst_t::Complete() {$/;"	f	class:atomic_inst_t
Complete	memop.C	/^load_inst_t::Complete( void ) {$/;"	f	class:load_inst_t
Complete	memop.C	/^prefetch_inst_t::Complete( void ) {$/;"	f	class:prefetch_inst_t
Complete	memop.C	/^store_inst_t::Complete() {$/;"	f	class:store_inst_t
Count	inv-defs.h	/^  long long Count;  $/;"	m	struct:Invariant
Count	inv-defs.h	/^  long long Count;  $/;"	m	struct:MulRangeInvariant
DATA_DEMAND_PRIORITY	mshr.h	/^                       DATA_DEMAND_PRIORITY,    \/* processor read data   *\/$/;"	e	enum:mshr_priority_t
DBUS	diagnosis.h	/^			   DBUS,$/;"	e	enum:loc_id_t
DDG_H	ddg.h	2;"	d
DEBUG_DDG	ddg.C	12;"	d	file:
DEBUG_DDG_SIZE	ddg.C	13;"	d	file:
DEBUG_MULTICYCLE_FE	pseq.h	/^  static const bool DEBUG_MULTICYCLE_FE = true;$/;"	m	class:pseq_t
DEBUG_SIMPLE_FE	pseq.h	/^  static const bool DEBUG_SIMPLE_FE = false;$/;"	m	class:pseq_t
DECODER	diagnosis.h	/^			   DECODER,$/;"	e	enum:loc_id_t
DECODER_DEBUG	diagnosis.C	179;"	d	file:
DECODE_DEFAULT_MIN_LATENCY	decode.C	/^const uint64  DECODE_DEFAULT_MIN_LATENCY = 10000;$/;"	v
DECODE_STAGE	dynamic.h	/^    DECODE_STAGE,$/;"	e	enum:dynamic_inst_t::stage_t
DELAYED_PRIORITY	mshr.h	/^enum mshr_priority_t { DELAYED_PRIORITY,        \/* ??? not used?         *\/$/;"	e	enum:mshr_priority_t
DEST_INDEX	dynamic.h	/^  enum reg_index_t {SOURCE1_INDEX, SOURCE2_INDEX, TO_FREE_INDEX, DEST_INDEX};$/;"	e	enum:dynamic_inst_t::reg_index_t
DEST_REG	pseq.C	114;"	d	file:
DIAGNOSIS_GIVEUP_THRESHOLD	diagnosis.C	32;"	d	file:
DIAGNOSIS_H	diagnosis.h	2;"	d
DIAGNOSIS_THRESHOLD	diagnosis.h	20;"	d
DOUBLE_ARF	arf.h	72;"	d
DO_FAULT_INJECTION	pseq.h	2318;"	d
DTLB_BITS	dtlb.h	/^const word_t DTLB_BITS = 8; \/\/ 64 entry TLB$/;"	v
DTLB_SIZE	dtlb.h	/^const word_t DTLB_SIZE = 1 << DTLB_BITS;$/;"	v
DX_PLIST	dx.h	60;"	d
DX_PLIST	ix.h	61;"	d
DX_PLIST	ix.h	62;"	d
DX_RETURNT	dx.h	59;"	d
DX_RETURNT	ix.h	59;"	d
DX_RETURNT	ix.h	60;"	d
Deallocate	mshr.C	/^stream_t::Deallocate() {$/;"	f	class:stream_t
Decode	dynamic.C	/^dynamic_inst_t::Decode( uint64 issueTime )$/;"	f	class:dynamic_inst_t
DecodeFault	decodefault.C	/^DecodeFault::DecodeFault( static_inst_t *s_inst, int inst, int stuck_at, int bit):Fault(stuck_at, bit)$/;"	f	class:DecodeFault
DecodeFault	decodefault.h	/^class DecodeFault:public Fault {$/;"	c
DetailedType	inv-defs.h	/^  char DetailedType[10];$/;"	m	struct:Invariant
DetailedType	inv-defs.h	/^  char DetailedType[10];$/;"	m	struct:MulRangeInvariant
DetectStride	mshr.C	/^mshr_t::DetectStride(pa_t block_address, bool *prefetch_pos) {$/;"	f	class:mshr_t
Disconnected	wait.h	/^  bool Disconnected() const { return ((prev == NULL) && (next == NULL)); }$/;"	f	class:waiter_t
DoAfterFill	cache.C	/^void generic_cache_template<BlockType>::DoAfterFill(BlockType *b, uint32 way) {$/;"	f	class:generic_cache_template
DoBeforeReplace	cache.C	/^void generic_cache_template<BlockType>::DoBeforeReplace(BlockType *b, uint32 way) {$/;"	f	class:generic_cache_template
DoWhenAccessHit	cache.C	/^void generic_cache_template<BlockType>::DoWhenAccessHit(BlockType *b, bool read, bool data) {$/;"	f	class:generic_cache_template
DoWhenAccessMiss	cache.C	/^void generic_cache_template<BlockType>::DoWhenAccessMiss(my_addr_t a, bool read, bool data) {$/;"	f	class:generic_cache_template
EARLY_ATOMIC_STAGE	dynamic.h	/^    EARLY_ATOMIC_STAGE,$/;"	e	enum:dynamic_inst_t::stage_t
EARLY_STORE_STAGE	dynamic.h	/^    EARLY_STORE_STAGE,$/;"	e	enum:dynamic_inst_t::stage_t
ENDIAN_MATCHES	hfa.C	/^uint32 ENDIAN_MATCHES = false;$/;"	v
EVENT_BRANCH_MISPREDICT	dynamic.h	/^const inst_event_t EVENT_BRANCH_MISPREDICT = 1 << 7;$/;"	v
EVENT_DCACHE_MISS	dynamic.h	/^const inst_event_t EVENT_DCACHE_MISS       = 1 << 0;$/;"	v
EVENT_FINALIZED	dynamic.h	/^const inst_event_t EVENT_FINALIZED         = 1 << 6;$/;"	v
EVENT_IWINDOW_REMOVED	dynamic.h	/^const inst_event_t EVENT_IWINDOW_REMOVED   = 1 << 4;$/;"	v
EVENT_LSQ_BYPASS	dynamic.h	/^const inst_event_t EVENT_LSQ_BYPASS        = 1 << 1;$/;"	v
EVENT_LSQ_INSERT	dynamic.h	/^const inst_event_t EVENT_LSQ_INSERT        = 1 << 3;$/;"	v
EVENT_MSHR_HIT	dynamic.h	/^const inst_event_t EVENT_MSHR_HIT          = 1 << 5;$/;"	v
EVENT_MSHR_STALL	dynamic.h	/^const inst_event_t EVENT_MSHR_STALL        = 1 << 8;$/;"	v
EVENT_QUEUE_SIZE	scheduler.h	/^const uint32 EVENT_QUEUE_SIZE = 8;$/;"	v
EVENT_TIME_EXECUTE	dynamic.h	/^  EVENT_TIME_EXECUTE = 0,$/;"	e	enum:inst_time_t
EVENT_TIME_EXECUTE_DONE	dynamic.h	/^  EVENT_TIME_EXECUTE_DONE,$/;"	e	enum:inst_time_t
EVENT_TIME_NUM_EVENT_TIMES	dynamic.h	/^  EVENT_TIME_NUM_EVENT_TIMES$/;"	e	enum:inst_time_t
EVENT_TIME_RETIRE	dynamic.h	/^  EVENT_TIME_RETIRE,$/;"	e	enum:inst_time_t
EVENT_VALUE_PRODUCER	dynamic.h	/^const inst_event_t EVENT_VALUE_PRODUCER    = 1 << 2;$/;"	v
EXECUTE_STAGE	dynamic.h	/^    EXECUTE_STAGE,$/;"	e	enum:dynamic_inst_t::stage_t
Empty	wait.h	/^  bool Empty() const { return (next == NULL); }$/;"	f	class:wait_list_t
Execute	controlop.C	/^control_inst_t::Execute()$/;"	f	class:control_inst_t
Execute	dynamic.C	/^dynamic_inst_t::Execute( void ) {$/;"	f	class:dynamic_inst_t
Execute	dynamic.C	/^void dynamic_inst_t::Execute( void ) {$/;"	f	class:dynamic_inst_t
Execute	memop.C	/^load_inst_t::Execute() {$/;"	f	class:load_inst_t
Execute	memop.C	/^memory_inst_t::Execute( void )$/;"	f	class:memory_inst_t
Execute	memop.C	/^prefetch_inst_t::Execute( void ) {$/;"	f	class:prefetch_inst_t
Execute	memop.C	/^store_inst_t::Execute() {$/;"	f	class:store_inst_t
Execute	sample.C	/^void dynamic_inst_t::Execute( void ) {$/;"	f	class:dynamic_inst_t
Execute	scheduler.C	/^scheduler_t::Execute( tick_t localcycle )$/;"	f	class:scheduler_t
FAIL	statici.C	344;"	d	file:
FAULT_CLEAR_FUNC_TRAP	pseq.h	2371;"	d
FAULT_CLOCK	pseq.h	2344;"	d
FAULT_CURR_INST	pseq.h	2359;"	d
FAULT_IN_FUNC_TRAP	pseq.h	2368;"	d
FAULT_RET_INST	pseq.h	2347;"	d
FAULT_RET_PRIV	pseq.h	2353;"	d
FAULT_SET_NON_RET_TRAP	pseq.h	2374;"	d
FAULT_SET_PRIV	pseq.h	2362;"	d
FETCH_BARRIER	statici.C	147;"	d	file:
FETCH_STAGE	dynamic.h	/^    FETCH_STAGE,$/;"	e	enum:dynamic_inst_t::stage_t
FLATARF_MAX_DISPATCH_SIZE	flatarf.C	76;"	d	file:
FLOAT_BLOCK	statici.C	320;"	d	file:
FLOAT_DOUBLE	statici.C	314;"	d	file:
FLOAT_QUAD	statici.C	317;"	d	file:
FLOAT_SINGLE	statici.C	311;"	d	file:
FLOW_CONSTANT	flow.h	/^const flow_event_t FLOW_CONSTANT          = 1 << 1;$/;"	v
FLOW_EXCEPTION	flow.h	/^const flow_event_t FLOW_EXCEPTION         = 1 << 3;$/;"	v
FLOW_IS_COUNTED	flow.h	/^const flow_event_t FLOW_IS_COUNTED        = 1 << 4;$/;"	v
FLOW_MEMORY_MISS	flow.h	/^const flow_event_t FLOW_MEMORY_MISS       = 1 << 0;$/;"	v
FLOW_SEEN_ACCESS	flow.h	/^const flow_event_t FLOW_SEEN_ACCESS       = 1 << 2;$/;"	v
FLOW_UNUSED5	flow.h	/^const flow_event_t FLOW_UNUSED5      = 1 << 5;$/;"	v
FLOW_UNUSED6	flow.h	/^const flow_event_t FLOW_UNUSED6      = 1 << 6;$/;"	v
FLOW_UNUSED7	flow.h	/^const flow_event_t FLOW_UNUSED7      = 1 << 7;$/;"	v
FLOW_UNUSED8	flow.h	/^const flow_event_t FLOW_UNUSED8      = 1 << 8;$/;"	v
FORWARD_INSTR_CNT	diagnosis.C	22;"	d	file:
FP_CMP	statici.C	337;"	d	file:
FP_MONO_OP	statici.C	323;"	d	file:
FP_MOVE_OP	statici.C	327;"	d	file:
FP_REG_FILE	regfile.h	73;"	d
FP_TRI_OP	statici.C	332;"	d	file:
FP_util	pseq.h	/^  int FP_util[3][4];$/;"	m	class:pseq_t
FU	diagnosis.h	/^			   FU,$/;"	e	enum:loc_id_t
Fault	fault.h	/^		Fault( int stuck_at, int bit ):stuck_at(stuck_at), bit(bit) {}$/;"	f	class:Fault
Fault	fault.h	/^class Fault {$/;"	c
FetchSquash	dynamic.C	/^dynamic_inst_t::FetchSquash() { $/;"	f	class:dynamic_inst_t
Fill	cache.C	/^pa_t generic_cache_template<BlockType>::Fill(pa_t a, bool dirty, bool *writeback, bool prefetched) {$/;"	f	class:generic_cache_template
FillAndSwapOutVictim	mshr.C	/^miss_t::FillAndSwapOutVictim() {$/;"	f	class:miss_t
Find	mshr.C	/^bool replacement_manager_t<Type>::Find(Type *t) {$/;"	f	class:replacement_manager_t
Fname	inv-defs.h	/^  char *Fname;$/;"	m	struct:Invariant
Fname	inv-defs.h	/^  char *Fname;$/;"	m	struct:MulRangeInvariant
GEN_TB	dynamic.C	1147;"	d	file:
GEN_TB	sample.C	409;"	d	file:
GET_CLOCK	pseq.h	2410;"	d
GET_FAULTY_REG	pseq.h	2338;"	d
GET_FAULT_BIT	pseq.h	2328;"	d
GET_FAULT_INJECTION	pseq.h	2321;"	d
GET_FAULT_STUCKAT	pseq.h	2332;"	d
GET_FAULT_TYPE	pseq.h	2324;"	d
GET_INF_LOOP_START	pseq.h	2404;"	d
GET_PRIV	pseq.h	2365;"	d
GET_RET_INST	pseq.h	2350;"	d
GET_RET_PRIV	pseq.h	2356;"	d
GetBlockSize	mshr.h	/^  word_t  GetBlockSize() const { return m_block_mask + 1; }$/;"	f	class:mshr_t
GetIdleMiss	mshr.C	/^mshr_t::GetIdleMiss() {$/;"	f	class:mshr_t
GetLRU	cache.C	/^uint32 generic_cache_template<BlockType>::GetLRU(BlockType* set) {$/;"	f	class:generic_cache_template
GetLRU	mshr.h	/^  Type  *GetLRU() { return m_tail; }$/;"	f	class:replacement_manager_t
GetMRU	mshr.h	/^  Type  *GetMRU() { return m_head; }$/;"	f	class:replacement_manager_t
GetName	cache.h	/^  const char  *GetName( void ) const { return name; }$/;"	f	class:cache_t
GetSize	mshr.h	/^  uint32 GetSize() { return m_size; };$/;"	f	class:replacement_manager_t
GratuitousPrefetchMSHRsAvailable	mshr.h	/^  bool    GratuitousPrefetchMSHRsAvailable() const { $/;"	f	class:mshr_t
HALT_AT_ROLLBACK	pseq.C	118;"	d	file:
HALT_SIMULATION	system.h	517;"	d
HIT	rubycache.h	/^enum ruby_status_t { MISS, HIT, NOT_READY };$/;"	e	enum:ruby_status_t
HashIndex	mshr.h	/^  uint32  HashIndex(pa_t a) { return (uint32)(a>>m_block_bits)&MSHR_HASH_MASK; }$/;"	f	class:mshr_t
HashInsert	mshr.C	/^mshr_t::HashInsert(miss_t *m) {$/;"	f	class:mshr_t
HashMatch	mshr.C	/^mshr_t::HashMatch(pa_t a) {$/;"	f	class:mshr_t
HashRemove	mshr.C	/^mshr_t::HashRemove(miss_t *m) {$/;"	f	class:mshr_t
HashVerify	mshr.C	/^mshr_t::HashVerify(miss_t *m) {$/;"	f	class:mshr_t
INC_BRANCH	pseq.h	2413;"	d
INC_FATAL_TRAPS	pseq.h	2395;"	d
INC_READ_INJ	pseq.h	2398;"	d
INC_READ_MASK	pseq.h	2401;"	d
INC_STORE	pseq.h	2416;"	d
INC_TOTAL_INJ	pseq.h	2386;"	d
INC_TOTAL_MASK	pseq.h	2389;"	d
INC_TOTAL_TRAPS	pseq.h	2392;"	d
INF_LOOP_THRESHOLD	pseq.h	70;"	d
INJECT_FAULT	pseq.h	2341;"	d
INST_DEMAND_PRIORITY	mshr.h	/^                       INST_DEMAND_PRIORITY,    \/* processor read instr  *\/$/;"	e	enum:mshr_priority_t
INTERRUPT_IN_EXEC	diagnosis.C	26;"	d	file:
INT_ARF	arf.h	68;"	d
INT_BYTE	statici.C	296;"	d	file:
INT_EXTENDED	statici.C	305;"	d	file:
INT_HALF	statici.C	299;"	d	file:
INT_QUAD	statici.C	308;"	d	file:
INT_REG_FILE	regfile.h	70;"	d
INT_SIGNED	statici.C	293;"	d	file:
INT_WORD	statici.C	302;"	d	file:
INVALID	diagnosis.h	/^enum loc_id_t {INVALID,$/;"	e	enum:loc_id_t
INVALID_REG	pseq.h	2023;"	d
IPAGEMAP_DONE_TOKEN	ipagemap.h	/^const la_t IPAGEMAP_DONE_TOKEN  = ~0x1;$/;"	v
IPAGEMAP_FILENAME	ipagemap.C	/^const char *IPAGEMAP_FILENAME = ".\/data\/imap";$/;"	v
IPAGEMAP_INDEX_TOKEN	ipagemap.h	/^const la_t IPAGEMAP_INDEX_TOKEN = ~0x0;$/;"	v
IPAGE_CONFLICT	ipage.h	/^const uint16 IPAGE_CONFLICT  =     0x2;$/;"	v
IPAGE_MAX_INSTR	ipage.h	/^const uint32 IPAGE_MAX_INSTR =    128;$/;"	v
IPAGE_NEW	ipage.h	/^const uint16 IPAGE_NEW       =     0x1;$/;"	v
IPAGE_PAGE_BITS	ipage.h	/^const int    IPAGE_PAGE_BITS =      7;$/;"	v
IPAGE_PAGE_MASK	ipage.h	/^const int    IPAGE_PAGE_MASK = IPAGE_MAX_INSTR-1;$/;"	v
IPAGE_SEEN	ipage.h	/^const uint16 IPAGE_SEEN      =     0x0;$/;"	v
ISADDRESS32	pseq.C	126;"	d	file:
I_RD1	statici.C	93;"	d	file:
I_RD2	statici.C	94;"	d	file:
I_RS1	statici.C	88;"	d	file:
I_RS2	statici.C	89;"	d	file:
I_RS3	statici.C	90;"	d	file:
I_RS4	statici.C	91;"	d	file:
InsertOrderedWaitQueue	wait.h	/^  void InsertOrderedWaitQueue(wait_list_t *wl, waiter_t *w_last) {$/;"	f	class:waiter_t
InsertVictim	mshr.h	/^  void    InsertVictim(miss_t* m) {$/;"	f	class:mshr_t
InsertWaitQueue	wait.h	/^  void InsertWaitQueue(wait_list_t &wl) {$/;"	f	class:waiter_t
InsertWaitQueueBefore	wait.h	/^  void InsertWaitQueueBefore(waiter_t *w) {$/;"	f	class:waiter_t
InsertWaitQueueTail	wait.h	/^  void InsertWaitQueueTail(wait_list_t &wl) {$/;"	f	class:waiter_t
InstName	inv-defs.h	/^  char InstName[10];$/;"	m	struct:Invariant
InstName	inv-defs.h	/^  char InstName[10];$/;"	m	struct:MulRangeInvariant
InvMap	inv-defs.h	/^typedef map<int,Invariant*> InvMap;  $/;"	t
Invariant	inv-defs.h	/^struct Invariant {$/;"	s
IsAddressInCache	mshr.C	/^mshr_t::IsAddressInCache(pa_t addr) {$/;"	f	class:mshr_t
IsAllocated	mshr.h	/^  bool IsAllocated() { return (m_address == MISS_NOT_ALLOCATED); }$/;"	f	class:miss_t
IsDirty	cache.h	/^  inline bool IsDirty(BlockType &cb) { $/;"	f	class:generic_cache_template
IsValid	cache.h	/^  inline bool IsValid(BlockType &cb) { $/;"	f	class:generic_cache_template
LARGE_STALL_TIME	ptrace.C	/^const uint64  LARGE_STALL_TIME        = 10000;$/;"	v
LAST_FETCH_MASK	mshr.h	/^const word_t LAST_FETCH_MASK = LAST_FETCH_SIZE - 1;$/;"	v
LAST_FETCH_SIZE	mshr.h	/^const word_t LAST_FETCH_SIZE = 16;$/;"	v
LAST_SEQ_IDX	pseq.h	74;"	d
LLB_DICTIONARY_SIZE	diagnosis.h	24;"	d
LLB_FULL	diagnosis.h	17;"	d
LLB_QUEUE_SIZE	diagnosis.h	23;"	d
LL_FAIL	statici.C	348;"	d	file:
LOGGING_THRESHOLD	diagnosis.C	31;"	d	file:
LOGGING_THRESHOLD_REACHED	diagnosis.h	19;"	d
LOGICAL_REG	diagnosis.h	/^			   LOGICAL_REG,$/;"	e	enum:loc_id_t
LOOP_HASH_SIZE	pseq.h	69;"	d
LSQ_HASH_MASK	lsq.h	/^const uint32 LSQ_HASH_MASK = LSQ_HASH_SIZE - 1;$/;"	v
LSQ_HASH_SIZE	lsq.h	/^const uint32 LSQ_HASH_SIZE = 64;$/;"	v
LSQ_WAIT_STAGE	dynamic.h	/^    LSQ_WAIT_STAGE,$/;"	e	enum:dynamic_inst_t::stage_t
LXL_BEYOND_FATAL_TRAP	diagnosis.C	23;"	d	file:
LXL_DEBUG_MISMATCH_INFO	dynamic.C	3636;"	d	file:
LXL_DIAG_DEBUG	diagnosis.C	13;"	d	file:
LXL_MISMATCH_DEBUG	arf.C	80;"	d	file:
LXL_NO_NUM_REG_CHK	arf.C	84;"	d	file:
LXL_NO_OPAL_CONFIG	system.C	106;"	d	file:
LXL_PATCH_CORRUPTED_REG	dynamic.C	169;"	d	file:
LXL_RAT_DEBUG	arf.C	104;"	d	file:
LXL_SQUASH_DEBUG	dynamic.C	1955;"	d	file:
LXL_STORE_DEBUG	memop.C	87;"	d	file:
LoadMSHRsAvailable	mshr.h	/^  bool    LoadMSHRsAvailable() const { $/;"	f	class:mshr_t
MASK_FSR_MISMATCH	arf.C	82;"	d	file:
MAX_CALL_DEPTH	inv-defs.h	6;"	d
MAX_CANDIDATES	diagnosis.C	15;"	d	file:
MAX_INSTR_RUN	system.C	107;"	d	file:
MAX_INSTR_TRACE_SIZE	diagnosis.h	14;"	d
MAX_INST_STAGE	dynamic.h	/^    MAX_INST_STAGE$/;"	e	enum:dynamic_inst_t::stage_t
MAX_INVARIANTS_PER_PROGRAM_POINT	inv-defs.h	5;"	d
MAX_NUM_MISMATCH	diagnosis.C	16;"	d	file:
MAX_NUM_RANGES	inv-defs.h	7;"	d
MAX_PRIORITY	mshr.h	/^                       MAX_PRIORITY };$/;"	e	enum:mshr_priority_t
MAX_PROGRAM_POINTS	inv-defs.h	4;"	d
MAX_PROPAGATION_LATENCY	pseq.h	2022;"	d
MAX_STATE	mshr.h	/^                    MAX_STATE };$/;"	e	enum:miss_state_t
MAX_TERM_CAND	diagnosis.C	18;"	d	file:
MAX_TERM_MISMATCH	diagnosis.C	17;"	d	file:
MEMOP_EXACT	memop.h	/^const uint16  MEMOP_EXACT    =  2;$/;"	v
MEMOP_OVERLAP	memop.h	/^const uint16  MEMOP_OVERLAP  =  1;$/;"	v
MEMORY_OP_GET	dx.C	87;"	d	file:
MEMORY_OP_GET	ix.C	89;"	d	file:
MEMORY_OP_TYPE	dx.C	86;"	d	file:
MEMORY_OP_TYPE	ix.C	88;"	d	file:
MEMSTAT_MAX_THREADS	memstat.h	/^const int32  MEMSTAT_MAX_THREADS = 160;$/;"	v
MEM_STATE	pseq.h	2383;"	d
MISS	rubycache.h	/^enum ruby_status_t { MISS, HIT, NOT_READY };$/;"	e	enum:ruby_status_t
MISS_NOT_ALLOCATED	mshr.h	/^  static const pa_t MISS_NOT_ALLOCATED = ~((pa_t) 0);$/;"	m	class:miss_t
MSHR_DEBUG	mshr.h	/^  static const bool MSHR_DEBUG = false;$/;"	m	class:mshr_t
MSHR_HASH_BITS	mshr.h	/^const word_t MSHR_HASH_BITS = 5;$/;"	v
MSHR_HASH_MASK	mshr.h	/^const word_t MSHR_HASH_MASK = MSHR_HASH_SIZE - 1;$/;"	v
MSHR_HASH_SIZE	mshr.h	/^const word_t MSHR_HASH_SIZE = 1 << MSHR_HASH_BITS;$/;"	v
MSHRsAvailable	mshr.h	/^  bool    MSHRsAvailable() const { return (m_num_active < m_max_misses); }$/;"	f	class:mshr_t
MULTICORE_DIAGNOSIS_DEBUG	diagnosis.C	24;"	d	file:
MULTICORE_DIAGNOSIS_DEBUG	diagnosis.C	3255;"	d	file:
M_PSTATE	pseq.C	134;"	d	file:
Max	inv-defs.h	/^  }Max;$/;"	m	struct:Invariant	typeref:union:Invariant::__anon14
Max	inv-defs.h	/^  }Max;$/;"	m	struct:MulRangeInvariant	typeref:union:MulRangeInvariant::__anon17
Min	inv-defs.h	/^  }Min;$/;"	m	struct:Invariant	typeref:union:Invariant::__anon13
Min	inv-defs.h	/^  }Min;$/;"	m	struct:MulRangeInvariant	typeref:union:MulRangeInvariant::__anon16
Miss	mshr.C	/^mshr_t::Miss(pa_t a, cache_t *c, mshr_priority_t p, waiter_t *w, bool *primary_bool)$/;"	f	class:mshr_t
MulRangeInvMap	inv-defs.h	/^typedef map<int,MulRangeInvariant*> MulRangeInvMap;  $/;"	t
MulRangeInvariant	inv-defs.h	/^struct MulRangeInvariant {$/;"	s
NORMAL	pseq.h	/^	NORMAL=0,$/;"	e	enum:operation_mode_t
NOT_READY	rubycache.h	/^enum ruby_status_t { MISS, HIT, NOT_READY };$/;"	e	enum:ruby_status_t
NO_FAULT_INJECTION	pseq.h	2315;"	d
NUM_AGU	diagnosis.h	11;"	d
NUM_CHKPTS	pstate.h	66;"	d
NUM_CYCLES_TO_COMPARE	diagnosis.C	29;"	d	file:
NUM_FU_TYPE	diagnosis.h	12;"	d
NUM_FU_UNIT	diagnosis.h	13;"	d
NUM_INSTR_TO_COMPARE	diagnosis.C	28;"	d	file:
NUM_STRUCT	diagnosis.h	/^			   NUM_STRUCT};$/;"	e	enum:loc_id_t
NoOfUpdation	inv-defs.h	/^  long long NoOfUpdation;$/;"	m	struct:Invariant
NoOfUpdation	inv-defs.h	/^  long long NoOfUpdation;$/;"	m	struct:MulRangeInvariant
OPAL_ATOMIC	mf_api.h	/^  OPAL_ATOMIC,$/;"	e	enum:OpalMemop
OPAL_IFETCH	mf_api.h	/^  OPAL_IFETCH,$/;"	e	enum:OpalMemop
OPAL_LOAD	mf_api.h	/^  OPAL_LOAD,$/;"	e	enum:OpalMemop
OPAL_RELATIVE_PATH	hfa.C	/^const char *OPAL_RELATIVE_PATH = "..\/..\/..\/opal\/";$/;"	v
OPAL_SNET_NEW_CHKPT	mf_api.h	/^  OPAL_SNET_NEW_CHKPT,$/;"	e	enum:OpalMemop
OPAL_SNET_PRINT_CLBSIZE	mf_api.h	/^  OPAL_SNET_PRINT_CLBSIZE,$/;"	e	enum:OpalMemop
OPAL_SNET_ROLLBACK	mf_api.h	/^  OPAL_SNET_ROLLBACK,$/;"	e	enum:OpalMemop
OPAL_SNET_START_LOGGING	mf_api.h	/^  OPAL_SNET_START_LOGGING,$/;"	e	enum:OpalMemop
OPAL_STORE	mf_api.h	/^  OPAL_STORE,$/;"	e	enum:OpalMemop
OS_INSTR_THRESHOLD	pseq.h	81;"	d
OS_INSTR_THRESHOLD_MULTI	pseq.h	82;"	d
OUT_SYMPTOM_INFO	pseq.h	2421;"	d
OpalMemop	mf_api.h	/^typedef enum OpalMemop {$/;"	g
OpalMemop_t	mf_api.h	/^} OpalMemop_t;$/;"	t	typeref:enum:OpalMemop
OracleAccess	cache.C	/^void generic_cache_template<BlockType>::OracleAccess(pa_t a) {$/;"	f	class:generic_cache_template
OracleAccess	mshr.C	/^mshr_t::OracleAccess(pa_t a) {$/;"	f	class:mshr_t
OracleCleanse	mshr.C	/^miss_t::OracleCleanse() {$/;"	f	class:miss_t
OrderedList	wait.C	/^wait_list_t::OrderedList() {$/;"	f	class:wait_list_t
PC	pseq.h	/^    uint64 PC;$/;"	m	struct:__anon21
PHYSICAL_REG	diagnosis.h	/^			   PHYSICAL_REG,$/;"	e	enum:loc_id_t
PREFETCH2CACHE_PRIORITY	mshr.h	/^                       PREFETCH2CACHE_PRIORITY, \/* prefetch to cache     *\/$/;"	e	enum:mshr_priority_t
PREFETCH_PRIORITY	mshr.h	/^                       PREFETCH_PRIORITY,       \/* prefetch to L1 mshrs  *\/$/;"	e	enum:mshr_priority_t
PREFETCH_STATE	mshr.h	/^                    PREFETCH_STATE, \/* finished prefetch                                  *\/$/;"	e	enum:miss_state_t
PRINT_ALL_TRAPS	pseq.C	3175;"	d	file:
PRINT_INSTR_AFTER_RECOVERY	pseq.C	110;"	d	file:
PSEQ_CRITICAL_REG_COUNT	checkresult.h	/^const uint32 PSEQ_CRITICAL_REG_COUNT = 4;$/;"	v
PSEQ_FETCH_BARRIER	pseq.h	/^  PSEQ_FETCH_BARRIER,$/;"	e	enum:pseq_fetch_status_t
PSEQ_FETCH_ICACHEMISS	pseq.h	/^  PSEQ_FETCH_ICACHEMISS,$/;"	e	enum:pseq_fetch_status_t
PSEQ_FETCH_ITLBMISS	pseq.h	/^  PSEQ_FETCH_ITLBMISS,$/;"	e	enum:pseq_fetch_status_t
PSEQ_FETCH_MAX_STATUS	pseq.h	/^  PSEQ_FETCH_MAX_STATUS$/;"	e	enum:pseq_fetch_status_t
PSEQ_FETCH_READY	pseq.h	/^  PSEQ_FETCH_READY = 0,$/;"	e	enum:pseq_fetch_status_t
PSEQ_FETCH_SQUASH	pseq.h	/^  PSEQ_FETCH_SQUASH,$/;"	e	enum:pseq_fetch_status_t
PSEQ_FETCH_WIN_FULL	pseq.h	/^  PSEQ_FETCH_WIN_FULL,$/;"	e	enum:pseq_fetch_status_t
PSEQ_HIST_DECODE	pseq.C	/^const int32   PSEQ_HIST_DECODE        = 30;$/;"	v
PSEQ_INVALID_LINE_ADDRESS	pseq.h	/^  static const pa_t PSEQ_INVALID_LINE_ADDRESS = ~(pa_t)0;$/;"	m	class:pseq_t
PSEQ_IPAGE_TABLESIZE	pseq.h	/^const int PSEQ_IPAGE_TABLESIZE       = 16384;$/;"	v
PSEQ_MAX_FF_LENGTH	pseq.h	/^const uint32 PSEQ_MAX_FF_LENGTH      = 256;$/;"	v
PSEQ_MAX_FWD_PROGRESS_TIME	pseq.h	/^const int PSEQ_MAX_FWD_PROGRESS_TIME = 1024*64;$/;"	v
PSEQ_OS_PAGE_MASK	pseq.C	/^const la_t PSEQ_OS_PAGE_MASK = 0xffffffffffffe000ULL;$/;"	v
PSEQ_RECENT_RETIRE_SIZE	pseq.C	/^const int32   PSEQ_RECENT_RETIRE_SIZE = 40;$/;"	v
PSEQ_REG_USE_HIST	pseq.C	/^const uint32  PSEQ_REG_USE_HIST       = 200;$/;"	v
PSEQ_RETIRE_LIMIT	pseq.h	/^  PSEQ_RETIRE_LIMIT,$/;"	e	enum:pseq_retire_status_t
PSEQ_RETIRE_MAX_STATUS	pseq.h	/^  PSEQ_RETIRE_MAX_STATUS$/;"	e	enum:pseq_retire_status_t
PSEQ_RETIRE_READY	pseq.h	/^  PSEQ_RETIRE_READY = 0,$/;"	e	enum:pseq_retire_status_t
PSEQ_RETIRE_SQUASH	pseq.h	/^  PSEQ_RETIRE_SQUASH,$/;"	e	enum:pseq_retire_status_t
PSEQ_RETIRE_UPDATEALL	pseq.h	/^  PSEQ_RETIRE_UPDATEALL,$/;"	e	enum:pseq_retire_status_t
PS_EXEC_FAIL	pstate.h	/^const uint16  PS_EXEC_FAIL     =  0x1;$/;"	v
PS_EXEC_SUCCESS	pstate.h	/^const uint16  PS_EXEC_SUCCESS  =  0x0;$/;"	v
PS_NO_INTEREST	pstate.h	/^const uint16  PS_NO_INTEREST   =  0x2;$/;"	v
PTMEM_IS_IO	ptrace.h	/^const pt_memory_flags_t PTMEM_IS_IO          = 1 << 0;$/;"	v
PTMEM_NON_CPU_INI	ptrace.h	/^const pt_memory_flags_t PTMEM_NON_CPU_INI    = 1 << 1;$/;"	v
PTMEM_NOT_STALLABLE	ptrace.h	/^const pt_memory_flags_t PTMEM_NOT_STALLABLE  = 1 << 2;$/;"	v
PTMEM_UNUSED3	ptrace.h	/^const pt_memory_flags_t PTMEM_UNUSED3        = 1 << 3;$/;"	v
PTMEM_UNUSED4	ptrace.h	/^const pt_memory_flags_t PTMEM_UNUSED4        = 1 << 4;$/;"	v
PTMEM_UNUSED5	ptrace.h	/^const pt_memory_flags_t PTMEM_UNUSED5        = 1 << 5;$/;"	v
PTMEM_UNUSED6	ptrace.h	/^const pt_memory_flags_t PTMEM_UNUSED6        = 1 << 6;$/;"	v
PTMEM_UNUSED7	ptrace.h	/^const pt_memory_flags_t PTMEM_UNUSED7        = 1 << 7;$/;"	v
PTRACE_IO_STALL_TIME	ptrace.C	/^const uint64  PTRACE_IO_STALL_TIME    = 140;$/;"	v
PTRACE_MAGIC_NUM	ptrace.h	/^  static const uint32 PTRACE_MAGIC_NUM = 0x83245656;$/;"	m	class:ptrace_t
PTRACE_ONLINE	ptrace.h	/^    PTRACE_UNINITIALIZED, PTRACE_WRITING, PTRACE_READING, PTRACE_ONLINE$/;"	e	enum:ptrace_t::ptrace_mode_t
PTRACE_READING	ptrace.h	/^    PTRACE_UNINITIALIZED, PTRACE_WRITING, PTRACE_READING, PTRACE_ONLINE$/;"	e	enum:ptrace_t::ptrace_mode_t
PTRACE_UNINITIALIZED	ptrace.h	/^    PTRACE_UNINITIALIZED, PTRACE_WRITING, PTRACE_READING, PTRACE_ONLINE$/;"	e	enum:ptrace_t::ptrace_mode_t
PTRACE_WRITING	ptrace.h	/^    PTRACE_UNINITIALIZED, PTRACE_WRITING, PTRACE_READING, PTRACE_ONLINE$/;"	e	enum:ptrace_t::ptrace_mode_t
PT_INST_RECORD	ptrace.h	/^  enum pt_token_t { PT_INST_RECORD, PT_MEMORY_RECORD };$/;"	e	enum:ptrace_t::pt_token_t
PT_MEMORY_RECORD	ptrace.h	/^  enum pt_token_t { PT_INST_RECORD, PT_MEMORY_RECORD };$/;"	e	enum:ptrace_t::pt_token_t
PerPCLockTable	sysstat.h	/^typedef map<la_t, lock_stat_t *>   PerPCLockTable;$/;"	t
Prefetch	cache.C	/^void generic_cache_template<BlockType>::Prefetch(pa_t a) {$/;"	f	class:generic_cache_template
Prefetch	mshr.C	/^stream_t::Prefetch(uint32 num_prefetches) {$/;"	f	class:stream_t
PrefetchMoreOnPrefetchHit	mshr.C	/^stream_t::PrefetchMoreOnPrefetchHit(miss_t *miss) {$/;"	f	class:stream_t
ProgramPtId	inv-defs.h	/^  int ProgramPtId; \/\/ later add variables, operations, position\/pgm point etc.$/;"	m	struct:Invariant
ProgramPtId	inv-defs.h	/^  int ProgramPtId; \/\/ later add variables, operations, position\/pgm point etc.$/;"	m	struct:MulRangeInvariant
QUEUED_STATE	mshr.h	/^enum miss_state_t { QUEUED_STATE,   \/* waiting for bus free or lower level MSHR available *\/$/;"	e	enum:miss_state_t
RANGE_IDX	pseq.h	75;"	d
RANGE_THRESHOLD	pseq.h	71;"	d
READY_STAGE	dynamic.h	/^    READY_STAGE,$/;"	e	enum:dynamic_inst_t::stage_t
READ_TWO_F	statici.C	260;"	d	file:
READ_TWO_I	statici.C	230;"	d	file:
RECOVERED	pseq.h	/^	RECOVERED$/;"	e	enum:operation_mode_t
RECOVERING	pseq.h	/^	RECOVERING,$/;"	e	enum:operation_mode_t
REGISTER_BASE	pstate.C	76;"	d	file:
REG_BLOCK	statici.h	/^const byte_t  REG_BLOCK   = 1 << 6; \/\/ 64-byte access$/;"	v
REG_BYTE	statici.h	/^const byte_t  REG_BYTE    = 1 << 0;$/;"	v
REG_DOUBLE	statici.h	/^const byte_t  REG_DOUBLE  = 1 << 3;$/;"	v
REG_HALF	statici.h	/^const byte_t  REG_HALF    = 1 << 1;$/;"	v
REG_MEMSIZE	statici.h	/^const byte_t  REG_MEMSIZE = REG_BYTE | REG_HALF | REG_WORD | REG_DOUBLE |$/;"	v
REG_ONE_MOVE	statici.C	202;"	d	file:
REG_QUAD	statici.h	/^const byte_t  REG_QUAD    = 1 << 4;$/;"	v
REG_SIGNED	statici.h	/^const byte_t  REG_SIGNED  = 1 << 7; \/\/ set if this is a signed access$/;"	v
REG_TWO_ALU	statici.C	172;"	d	file:
REG_TWO_I	statici.C	215;"	d	file:
REG_TWO_SHIFT	statici.C	185;"	d	file:
REG_WORD	statici.h	/^const byte_t  REG_WORD    = 1 << 2;$/;"	v
RES_BUS_WIDTH	diagnosis.h	10;"	d
RETIRE_STAGE	dynamic.h	/^    RETIRE_STAGE,$/;"	e	enum:dynamic_inst_t::stage_t
ROB	diagnosis.h	/^			   ROB,$/;"	e	enum:loc_id_t
ROB_FAULT_DEBUG	iwindow.C	159;"	d	file:
ROLLBACK_AT_SYMPTOM	pseq.C	116;"	d	file:
Read	cache.C	/^bool generic_cache_template<BlockType>::Read( pa_t a, waiter_t *w, bool data_request, bool *primary_bool)$/;"	f	class:generic_cache_template
RecentFetch	mshr.C	/^mshr_t::RecentFetch(pa_t block_address) {$/;"	f	class:mshr_t
Release	dynamic.h	/^  void Release() { SIM_HALT; }$/;"	f	class:dynamic_inst_t
Release	wait.h	/^  virtual void Release() {};$/;"	f	class:waiter_t
ReleaseChain	wait.C	/^wait_list_t::ReleaseChain() {$/;"	f	class:wait_list_t
Remove	mshr.C	/^void replacement_manager_t<Type>::Remove(Type *t) {$/;"	f	class:replacement_manager_t
RemoveHead	wait.h	/^  waiter_t *RemoveHead() {$/;"	f	class:free_list_t
RemoveOutstanding	mshr.C	/^mshr_t::RemoveOutstanding(miss_t* m) {$/;"	f	class:mshr_t
RemoveWaitQueue	wait.h	/^  void RemoveWaitQueue() {$/;"	f	class:waiter_t
Reset	regmap.C	/^void reg_map_t::Reset(void) $/;"	f	class:reg_map_t
Retire	controlop.C	/^control_inst_t::Retire( abstract_pc_t *a )$/;"	f	class:control_inst_t
Retire	dynamic.C	/^dynamic_inst_t::Retire( abstract_pc_t *a )$/;"	f	class:dynamic_inst_t
Retire	memop.C	/^atomic_inst_t::Retire( abstract_pc_t *a ) {$/;"	f	class:atomic_inst_t
Retire	memop.C	/^load_inst_t::Retire( abstract_pc_t *a ) {$/;"	f	class:load_inst_t
Retire	memop.C	/^memory_inst_t::Retire( abstract_pc_t *a )$/;"	f	class:memory_inst_t
Retire	memop.C	/^prefetch_inst_t::Retire( abstract_pc_t *a ) {$/;"	f	class:prefetch_inst_t
Retire	memop.C	/^store_inst_t::Retire( abstract_pc_t *a ) {$/;"	f	class:store_inst_t
SDQ_TWIST	statici.C	167;"	d	file:
SET_FAULT_INJ_INST	pseq.h	2426;"	d
SIMSTATUS_BREAK	system.h	/^    SIMSTATUS_BREAK,$/;"	e	enum:system_t::sim_status_t
SIMSTATUS_MLP_TRACE	system.h	/^    SIMSTATUS_MLP_TRACE,$/;"	e	enum:system_t::sim_status_t
SIMSTATUS_OK	system.h	/^    SIMSTATUS_OK,$/;"	e	enum:system_t::sim_status_t
SIMSTATUS_SYMBOL_MODE	system.h	/^    SIMSTATUS_SYMBOL_MODE$/;"	e	enum:system_t::sim_status_t
SIMSTATUS_TRACING	system.h	/^    SIMSTATUS_TRACING,$/;"	e	enum:system_t::sim_status_t
SIMSTATUS_WARMUP	system.h	/^    SIMSTATUS_WARMUP,$/;"	e	enum:system_t::sim_status_t
SIM_break_simulation	simdist12.C	/^void SIM_break_simulation(const char *msg) {$/;"	f
SIM_breakpoint	simdist12.C	/^breakpoint_id_t SIM_breakpoint(conf_object_t *object,$/;"	f
SIM_check_exception	simdist12.C	/^sim_exception_t SIM_check_exception() {$/;"	f
SIM_clear_exception	simdist12.C	/^sim_exception_t SIM_clear_exception() {$/;"	f
SIM_conf_object_to_processor	simdist12.C	/^processor_t *SIM_conf_object_to_processor(conf_object_t* obj) {$/;"	f
SIM_continue	simdist12.C	/^simtime_t SIM_continue(integer_t step) {$/;"	f
SIM_cpu_enabled	simdist12.C	/^int          SIM_cpu_enabled(processor_t *cpu_ptr) {$/;"	f
SIM_cpu_get_current_globals	simdist12.C	/^int    SIM_cpu_get_current_globals(processor_t *cpu_ptr) {$/;"	f
SIM_cpu_get_max_tl	simdist12.C	/^int    SIM_cpu_get_max_tl(processor_t *cpu_ptr) { UNIMPL; return (0); }$/;"	f
SIM_cpu_get_mid	simdist12.C	/^int    SIM_cpu_get_mid(processor_t *cpu_ptr) {UNIMPL; return (0); }$/;"	f
SIM_cpu_get_num_windows	simdist12.C	/^int    SIM_cpu_get_num_windows(processor_t *cpu_ptr) { UNIMPL; return (0); }$/;"	f
SIM_cpu_get_pending_exception	simdist12.C	/^int    SIM_cpu_get_pending_exception(processor_t *cpu_ptr) {$/;"	f
SIM_cpu_get_pending_interrupt	simdist12.C	/^int    SIM_cpu_get_pending_interrupt(processor_t *cpu_ptr) {$/;"	f
SIM_cpu_set_mid	simdist12.C	/^void   SIM_cpu_set_mid(processor_t *cpu_ptr, int mid) { UNIMPL; }$/;"	f
SIM_current_processor	simdist12.C	/^conf_object_t *SIM_current_processor(void) {$/;"	f
SIM_cycle_count	simdist12.C	/^cycles_t SIM_cycle_count(conf_object_t *obj) {$/;"	f
SIM_disable_processor	simdist12.C	/^void SIM_disable_processor(processor_t *cpu_ptr) { UNIMPL; }$/;"	f
SIM_disassemble	simdist12.C	/^tuple_int_string_t *SIM_disassemble(processor_t *cpu_ptr, generic_address_t address, int type) {$/;"	f
SIM_dump_caches	simdist12.C	/^void SIM_dump_caches(void) {$/;"	f
SIM_enable_processor	simdist12.C	/^void SIM_enable_processor(processor_t *cpu_ptr) { UNIMPL; }$/;"	f
SIM_exception_has_occurred	simdist12.C	/^int SIM_exception_has_occurred() {$/;"	f
SIM_flush	simdist12.C	/^int SIM_flush(void) {$/;"	f
SIM_for_all_memory_pages	simdist12.C	/^void SIM_for_all_memory_pages(cb_func_nI_t func, int d_or_i) { UNIMPL; }$/;"	f
SIM_for_all_processors	simdist12.C	/^void SIM_for_all_processors(cb_func_nco_t cb, lang_void *param) {$/;"	f
SIM_free_attribute	simdist12.C	/^SIM_free_attribute(attr_value_t value) {$/;"	f
SIM_get_all_registers	simdist12.C	/^attr_value_t SIM_get_all_registers(conf_object_t *cpu) { attr_value_t a; UNIMPL; return a; };$/;"	f
SIM_get_attribute	simdist12.C	/^SIM_get_attribute(conf_object_t *object, const char *name) {$/;"	f
SIM_get_attribute_idx	simdist12.C	/^SIM_get_attribute_idx(conf_object_t *object, const char *name, attr_value_t *idx) {$/;"	f
SIM_get_callback_argument_string	simdist12.C	/^const char *SIM_get_callback_argument_string(callback_arguments_t cb)$/;"	f
SIM_get_current_proc_no	simdist12.C	/^int          SIM_get_current_proc_no(void) {$/;"	f
SIM_get_exception_name	simdist12.C	/^const char  *SIM_get_exception_name(conf_object_t *cpu_ptr, int exc_num) {$/;"	f
SIM_get_exception_name	simdist12.C	269;"	d	file:
SIM_get_exception_number	simdist12.C	/^int    SIM_get_exception_number(conf_object_t *cpu_ptr, const char *exc_name) {$/;"	f
SIM_get_exception_number	simdist12.C	273;"	d	file:
SIM_get_hap_arguments	simdist12.C	/^callback_arguments_t SIM_get_hap_arguments(hap_type_t hap, int type)$/;"	f
SIM_get_interface	simdist12.C	/^interface_t *SIM_get_interface(const conf_object_t *object,$/;"	f
SIM_get_mem_op_value_be	simdist12.C	/^uinteger_t SIM_get_mem_op_value_be(generic_transaction_t *mem_op) {$/;"	f
SIM_get_mem_op_value_le	simdist12.C	/^uinteger_t SIM_get_mem_op_value_le(generic_transaction_t *mem_op) $/;"	f
SIM_get_num_exceptions	simdist12.C	/^int    SIM_get_num_exceptions() { $/;"	f
SIM_get_object	simdist12.C	/^SIM_get_object(const char *name) {$/;"	f
SIM_get_pending_exception	simdist12.C	/^sim_exception_t SIM_get_pending_exception() {$/;"	f
SIM_get_proc_no	simdist12.C	/^int          SIM_get_proc_no(const processor_t *cpu_ptr) { $/;"	f
SIM_get_proc_no_on_node	simdist12.C	/^int          SIM_get_proc_no_on_node(const processor_t *ptr) {$/;"	f
SIM_get_processor	simdist12.C	/^conf_object_t *SIM_get_processor(int p) {$/;"	f
SIM_get_processor	simdist12.C	/^processor_t *SIM_get_processor(int p, int n) {$/;"	f
SIM_get_program_counter	simdist12.C	/^la_t   SIM_get_program_counter(processor_t *cpu) {$/;"	f
SIM_get_register_name	simdist12.C	/^const char  *SIM_get_register_name(conf_object_t *cpu_ptr, int reg) {$/;"	f
SIM_get_register_number	simdist12.C	/^int    SIM_get_register_number(conf_object_t *cpu_ptr, const char *regname)  {$/;"	f
SIM_get_stack_pointer	simdist12.C	/^la_t   SIM_get_stack_pointer(processor_t *cpu)  {$/;"	f
SIM_hap_add_callback	simdist12.C	/^hap_handle_t SIM_hap_add_callback(const char *hap,$/;"	f
SIM_hap_add_callback_index	simdist12.C	/^hap_handle_t SIM_hap_add_callback_index(const char *hap,$/;"	f
SIM_hap_delete_callback_id	simdist12.C	/^void SIM_hap_delete_callback_id(const char *hap, hap_handle_t handle){$/;"	f
SIM_hap_get_number	simdist12.C	/^hap_type_t SIM_hap_get_number(const char *id){$/;"	f
SIM_hap_install_callback	simdist12.C	/^hap_handle_t SIM_hap_install_callback(hap_type_t hap, hap_func_t cb, lang_void *data) {$/;"	f
SIM_hap_install_callback_idx	simdist12.C	/^hap_handle_t SIM_hap_install_callback_idx(hap_type_t hap, hap_func_t cb, int64 idx, lang_void *data) {$/;"	f
SIM_hap_install_callback_on_cpu	simdist12.C	/^hap_handle_t SIM_hap_install_callback_on_cpu(hap_type_t hap, hap_func_t cb, processor_t *cpu, lang_void *data) {$/;"	f
SIM_hap_new_type	simdist12.C	/^hap_type_t SIM_hap_new_type(const char *id, const char *params, $/;"	f
SIM_hap_occurred	simdist12.C	/^int SIM_hap_occurred(hap_type_t hap, conf_object_t * obj, integer_t value, attr_value_t *list)$/;"	f
SIM_hap_register_callback_idx	simdist12.C	/^hap_handle_t SIM_hap_register_callback_idx(const char *id, str_hap_func_t cb, integer_t idx, lang_void *data)$/;"	f
SIM_hap_remove_callback	simdist12.C	/^void SIM_hap_remove_callback(hap_type_t hap, hap_handle_t hdl) {$/;"	f
SIM_last_error	simdist12.C	/^const char *SIM_last_error() {$/;"	f
SIM_logical_to_physical	simdist12.C	/^physical_address_t SIM_logical_to_physical(processor_t *cpu_ptr, data_or_instr_t data_or_instr, logical_address_t address) {$/;"	f
SIM_memory_add_watchpoint	simdist12.C	/^void   SIM_memory_add_watchpoint(pa_t addr, int read, int write, int execute, pa_t length) { UNIMPL; }$/;"	f
SIM_memory_clear_watchpoint	simdist12.C	/^void   SIM_memory_clear_watchpoint(pa_t addr, int read, int write, int execute, pa_t length) { UNIMPL; }$/;"	f
SIM_new_object	simdist12.C	/^SIM_new_object(conf_class_t *conf_class, const char *instance_name) {$/;"	f
SIM_next_queue	simdist12.C	/^SIM_next_queue(conf_object_t * obj){$/;"	f
SIM_number_processors	simdist12.C	/^int  SIM_number_processors() {$/;"	f
SIM_object_constructor	simdist12.C	/^SIM_object_constructor(conf_object_t *, parse_object_t *) {$/;"	f
SIM_printf	simdist12.C	/^int SIM_printf( const char *fmt, ...)$/;"	f
SIM_proc_no_2_ptr	simdist12.C	/^conf_object_t *SIM_proc_no_2_ptr(int id) {$/;"	f
SIM_processor_break	simdist12.C	/^void SIM_processor_break(processor_t *, integer_t) { UNIMPL; }$/;"	f
SIM_profiling_info	simdist12.C	/^attr_value_t SIM_profiling_info(pa_t addr, pa_t length)$/;"	f
SIM_raise_general_exception	simdist12.C	/^void SIM_raise_general_exception(const char *str)$/;"	f
SIM_read_phys_memory	simdist12.C	/^uinteger_t SIM_read_phys_memory(processor_t *cpu, physical_address_t address, int len) {$/;"	f
SIM_read_register	simdist12.C	/^ireg_t SIM_read_register(conf_object_t *cpu_ptr, int indx)  { UNIMPL; return (0); }$/;"	f
SIM_register_attribute	simdist12.C	/^int SIM_register_attribute(conf_class_t *, const char *, attr_value_t (*)(void *, conf_object_t *, attr_value_t *), void *, set_error_t (*)(void *, conf_object_t *, attr_value_t *, attr_value_t *), void *, attr_attr_t, const char *) {$/;"	f
SIM_register_class	simdist12.C	/^SIM_register_class(const char *name, class_data_t *class_data) {$/;"	f
SIM_register_interface	simdist12.C	/^SIM_register_interface(conf_class_t *class_struct, const char *interface_name, void *interface) {$/;"	f
SIM_set_attribute	simdist12.C	/^SIM_set_attribute(conf_object_t *object, const char *name, attr_value_t *value) {$/;"	f
SIM_set_program_counter	simdist12.C	/^void   SIM_set_program_counter(processor_t *cpu, logical_address_t pc) {$/;"	f
SIM_stall_cycle	simdist12.C	/^void SIM_stall_cycle(conf_object_t *obj, cycles_t stall) {$/;"	f
SIM_step_count	simdist12.C	/^pc_step_t SIM_step_count( conf_object_t *obj ) {$/;"	f
SIM_step_post	simdist12.C	/^void SIM_step_post(conf_object_t * obj, $/;"	f
SIM_time_post_cycle	simdist12.C	/^void SIM_time_post_cycle(conf_object_t * obj, $/;"	f
SIM_write	simdist12.C	/^int SIM_write(const void *ptr, int size)$/;"	f
SIM_write_phys_memory	simdist12.C	/^  void SIM_write_phys_memory(processor_t *cpu, physical_address_t address, uinteger_t value, int len) {$/;"	f
SIM_write_register	simdist12.C	/^void   SIM_write_register(conf_object_t *cpu_ptr, int indx, ireg_t value)  { printf("Shit, this is useless!\\n" ) ; UNIMPL; }$/;"	f
SINGLE_ARF	arf.h	71;"	d
SIVA_LOAD_BUFFER_DEBUG	diagnosis.C	35;"	d	file:
SIVA_LOAD_BUFFER_DEBUG	memop.C	88;"	d	file:
SI_BIT0	statici.h	/^const byte_t  SI_BIT0         = 1 << 0;$/;"	v
SI_CC_RID	statici.C	123;"	d	file:
SI_COMPLEX_OP	statici.h	/^const byte_t  SI_COMPLEX_OP   = 1 << 6;$/;"	v
SI_CONDITIONAL_PRINT	statici.C	657;"	d	file:
SI_DOUBLE_RID	statici.C	110;"	d	file:
SI_FETCH_BARRIER	statici.h	/^const byte_t  SI_FETCH_BARRIER= 1 << 5;$/;"	v
SI_INT_RID	statici.C	97;"	d	file:
SI_ISASI	statici.h	/^const byte_t  SI_ISASI        = 1 << 2;$/;"	v
SI_ISIMMEDIATE	statici.h	/^const byte_t  SI_ISIMMEDIATE  = 1 << 1;$/;"	v
SI_MAX_DEST	statici.h	/^const int     SI_MAX_DEST   = 2;$/;"	v
SI_MAX_PREDECESSORS	sstat.h	/^const int32     SI_MAX_PREDECESSORS = 4;$/;"	v
SI_MAX_SIZE	statici.h	/^const uint32  SI_MAX_SIZE     =   1<<SI_SIZE_BITS;$/;"	v
SI_MAX_SOURCE	statici.h	/^const int     SI_MAX_SOURCE = 4;$/;"	v
SI_MAX_SUCCESSORS	sstat.h	/^const int32     SI_MAX_SUCCESSORS   = 8;$/;"	v
SI_QUAD_RID	statici.C	118;"	d	file:
SI_READASI	statici.C	143;"	d	file:
SI_READ_CONTROL	statici.C	137;"	d	file:
SI_READ_ICC	statici.C	151;"	d	file:
SI_READ_Y	statici.C	159;"	d	file:
SI_RESET	statici.C	341;"	d	file:
SI_SINGLE_RID	statici.C	105;"	d	file:
SI_SIZE_BITS	statici.h	/^const uint32  SI_SIZE_BITS    =     7;$/;"	v
SI_STATICPRED	statici.h	/^const byte_t  SI_STATICPRED   = 1 << 2;$/;"	v
SI_TOFREE	statici.h	/^const byte_t  SI_TOFREE       = 1 << 7;$/;"	v
SI_UPDATE_CWP	statici.h	/^const byte_t  SI_UPDATE_CWP   = 1 << 3;$/;"	v
SI_WRITE_CONTROL	statici.C	128;"	d	file:
SI_WRITE_CONTROL	statici.h	/^const byte_t  SI_WRITE_CONTROL= 1 << 4;$/;"	v
SI_WRITE_FSR	statici.C	114;"	d	file:
SI_WRITE_ICC	statici.C	155;"	d	file:
SI_WRITE_Y	statici.C	163;"	d	file:
SLICE_FAULTS_TILL	pseq.h	2021;"	d
SOURCE1_INDEX	dynamic.h	/^  enum reg_index_t {SOURCE1_INDEX, SOURCE2_INDEX, TO_FREE_INDEX, DEST_INDEX};$/;"	e	enum:dynamic_inst_t::reg_index_t
SOURCE2_INDEX	dynamic.h	/^  enum reg_index_t {SOURCE1_INDEX, SOURCE2_INDEX, TO_FREE_INDEX, DEST_INDEX};$/;"	e	enum:dynamic_inst_t::reg_index_t
SRC_REG	pseq.C	113;"	d	file:
STATIC_ZERO_REG	statici.C	/^const int STATIC_ZERO_REG = 0;$/;"	v
STAT_COHERENCE_INVALID	memstat.h	/^  STAT_COHERENCE_INVALID,$/;"	e	enum:stat_coherence_state_t
STAT_COHERENCE_MODIFIED	memstat.h	/^  STAT_COHERENCE_MODIFIED$/;"	e	enum:stat_coherence_state_t
STAT_COHERENCE_SHARED	memstat.h	/^  STAT_COHERENCE_SHARED,$/;"	e	enum:stat_coherence_state_t
STAT_EST_MEMORY_LATENCY	sysstat.C	/^const int32 STAT_EST_MEMORY_LATENCY = 10000;$/;"	v
STAT_INC	ix.C	107;"	d	file:
STAT_INC	ix.C	109;"	d	file:
STAT_IO_THREAD_ADDR	sysstat.C	/^const la_t STAT_IO_THREAD_ADDR = 0x10dec1ce;$/;"	v
STAT_IO_THREAD_ID	sysstat.C	/^const la_t STAT_IO_THREAD_ID   = (la_t) -1776;$/;"	v
STORE_DEMAND_PRIORITY	mshr.h	/^                       STORE_DEMAND_PRIORITY,   \/* processor store data  *\/$/;"	e	enum:mshr_priority_t
STORE_OP_GET	dx.C	91;"	d	file:
STORE_OP_GET	ix.C	93;"	d	file:
STORE_OP_TYPE	dx.C	90;"	d	file:
STORE_OP_TYPE	ix.C	92;"	d	file:
STREAM_BUFFER_SIZE	mshr.h	/^const word_t STREAM_BUFFER_SIZE = 4;$/;"	v
SVAAddr	inv-defs.h	/^struct SVAAddr {$/;"	s
SVAAddrFile	pseq.h	/^  std::ifstream *SVAAddrFile;$/;"	m	class:pseq_t
SVAAddrMap	inv-defs.h	/^typedef map<string, SVAAddr*> SVAAddrMap;  $/;"	t
SYMPTOM_IN_LOGGING_PHASE	diagnosis.h	18;"	d
SYSTEM_EXIT	system.h	521;"	d
Schedule	dynamic.C	/^dynamic_inst_t::Schedule() { $/;"	f	class:dynamic_inst_t
ScheduleBusTransfer	mshr.C	/^mshr_t::ScheduleBusTransfer(miss_t *m) {$/;"	f	class:mshr_t
Set	cache.h	/^  inline uint32 Set(pa_t a) { return (set_mask & (pa_t) (a >> block_bits));  }$/;"	f	class:generic_cache_template
SetLRU	mshr.C	/^void replacement_manager_t<Type>::SetLRU(Type *t) {$/;"	f	class:replacement_manager_t
SetMRU	mshr.C	/^void replacement_manager_t<Type>::SetMRU(Type *t) {$/;"	f	class:replacement_manager_t
SetPriority	wait.h	/^  void SetPriority(uint64 _priority) { priority = _priority; }$/;"	f	class:waiter_t
SetStage	dynamic.C	/^void dynamic_inst_t::SetStage(enum stage_t stage)$/;"	f	class:dynamic_inst_t
Squash	controlop.C	/^control_inst_t::Squash() { $/;"	f	class:control_inst_t
Squash	dynamic.C	/^dynamic_inst_t::Squash() { $/;"	f	class:dynamic_inst_t
Squash	memop.C	/^memory_inst_t::Squash() {$/;"	f	class:memory_inst_t
StoreValueArray	inv-defs.h	/^}StoreValueArray;$/;"	t	typeref:union:__anon19
StreamPrefetch	mshr.C	/^mshr_t::StreamPrefetch(pa_t a) {$/;"	f	class:mshr_t
TAGS_IDX	pseq.h	72;"	d
THRESHOLD_NUM_INTERRUPTS	diagnosis.C	30;"	d	file:
TMRStepTriggered	diagnosis.h	/^		void TMRStepTriggered(uint32 core_id) {trigger_tmr_step[core_id] = false;}$/;"	f	class:multicore_diagnosis_t
TOTAL_INSTR_MODE	pseq.h	/^  static const uint32 TOTAL_INSTR_MODE = 3;$/;"	m	class:pseq_t
TO_FREE_INDEX	dynamic.h	/^  enum reg_index_t {SOURCE1_INDEX, SOURCE2_INDEX, TO_FREE_INDEX, DEST_INDEX};$/;"	e	enum:dynamic_inst_t::reg_index_t
TRACK_CYCLE	pseq.h	2407;"	d
TRANSFER_STATE	mshr.h	/^                    TRANSFER_STATE, \/* waiting for bus transfer                           *\/$/;"	e	enum:miss_state_t
TRAP_RATE	pseq.h	87;"	d
TRAP_RATE_RESET	pseq.h	88;"	d
Tag	cache.h	/^  inline pa_t   Tag(pa_t a) { return (a >> (set_bits + block_bits));  }$/;"	f	class:generic_cache_template
TagCheck	cache.h	/^  inline bool TagCheck(pa_t a) {$/;"	f	class:generic_cache_template
TagSearch	cache.C	/^bool generic_cache_template<BlockType>::TagSearch(pa_t a, bool setMRU, bool setDirty,$/;"	f	class:generic_cache_template
Tick	mshr.C	/^mshr_t::Tick() {$/;"	f	class:mshr_t
Type	inv-defs.h	/^  char Type[10];$/;"	m	struct:Invariant
Type	inv-defs.h	/^  char Type[10];$/;"	m	struct:MulRangeInvariant
UNIMPL	simdist12.C	77;"	d	file:
UNKNOWN_ARF	arf.h	67;"	d
UNKNOWN_REG_FILE	regfile.h	69;"	d
UPDATE_FSR	dx.C	95;"	d	file:
UPDATE_FSR	ix.C	97;"	d	file:
UnwindRegisters	dynamic.C	/^dynamic_inst_t::UnwindRegisters( void )$/;"	f	class:dynamic_inst_t
UpgradePriorityIfNecessary	mshr.C	/^mshr_t::UpgradePriorityIfNecessary(miss_t* m, mshr_priority_t p) {$/;"	f	class:mshr_t
VALUE_START	pseq.h	76;"	d
VERBOSE_IN_CHECK	pseq.C	111;"	d	file:
VICTIM_STATE	mshr.h	/^                    VICTIM_STATE,   \/* finished demand miss                               *\/$/;"	e	enum:miss_state_t
VPC	diagnosis.h	/^	uint64 VPC;$/;"	m	struct:__anon4
VPC	diagnosis.h	/^	uint64 VPC;$/;"	m	struct:__anon7
VPC	diagnosis.h	/^    la_t VPC;$/;"	m	struct:__anon2
VPC	pseq.h	/^    la_t VPC;$/;"	m	struct:__anon23
VerifyMSHR	mshr.C	/^mshr_t::VerifyMSHR() {$/;"	f	class:mshr_t
WAIT_1ST_STAGE	dynamic.h	/^    WAIT_1ST_STAGE,$/;"	e	enum:dynamic_inst_t::stage_t
WAIT_2ND_STAGE	dynamic.h	/^    WAIT_2ND_STAGE,$/;"	e	enum:dynamic_inst_t::stage_t
WAIT_3RD_STAGE	dynamic.h	/^    WAIT_3RD_STAGE,$/;"	e	enum:dynamic_inst_t::stage_t
WAIT_4TH_STAGE	dynamic.h	/^    WAIT_4TH_STAGE,$/;"	e	enum:dynamic_inst_t::stage_t
WAIT_STATE	mshr.h	/^                    WAIT_STATE,     \/* waiting for lower level cache access               *\/$/;"	e	enum:miss_state_t
WARN_OUT_OF_RANGE	regbox.h	66;"	d
WRITE_TWO_F	statici.C	276;"	d	file:
WRITE_TWO_I	statici.C	245;"	d	file:
Waiting	wait.h	/^  bool Waiting() const { return (prev != NULL); }$/;"	f	class:waiter_t
Wakeup	dynamic.C	/^void dynamic_inst_t::Wakeup( void )$/;"	f	class:dynamic_inst_t
Wakeup	mshr.C	/^miss_t::Wakeup() {$/;"	f	class:miss_t
Wakeup	pseq.C	/^void pseq_t::Wakeup( void )$/;"	f	class:pseq_t
Wakeup	ptrace.C	/^void pt_memory_waiter_t::Wakeup( void )$/;"	f	class:pt_memory_waiter_t
Wakeup	rubycache.C	/^void rubycache_t::Wakeup( void )$/;"	f	class:rubycache_t
Wakeup	wait.h	/^  void Wakeup() { SIM_HALT; }$/;"	f	class:tail_waiter_t
WakeupChain	wait.C	/^wait_list_t::WakeupChain() {$/;"	f	class:wait_list_t
Warmup	cache.C	/^void generic_cache_template<BlockType>::Warmup(pa_t a) {$/;"	f	class:generic_cache_template
Write	cache.C	/^bool generic_cache_template<BlockType>::Write(pa_t a, waiter_t *w) {$/;"	f	class:generic_cache_template
_ACTOR_H_	actor.h	56;"	d
_ARF_H_	arf.h	56;"	d
_CACHE_H_	cache.h	56;"	d
_CHAIN_H_	chain.h	56;"	d
_CHECK_RESULT_H_	checkresult.h	56;"	d
_CONTROLOP_H_	controlop.h	56;"	d
_DECODEFAULT_H_	decodefault.h	6;"	d
_DECODE_H_	decode.h	56;"	d
_DEPENCENCY_H_	dependence.h	56;"	d
_DTLB_H_	dtlb.h	56;"	d
_DX_H_	dx.h	56;"	d
_DYNAMIC_H_	dynamic.h	56;"	d
_FAULT_H_	fault.h	9;"	d
_FLATARF_H_	flatarf.h	56;"	d
_FLOW_H_	flow.h	56;"	d
_HFA_INIT_H_	hfa_init.h	56;"	d
_HISTOGRAM_H_	histogram.h	57;"	d
_INV	inv-defs.h	2;"	d
_IPAGEMAP_H_	ipagemap.h	56;"	d
_IPAGE_H_	ipage.h	56;"	d
_IWINDOW_H_	iwindow.h	56;"	d
_IX_H_	ix.h	56;"	d
_LOCKSTAT_H_	lockstat.h	56;"	d
_LSQ_H_	lsq.h	56;"	d
_MEMOP_H_	memop.h	56;"	d
_MEMSTAT_H_	memstat.h	56;"	d
_MF_MEMORY_API_H_	mf_api.h	66;"	d
_MSHR_H_	mshr.h	56;"	d
_PIPEPOOL_H_	pipepool.h	56;"	d
_PIPESTATE_H_	pipestate.h	56;"	d
_PSEQ_H_	pseq.h	56;"	d
_PSTATE_H_	pstate.h	56;"	d
_PTRACE_H_	ptrace.h	56;"	d
_REGFILE_H_	regfile.h	56;"	d
_REG_BOX_H_	regbox.h	56;"	d
_REG_MAP_H_	regmap.h	56;"	d
_RUBYCACHE_H_	rubycache.h	56;"	d
_SCHEDULER_H_	scheduler.h	56;"	d
_SSTAT_H_	sstat.h	56;"	d
_STATICI_H_	statici.h	56;"	d
_STOPWATCH_H_	stopwatch.h	56;"	d
_SYSSTATS_H_	sysstat.h	56;"	d
_THREADSTAT_H_	threadstat.h	56;"	d
_WAITER_H_	wait.h	56;"	d
__AMBER_API_H__	amber_api.h	2;"	d
__CRC16_H__	crc16.h	2;"	d
__SYSTEM_H	system.h	56;"	d
__l64_p64_vtvfprintf	simdist12.C	/^int __l64_p64_vtvfprintf(FILE *stream, const char *format, va_list va)$/;"	f
__no_tgt_vtvfprintf	simdist12.C	/^int __no_tgt_vtvfprintf(FILE *stream, const char *format, va_list va)$/;"	f
__sparc_v9_vtdebug_log_vararg	simdist12.C	/^void __sparc_v9_vtdebug_log_vararg(int param, log_object_t *loggy, const char *format, va_list va)$/;"	f
__sparc_v9_vtvfprintf	simdist12.C	/^int __sparc_v9_vtvfprintf(FILE *stream, const char *format, va_list va)$/;"	f
a_fanout	pseq.h	/^		uint64 a_fanout ;$/;"	m	struct:pseq_t::ddg_a_stats
a_lifetime	pseq.h	/^		uint64 a_lifetime ;$/;"	m	struct:pseq_t::ddg_a_stats
a_size	pseq.h	/^		uint64 a_size ;$/;"	m	struct:pseq_t::ddg_a_stats
abortCallback	mf_api.h	/^  void (*abortCallback)( int cpuNumber );$/;"	m	struct:mf_opal_api
abstract_rf_t	arf.h	/^  abstract_rf_t( physical_file_t *rf, reg_map_t *decode_map, $/;"	f	class:abstract_rf_t
abstract_rf_t	arf.h	/^class abstract_rf_t {$/;"	c
access	rubycache.C	/^ruby_status_t rubycache_t::access( pa_t physical_address,$/;"	f	class:rubycache_t
accessCache	memop.C	/^load_inst_t::accessCache( void ) {$/;"	f	class:load_inst_t
accessCache	memop.C	/^prefetch_inst_t::accessCache( void ) {$/;"	f	class:prefetch_inst_t
accessCache	memop.C	/^store_inst_t::accessCache( void ) {$/;"	f	class:store_inst_t
access_size	pseq.h	/^    int access_size; $/;"	m	struct:__anon24
accesses	cache.h	/^  uint64 accesses;$/;"	m	class:cache_t
account_flips	statici.C	/^static_inst_t::account_flips(string s, bool vlog_valid, uint64 vlog, uint64 opal, fault_stats *fs, int* num_flips) {$/;"	f	class:static_inst_t
act_schedule_t	actor.C	/^act_schedule_t::act_schedule_t( pseq_t *seq, int32 queue_size ) :$/;"	f	class:act_schedule_t
act_schedule_t	actor.h	/^class act_schedule_t : public actor_t {$/;"	c
act_tick	actor.C	/^void act_schedule_t::act_tick( void )$/;"	f	class:act_schedule_t
act_tick	actor.C	/^void actor_t::act_tick( void )$/;"	f	class:actor_t
act_wakeup	actor.C	/^void act_schedule_t::act_wakeup( dynamic_inst_t *inst )$/;"	f	class:act_schedule_t
act_wakeup	actor.C	/^void actor_t::act_wakeup( dynamic_inst_t *inst )$/;"	f	class:actor_t
action	system.h	/^  breakpointf_t  action;$/;"	m	struct:breakpoint_action
activate_fault	dynamic.h	/^  bool activate_fault ;$/;"	m	class:dynamic_inst_t
actor_t	actor.C	/^actor_t::actor_t( pseq_t *seq, int32 queue_size )$/;"	f	class:actor_t
actor_t	actor.h	/^class actor_t {$/;"	c
actualPC_branch	statici.C	/^void   static_inst_t::actualPC_branch( bool isTaken,$/;"	f	class:static_inst_t
actualPC_cwp	statici.C	/^void   static_inst_t::actualPC_cwp( abstract_pc_t *a )$/;"	f	class:static_inst_t
actualPC_execute	statici.C	/^void   static_inst_t::actualPC_execute( abstract_pc_t *a )$/;"	f	class:static_inst_t
actualPC_indirect	statici.C	/^void   static_inst_t::actualPC_indirect( my_addr_t  effective_addr,$/;"	f	class:static_inst_t
actualPC_trap	statici.C	/^void   static_inst_t::actualPC_trap( bool       isTaken,$/;"	f	class:static_inst_t
actualPC_trap_return	statici.C	/^void   static_inst_t::actualPC_trap_return( abstract_pc_t *a,$/;"	f	class:static_inst_t
actualPC_uncond_branch	statici.C	/^void   static_inst_t::actualPC_uncond_branch( bool isTaken,$/;"	f	class:static_inst_t
add	flow.C	/^void cfg_list_t::add( flow_inst_t *node )$/;"	f	class:cfg_list_t
addChild	ddg.C	/^void ddg_node_t::addChild(ddg_node_t* C) $/;"	f	class:ddg_node_t
addDependentLoad	memop.h	/^  void addDependentLoad(memory_inst_t *l) {$/;"	f	class:store_inst_t
addFreelist	arf.C	/^void    abstract_rf_t::addFreelist( reg_id_t &rid )$/;"	f	class:abstract_rf_t
addFreelist	arf.C	/^void    arf_container_t::addFreelist( reg_id_t &rid )$/;"	f	class:arf_container_t
addFreelist	arf.C	/^void    arf_control_t::addFreelist( reg_id_t &rid )$/;"	f	class:arf_control_t
addFreelist	arf.C	/^void    arf_double_t::addFreelist( reg_id_t &rid )$/;"	f	class:arf_double_t
addFreelist	flatarf.C	/^void    flat_rf_t::addFreelist( reg_id_t &rid ) {$/;"	f	class:flat_rf_t
addFreelist	regmap.C	/^reg_map_t::addFreelist( uint16 id )$/;"	f	class:reg_map_t
addLLBEntry	diagnosis.C	/^bool llb_t::addLLBEntry(uint64 address, uint64 value)$/;"	f	class:llb_t
addLLBEntry	pseq.C	/^bool pseq_t::addLLBEntry(uint64 physical_address, uint64 *value, int num_values)$/;"	f	class:pseq_t
addLLBEntry	pseq.C	/^bool pseq_t::addLLBEntry(uint64 physical_address, uint64 value)$/;"	f	class:pseq_t
addMemRec	pseq.C	/^void pseq_t::addMemRec(uint64 pc, bool isLoad, uint64 address, uint64 data)$/;"	f	class:pseq_t
addOverlapLoad	memop.h	/^  void addOverlapLoad(memory_inst_t * i){$/;"	f	class:store_inst_t
addParent	ddg.C	/^void ddg_node_t::addParent(ddg_node_t* D)$/;"	f	class:ddg_node_t
addPredecessor	flow.h	/^  void    addPredecessor( flow_inst_t *predecessor ) {$/;"	f	class:flow_inst_t
addRegister	arf.C	/^void  arf_container_t::addRegister( rid_type_t regtype, int32 offset,$/;"	f	class:arf_container_t
addRegister	flatarf.C	/^void    flat_container_t::addRegister( rid_type_t regtype, int32 offset, abstract_rf_t *arf )$/;"	f	class:flat_container_t
addRegisterHandler	regbox.C	/^void    reg_box_t::addRegisterHandler( rid_type_t       rtype,$/;"	f	class:reg_box_t
addRetirePC	pseq.C	/^void pseq_t::addRetirePC(la_t pc)$/;"	f	class:pseq_t
addSpecialChild	ddg.C	/^void ddg_node_t::addSpecialChild(ddg_node_t *C)$/;"	f	class:ddg_node_t
addSubTreeNodes	pseq.C	/^void pseq_t::addSubTreeNodes(ddg_node_t *N, uint64_set_t &subtree_nodes)$/;"	f	class:pseq_t
addSuccessor	flow.h	/^  void    addSuccessor( flow_inst_t *successor ) {$/;"	f	class:flow_inst_t
addThreadConsumer	memstat.C	/^void mem_stat_t::addThreadConsumer( int16 producer_id, int16 thread_id, $/;"	f	class:mem_stat_t
addToReducedFaultSet	pseq.C	/^void pseq_t::addToReducedFaultSet(fault_t *fault)$/;"	f	class:pseq_t
addTranslation	dtlb.C	/^void dtlb_t::addTranslation( la_t va, context_id_t context, $/;"	f	class:dtlb_t
add_unique	flow.C	/^void cfg_list_t::add_unique( flow_inst_t *node )$/;"	f	class:cfg_list_t
addr	diagnosis.h	/^	uint64 addr;$/;"	m	struct:llb_queue_entry
addrOverlapWait	memop.C	/^atomic_inst_t::addrOverlapWait(store_inst_t * depend){$/;"	f	class:atomic_inst_t
addrOverlapWait	memop.C	/^load_inst_t::addrOverlapWait(store_inst_t * depend){$/;"	f	class:load_inst_t
addr_cmp	pseq.h	/^	struct addr_cmp {$/;"	s	class:pseq_t
addr_list	pseq.h	/^	addr_list_t addr_list ;$/;"	m	class:pseq_t
addr_list_t	pseq.h	/^	typedef vector<la_t> addr_list_t ;$/;"	t	class:pseq_t
addr_parity	diagnosis.h	/^	bool addr_parity;$/;"	m	struct:llb_queue_entry
addr_producer_fault	pseq.h	/^		uint64 addr_producer_fault ;$/;"	m	struct:pseq_t::slice_inst
address	diagnosis.h	/^	uint64 address; \/\/ for branch this is considered as target$/;"	m	struct:__anon12
address	pseq.h	/^		la_t address ;$/;"	m	struct:pseq_t::fault
address	pseq.h	/^		la_t address ;$/;"	m	struct:pseq_t::slice_inst
address	pseq.h	/^    uint64 address;$/;"	m	struct:__anon21
address	pseq.h	/^    uint64 address;$/;"	m	struct:__anon24
address	system.h	/^  la_t           address;$/;"	m	struct:breakpoint_action
addressGenerate	memop.C	/^memory_inst_t::addressGenerate( OpalMemop_t accessType )$/;"	f	class:memory_inst_t
addressMasked	controlop.h	/^  bool addressMasked() {$/;"	f	class:control_inst_t
addressOverlap	memop.C	/^memory_inst_t::addressOverlap( memory_inst_t *other )$/;"	f	class:memory_inst_t
address_state	cache.h	/^  pa_t      address_state;$/;"	m	class:generic_cache_block_t
advanceCycle	pseq.C	/^void pseq_t::advanceCycle( void )$/;"	f	class:pseq_t
advancePC	flow.C	/^void flow_inst_t::advancePC( void )$/;"	f	class:flow_inst_t
advanceSimics	pseq.C	/^bool pseq_t::advanceSimics( void )$/;"	f	class:pseq_t
advanceTime	mf_api.h	/^  void (*advanceTime)( void );$/;"	m	struct:mf_ruby_api
advanceTimeout	rubycache.C	/^void rubycache_t::advanceTimeout( void )$/;"	f	class:rubycache_t
agen_counter	pseq.h	/^  int      agen_counter;$/;"	m	class:pseq_t
aggressiveInvInpFile	pseq.h	/^  std::ifstream *aggressiveInvInpFile, *conservativeInvInpFile, *conservativeMulRangeInvInpFile;$/;"	m	class:pseq_t
aggressiveInvMap	pseq.h	/^  InvMap aggressiveInvMap, conservativeInvMap;  $/;"	m	class:pseq_t
agu	diagnosis.h	/^	int agu;$/;"	m	struct:__anon2
agu	diagnosis.h	/^	int agu;$/;"	m	struct:__anon5
agu_bin	diagnosis.h	/^	int *agu_bin;$/;"	m	class:diagnosis_t
all_reg_faults	pseq.h	/^	unsigned long all_reg_faults ;$/;"	m	class:pseq_t
allocate	chain.C	/^void chain_t::allocate( void )$/;"	f	class:chain_t
allocateFlatRegBox	pseq.C	/^void pseq_t::allocateFlatRegBox( mstate_t &inorder )$/;"	f	class:pseq_t
allocateIdealState	pseq.C	/^void pseq_t::allocateIdealState( void )$/;"	f	class:pseq_t
allocateRegBox	pseq.C	/^void pseq_t::allocateRegBox( mstate_t &ooo )$/;"	f	class:pseq_t
allocateRegister	arf.C	/^bool    abstract_rf_t::allocateRegister( reg_id_t &rid )$/;"	f	class:abstract_rf_t
allocateRegister	arf.C	/^bool    arf_container_t::allocateRegister( reg_id_t &rid )$/;"	f	class:arf_container_t
allocateRegister	arf.C	/^bool    arf_control_t::allocateRegister( reg_id_t &rid )$/;"	f	class:arf_control_t
allocateRegister	arf.C	/^bool    arf_double_t::allocateRegister( reg_id_t &rid )$/;"	f	class:arf_double_t
allocateRegister	arf.h	/^  bool    allocateRegister( reg_id_t &rid ) { return (true); }$/;"	f	class:arf_none_t
allocateRegister	flatarf.C	/^bool    flat_rf_t::allocateRegister( reg_id_t &rid ) {$/;"	f	class:flat_rf_t
allow_arch_state_mismatch_msg	pseq.h	/^  bool allow_arch_state_mismatch_msg;$/;"	m	class:pseq_t
allow_inv_violation_msg	pseq.h	/^  bool allow_inv_violation_msg;$/;"	m	class:pseq_t
alu_bin	diagnosis.h	/^	int alu_bin[NUM_FU_TYPE][NUM_FU_UNIT];$/;"	m	class:diagnosis_t
amap_search	chain.C	/^int64 chain_t::amap_search( flow_inst_t *flow_inst )$/;"	f	class:chain_t
amap_store	chain.C	/^void chain_t::amap_store(flow_inst_t *flow_inst, int64 depth)$/;"	f	class:chain_t
amber_api_t	amber_api.h	/^} amber_api_t ;$/;"	t	typeref:struct:mf_amber_api
analyzeDependence	chain.C	/^void chain_t::analyzeDependence( void )$/;"	f	class:chain_t
analyzeTrace	diagnosis.C	/^void diagnosis_t::analyzeTrace() {$/;"	f	class:diagnosis_t
analyzeWindow	chain.C	/^void chain_t::analyzeWindow( void )$/;"	f	class:chain_t
app_inst	pseq.h	/^  uint64 app_inst;$/;"	m	class:pseq_t
appl_name	inv-defs.h	/^  char appl_name[100];$/;"	m	struct:SVAAddr
arch_cycle	fault.h	/^		tick_t arch_cycle ;	\/\/ Cycle that this fault was architecturally visible$/;"	m	class:Fault
areCompareLogElementsSame	diagnosis.C	/^bool multicore_diagnosis_t::areCompareLogElementsSame(compare_log_element_t a, compare_log_element_t b)$/;"	f	class:multicore_diagnosis_t
arf_cc_t	arf.h	/^  arf_cc_t( physical_file_t *rf, reg_map_t *decode_map, $/;"	f	class:arf_cc_t
arf_cc_t	arf.h	/^class arf_cc_t : public abstract_rf_t {$/;"	c
arf_container_t	arf.h	/^  arf_container_t( fault_stats *fault_stat\/*void*\/ ) :$/;"	f	class:arf_container_t
arf_container_t	arf.h	/^class arf_container_t : public abstract_rf_t {$/;"	c
arf_control_t	arf.h	/^  arf_control_t( physical_file_t **rf_array, uint32 count, fault_stats *fault_stat ) :$/;"	f	class:arf_control_t
arf_control_t	arf.h	/^class arf_control_t : public abstract_rf_t {$/;"	c
arf_double_t	arf.h	/^  arf_double_t( physical_file_t *rf, reg_map_t *decode_map, $/;"	f	class:arf_double_t
arf_double_t	arf.h	/^class arf_double_t : public abstract_rf_t {$/;"	c
arf_int_global_t	arf.h	/^  arf_int_global_t( physical_file_t *rf, reg_map_t *decode_map, $/;"	f	class:arf_int_global_t
arf_int_global_t	arf.h	/^class arf_int_global_t : public abstract_rf_t {$/;"	c
arf_int_t	arf.h	/^  arf_int_t( physical_file_t *rf, reg_map_t *decode_map, $/;"	f	class:arf_int_t
arf_int_t	arf.h	/^class arf_int_t : public abstract_rf_t {$/;"	c
arf_none_t	arf.h	/^  arf_none_t( physical_file_t *rf, reg_map_t *decode_map, $/;"	f	class:arf_none_t
arf_none_t	arf.h	/^class arf_none_t : public abstract_rf_t {$/;"	c
arf_single_t	arf.h	/^  arf_single_t( physical_file_t *rf, reg_map_t *decode_map, $/;"	f	class:arf_single_t
arf_single_t	arf.h	/^class arf_single_t : public abstract_rf_t {$/;"	c
arf_type	arf.h	/^  int arf_type;$/;"	m	class:abstract_rf_t
as_float	regfile.h	/^            float32  as_float;$/;"	m	union:physical_reg_t::__anon25
as_int	regfile.h	/^            ireg_t   as_int;$/;"	m	union:physical_reg_t::__anon25
askSimics	pstate.C	/^void pstate_t::askSimics( uint32 instr, pa_t paddr, la_t addr )$/;"	f	class:pstate_t
assert_fail	statici.h	/^	bool      assert_fail ;$/;"	m	class:static_inst_t
async_exception_menomic	pstate.C	/^const char *pstate_t::async_exception_menomic( exception_t except_type ) {$/;"	f	class:pstate_t
at	checkresult.h	/^  abstract_pc_t       at;$/;"	m	class:mstate_t
atomic	memstat.C	/^void mem_stat_t::atomic( int32 thread_id, la_t virtual_address, pa_t address ,$/;"	f	class:mem_stat_t
atomicMemoryWrite	memop.h	/^  bool atomicMemoryWrite( void ) {$/;"	f	class:store_inst_t
atomic_inst_t	memop.C	/^atomic_inst_t::atomic_inst_t( static_inst_t *s_inst, $/;"	f	class:atomic_inst_t
atomic_inst_t	memop.h	/^class atomic_inst_t : public store_inst_t, public load_interface_t {$/;"	c
attachMemTrace	pseq.C	/^void pseq_t::attachMemTrace( char *traceFilename )$/;"	f	class:pseq_t
attachMemTrace	system.C	/^void system_t::attachMemTrace( char *baseFilename, char *traceFilename )$/;"	f	class:system_t
attachTLBTrace	pseq.C	/^void pseq_t::attachTLBTrace( char *traceFileName )$/;"	f	class:pseq_t
attachTLBTrace	system.C	/^void system_t::attachTLBTrace( char *baseFilename, char *traceFilename )$/;"	f	class:system_t
attachTrace	pseq.C	/^void pseq_t::attachTrace( char *traceFileName, bool withImap )$/;"	f	class:pseq_t
attachTrace	system.C	/^void system_t::attachTrace( char *baseFilename, char *traceFilename )$/;"	f	class:system_t
avg_logging_length	diagnosis.h	/^		uint64 avg_logging_length;$/;"	m	class:multicore_diagnosis_t
bad_value	diagnosis.h	/^    ireg_t bad_value;$/;"	m	struct:__anon1
beginExecution	dynamic.C	/^dynamic_inst_t::beginExecution() { $/;"	f	class:dynamic_inst_t
bit	fault.h	/^		int bit ;		\/\/ Bit stuck at. Assuming big Endian format$/;"	m	class:Fault
block_bits	cache.h	/^  uint32 block_bits;$/;"	m	class:generic_cache_template
block_mask	cache.h	/^  uint32 block_mask;$/;"	m	class:generic_cache_template
block_size	cache.h	/^  uint32 block_size;$/;"	m	class:generic_cache_template
branch_predictor_type_menomic	pstate.C	/^const char *pstate_t::branch_predictor_type_menomic[BRANCHPRED_NUM_BRANCH_TYPES] = {$/;"	m	class:pstate_t	file:
branch_predictor_type_menomic	pstate.h	/^  static const char  *branch_predictor_type_menomic[BRANCHPRED_NUM_BRANCH_TYPES];$/;"	m	class:pstate_t
branch_type_menomic	pstate.C	/^const char *pstate_t::branch_type_menomic[BRANCH_NUM_BRANCH_TYPES] = {$/;"	m	class:pstate_t	file:
branch_type_menomic	pstate.h	/^  static const char  *branch_type_menomic[BRANCH_NUM_BRANCH_TYPES];$/;"	m	class:pstate_t
breakSimulation	system.C	/^void system_t::breakSimulation( void )$/;"	f	class:system_t
breakpoint_action	system.h	/^typedef struct breakpoint_action {$/;"	s
breakpoint_action_t	system.h	/^} breakpoint_action_t;$/;"	t	typeref:struct:breakpoint_action
breakpoint_memcpy	system.C	/^void system_t::breakpoint_memcpy( uint64 address, access_t access,$/;"	f	class:system_t
breakpoint_os_resume	system.C	/^void system_t::breakpoint_os_resume( uint64 address, access_t access,$/;"	f	class:system_t
breakpoint_print	system.C	/^void system_t::breakpoint_print( uint64 address, access_t access,$/;"	f	class:system_t
breakpoint_switch	system.C	/^void system_t::breakpoint_switch( uint64 address, access_t access, void *data )$/;"	f	class:system_t
breakpointf_t	system.h	/^typedef void (system_t::*breakpointf_t)( uint64, access_t, void * );$/;"	t
bucket_compare	histogram.C	/^static int bucket_compare( const void *el1, const void *el2 )$/;"	f	file:
buildFreelist	regmap.C	/^reg_map_t::buildFreelist( void ) const$/;"	f	class:reg_map_t
cache	cache.h	/^  BlockType *cache;$/;"	m	class:generic_cache_template
cache_line_stat_t	memstat.h	/^  cache_line_stat_t( la_t virtual_address ) {$/;"	f	class:cache_line_stat_t
cache_line_stat_t	memstat.h	/^class cache_line_stat_t {$/;"	c
cache_t	cache.C	/^cache_t::cache_t(const char *n, mshr_t *m, scheduler_t *eventQueue) {$/;"	f	class:cache_t
cache_t	cache.h	/^class cache_t {$/;"	c
canDoPtrArithmetic	dynamic.C	/^bool dynamic_inst_t::canDoPtrArithmetic() {$/;"	f	class:dynamic_inst_t
ccode	regfile.h	/^    unsigned char   ccode;$/;"	m	union:register_cc_u
cfg_list_t	flow.C	/^cfg_list_t::cfg_list_t()$/;"	f	class:cfg_list_t
cfg_list_t	flow.h	/^class cfg_list_t {$/;"	c
chain_increment	chain.h	/^  uint32 chain_increment( uint32 index ) {$/;"	f	class:chain_t
chain_inst_consumer	chain.C	/^void chain_t::chain_inst_consumer( pt_record_t *rec )$/;"	f	class:chain_t
chain_mem_consumer	chain.C	/^void chain_t::chain_mem_consumer( pt_record_t *rec )$/;"	f	class:chain_t
chain_t	chain.C	/^chain_t::chain_t( int id, uint32 window_size )$/;"	f	class:chain_t
chain_t	chain.h	/^class chain_t {$/;"	c
changed_dest	statici.h	/^  bool      changed_dest;$/;"	m	class:static_inst_t
check	arf.C	/^void      arf_cc_t::check( reg_id_t &rid, pstate_t *state,$/;"	f	class:arf_cc_t
check	arf.C	/^void      arf_container_t::check( reg_id_t &rid, pstate_t *state,$/;"	f	class:arf_container_t
check	arf.C	/^void      arf_int_t::check( reg_id_t &rid, pstate_t *state,$/;"	f	class:arf_int_t
check	arf.C	/^void     arf_int_global_t::check( reg_id_t &rid, pstate_t *state,$/;"	f	class:arf_int_global_t
check	arf.C	/^void    abstract_rf_t::check( reg_id_t &rid, pstate_t *state,$/;"	f	class:abstract_rf_t
check	arf.C	/^void    arf_control_t::check( reg_id_t &rid, pstate_t *state,$/;"	f	class:arf_control_t
check	arf.C	/^void    arf_double_t::check( reg_id_t &rid, pstate_t *state,$/;"	f	class:arf_double_t
check	arf.C	/^void    arf_single_t::check( reg_id_t &rid, pstate_t *state,$/;"	f	class:arf_single_t
check	arf.h	/^  void    check( reg_id_t &rid, pstate_t *state, check_result_t *result, bool init ) {}$/;"	f	class:arf_none_t
check	flatarf.C	/^void      flat_control_t::check( reg_id_t &rid, pstate_t *state,$/;"	f	class:flat_control_t
check	flatarf.C	/^void      flat_double_t::check( reg_id_t &rid, pstate_t *state,$/;"	f	class:flat_double_t
check	flatarf.C	/^void      flat_int_global_t::check( reg_id_t &rid, pstate_t *state,$/;"	f	class:flat_int_global_t
check	flatarf.C	/^void      flat_int_t::check( reg_id_t &rid, pstate_t *state,$/;"	f	class:flat_int_t
check	flatarf.C	/^void      flat_single_t::check( reg_id_t &rid, pstate_t *state,$/;"	f	class:flat_single_t
check	flatarf.C	/^void    flat_container_t::check( reg_id_t &rid, pstate_t *state, check_result_t *result )$/;"	f	class:flat_container_t
checkAddressAlignment	memop.C	/^void memory_inst_t::checkAddressAlignment( )$/;"	f	class:memory_inst_t
checkAllState	pseq.C	/^void pseq_t::checkAllState( check_result_t *result, mstate_t *mstate, bool init )$/;"	f	class:pseq_t
checkAndInjectTransientFault	pseq.C	/^void pseq_t::checkAndInjectTransientFault(dynamic_inst_t *d_inst, int dest_src)$/;"	f	class:pseq_t
checkBlackList	diagnosis.C	/^void diagnosis_t::checkBlackList(instruction_information_t&info)$/;"	f	class:diagnosis_t
checkChangedState	pseq.C	/^void pseq_t::checkChangedState( check_result_t *result, mstate_t *mstate,$/;"	f	class:pseq_t
checkCriticalState	pseq.C	/^void pseq_t::checkCriticalState( check_result_t *result, mstate_t *mstate, bool init )$/;"	f	class:pseq_t
checkDestReadiness	dynamic.C	/^void dynamic_inst_t::checkDestReadiness()$/;"	f	class:dynamic_inst_t
checkExitCond	diagnosis.C	/^bool diagnosis_t::checkExitCond()$/;"	f	class:diagnosis_t
checkRangeOverlap	diagnosis.C	/^bool diagnosis_t::checkRangeOverlap(reg_loc_t&reg_loc)$/;"	f	class:diagnosis_t
checkReadRegValue	dynamic.h	/^  virtual bool checkReadRegValue() { return true; }$/;"	f	class:dynamic_inst_t
checkReadRegValue	memop.C	/^bool atomic_inst_t::checkReadRegValue()$/;"	f	class:atomic_inst_t
checkRegReadiness	arf.C	/^void abstract_rf_t::checkRegReadiness(reg_id_t&rid)$/;"	f	class:abstract_rf_t
checkRegisterReady	pseq.C	/^pseq_t::checkRegisterReady()$/;"	f	class:pseq_t
checkSyncTarget	arf.C	/^bool abstract_rf_t::checkSyncTarget(reg_id_t &rid) {$/;"	f	class:abstract_rf_t
check_result_t	checkresult.h	/^  check_result_t( void ) {$/;"	f	class:check_result_t
check_result_t	checkresult.h	/^class check_result_t {$/;"	c
checked_core	diagnosis.h	/^		bool *checked_core;$/;"	m	class:multicore_diagnosis_t
checkpointState	pstate.C	/^void pstate_t::checkpointState( core_state_t *a_state )$/;"	f	class:pstate_t
checkpointState	pstate.C	/^void pstate_t::checkpointState( void )$/;"	f	class:pstate_t
checkpointStateAfterLogging	pstate.C	/^void pstate_t::checkpointStateAfterLogging()$/;"	f	class:pstate_t
checkpointTLB	pseq.C	/^void pseq_t::checkpointTLB()$/;"	f	class:pseq_t
checkpointTLBAfterLogging	pseq.C	/^void pseq_t::checkpointTLBAfterLogging()$/;"	f	class:pseq_t
cheetah_register_names	pseq.C	/^const char *cheetah_register_names[] = {$/;"	v
children	ddg.h	/^	ddg_node_list_t children ;$/;"	m	class:ddg_node_t
chkGetInt	regfile.h	/^        uint64 chkGetInt(uint16 reg_no) const {$/;"	f	class:physical_file_t
chkSetInt	regfile.h	/^	void  chkSetInt(uint16 reg_no, uint64 value) {$/;"	f	class:physical_file_t
clear	diagnosis.h	/^		void clear() { clearLLB(); }$/;"	f	class:llb_t
clearAddressNotFound	diagnosis.C	/^void multicore_diagnosis_t::clearAddressNotFound() {$/;"	f	class:multicore_diagnosis_t
clearAllFaults	arf.C	/^void abstract_rf_t::clearAllFaults( )$/;"	f	class:abstract_rf_t
clearAllFaults	arf.C	/^void arf_control_t::clearAllFaults()$/;"	f	class:arf_control_t
clearAllFaults	pseq.C	/^void pseq_t::clearAllFaults()$/;"	f	class:pseq_t
clearAllFaults	regfile.h	/^	void clearAllFaults() {$/;"	f	class:physical_file_t
clearAllFaults	regmap.h	/^  void clearAllFaults( ) {$/;"	f	class:reg_map_t
clearCompareLog	diagnosis.C	/^void multicore_diagnosis_t::clearCompareLog(int core_id)$/;"	f	class:multicore_diagnosis_t
clearCorrupted	dynamic.h	/^  void clearCorrupted() { corrupted=false;}$/;"	f	class:dynamic_inst_t
clearDictionary	diagnosis.C	/^void llb_t::clearDictionary()$/;"	f	class:llb_t
clearDoFaultInjection	pseq.h	/^  void clearDoFaultInjection()$/;"	f	class:pseq_t
clearException	pseq.C	/^pseq_t::clearException( void )$/;"	f	class:pseq_t
clearFault	arf.C	/^void abstract_rf_t::clearFault( reg_id_t &rid )$/;"	f	class:abstract_rf_t
clearFault	arf.C	/^void arf_double_t::clearFault( reg_id_t &rid )$/;"	f	class:arf_double_t
clearFault	arf.h	/^  inline void clearFault( reg_id_t &rid ) $/;"	f	class:arf_control_t
clearFault	dynamic.h	/^  void clearFault() { has_fault=false; }$/;"	f	class:dynamic_inst_t
clearFault	regfile.h	/^        void clearFault( uint16 reg_no ) {$/;"	f	class:physical_file_t
clearFault	regmap.h	/^  void clearFault( uint16 reg_no ) {$/;"	f	class:reg_map_t
clearFault	statici.h	/^  void clearFault() { has_fault = false ; }$/;"	f	class:static_inst_t
clearFirstTimeRollback	diagnosis.h	/^		void clearFirstTimeRollback() { first_time_rollback = false; }$/;"	f	class:multicore_diagnosis_t
clearFlatRegDeps	pseq.C	/^void pseq_t::clearFlatRegDeps( mstate_t &inorder, flow_inst_t *predecessor )$/;"	f	class:pseq_t
clearFuncTrap	pseq.h	/^  void clearFuncTrap()$/;"	f	class:pseq_t
clearLLB	diagnosis.C	/^void llb_t::clearLLB()$/;"	f	class:llb_t
clearLLB	system.C	/^void system_t::clearLLB(int core_id)$/;"	f	class:system_t
clearMemFault	memop.h	/^  void      clearMemFault() { has_mem_fault = false ; }$/;"	f	class:memory_inst_t
clearOSInstr	pseq.h	/^  void clearOSInstr()$/;"	f	class:pseq_t
clearPatched	arf.C	/^void abstract_rf_t::clearPatched( reg_id_t &rid )$/;"	f	class:abstract_rf_t
clearPatched	arf.C	/^void arf_control_t::clearPatched( reg_id_t &rid )$/;"	f	class:arf_control_t
clearPatched	arf.C	/^void arf_double_t::clearPatched( reg_id_t &rid )$/;"	f	class:arf_double_t
clearPatched	regfile.h	/^	void clearPatched( uint16 reg_no) {$/;"	f	class:physical_file_t
clearQueue	diagnosis.C	/^void llb_t::clearQueue()$/;"	f	class:llb_t
clearReadFault	arf.C	/^void abstract_rf_t::clearReadFault( reg_id_t &rid )$/;"	f	class:abstract_rf_t
clearReadFault	arf.C	/^void arf_double_t::clearReadFault( reg_id_t &rid )$/;"	f	class:arf_double_t
clearReadFault	regfile.h	/^	inline void clearReadFault( uint16 reg_no ) {$/;"	f	class:physical_file_t
clearReadFaults	dynamic.C	/^void dynamic_inst_t::clearReadFaults()$/;"	f	class:dynamic_inst_t
clearSquashingOnAddress	diagnosis.C	/^void multicore_diagnosis_t::clearSquashingOnAddress(int core_id)$/;"	f	class:multicore_diagnosis_t
clearUnchecked	pseq.C	/^void pseq_t::clearUnchecked()$/;"	f	class:pseq_t
client_start_num	system.h	/^  int client_start_num;$/;"	m	class:system_t
closeBranchTrace	pseq.C	/^void pseq_t::closeBranchTrace( void )$/;"	f	class:pseq_t
closeBranchTrace	system.C	/^void system_t::closeBranchTrace( void )$/;"	f	class:system_t
closeFaultLog	system.C	/^void system_t::closeFaultLog(void)$/;"	f	class:system_t
closeLogfiles	system.C	/^void system_t::closeLogfiles( void )$/;"	f	class:system_t
closeRegisterType	arf.C	/^void  arf_container_t::closeRegisterType( void )$/;"	f	class:arf_container_t
closeRegisterType	flatarf.C	/^void    flat_container_t::closeRegisterType( void )$/;"	f	class:flat_container_t
closeTrace	pseq.C	/^void pseq_t::closeTrace( void )$/;"	f	class:pseq_t
closeTrace	ptrace.C	/^void ptrace_t::closeTrace( void )$/;"	f	class:ptrace_t
closeTrace	system.C	/^void system_t::closeTrace( void )$/;"	f	class:system_t
collectCompareLog	diagnosis.C	/^void multicore_diagnosis_t::collectCompareLog(uint64 pc, int core_id)$/;"	f	class:multicore_diagnosis_t
collectCompareLog	diagnosis.C	/^void multicore_diagnosis_t::collectCompareLog(uint64 pc, uint64 address, uint64 value, int core_id)$/;"	f	class:multicore_diagnosis_t
collectCompareLog	diagnosis.C	/^void multicore_diagnosis_t::collectCompareLog(uint64 pc, uint64 target, int core_id)$/;"	f	class:multicore_diagnosis_t
collectCompareLog	diagnosis.C	/^void multicore_diagnosis_t::collectCompareLog(uint64 pc, uint64 value, int core_id, bool isNormal)$/;"	f	class:multicore_diagnosis_t
collectCompareLog	dynamic.C	/^void dynamic_inst_t::collectCompareLog()$/;"	f	class:dynamic_inst_t
collectCompareLog	memop.h	/^  void collectCompareLog() {}$/;"	f	class:load_inst_t
collectLLB	dynamic.h	/^  virtual bool collectLLB() { }$/;"	f	class:dynamic_inst_t
collectLLB	memop.C	/^bool atomic_inst_t::collectLLB()$/;"	f	class:atomic_inst_t
collectLLB	memop.C	/^bool load_inst_t::collectLLB()$/;"	f	class:load_inst_t
collectLoadSources	dynamic.h	/^  virtual void collectLoadSources() {}$/;"	f	class:dynamic_inst_t
collectLoadSources	memop.C	/^void load_inst_t::collectLoadSources()$/;"	f	class:load_inst_t
commandSetDispatch	system.C	/^set_error_t system_t::commandSetDispatch( attr_value_t *val )$/;"	f	class:system_t
commitObserver	pseq.C	/^void pseq_t::commitObserver( dynamic_inst_t *dinstr )$/;"	f	class:pseq_t
compareCompareLog	diagnosis.C	/^void multicore_diagnosis_t::compareCompareLog()$/;"	f	class:multicore_diagnosis_t
compareDestRegs	statici.h	/^  bool compareDestRegs(static_inst_t *A) {$/;"	f	class:static_inst_t
compareInstructions	diagnosis.C	/^bool diagnosis_t::compareInstructions(int cur_inst)$/;"	f	class:diagnosis_t
compareLastReplayCompareLog	diagnosis.C	/^void multicore_diagnosis_t::compareLastReplayCompareLog()$/;"	f	class:multicore_diagnosis_t
compareReplayCompareLog	diagnosis.C	/^void multicore_diagnosis_t::compareReplayCompareLog()$/;"	f	class:multicore_diagnosis_t
compareState	pseq.C	/^bool pseq_t::compareState(core_state_t *ps)$/;"	f	class:pseq_t
compareState	pstate.C	/^bool pstate_t::compareState( core_state_t * ps )$/;"	f	class:pstate_t
compareState	system.C	/^bool system_t::compareState(core_state_t *ps, int core_id)$/;"	f	class:system_t
compare_log	diagnosis.h	/^		vector<compare_log_element_t> *compare_log;$/;"	m	class:multicore_diagnosis_t
compare_log_element_t	diagnosis.h	/^} compare_log_element_t;$/;"	t	typeref:struct:__anon12
compare_log_last_replay	diagnosis.h	/^		vector<compare_log_element_t> compare_log_last_replay;$/;"	m	class:multicore_diagnosis_t
compare_log_logging	diagnosis.h	/^		vector<compare_log_element_t> *compare_log_logging;$/;"	m	class:multicore_diagnosis_t
complete	rubycache.C	/^void rubycache_t::complete( pa_t physical_address )$/;"	f	class:rubycache_t
completedRequest	pseq.C	/^void pseq_t::completedRequest( pa_t physicalAddr )$/;"	f	class:pseq_t
computeDiagnosisLatency	diagnosis.C	/^void multicore_diagnosis_t::computeDiagnosisLatency()$/;"	f	class:multicore_diagnosis_t
connectAmber	system.C	/^void system_t::connectAmber(void)$/;"	f	class:system_t
conservativeInvInpFile	pseq.h	/^  std::ifstream *aggressiveInvInpFile, *conservativeInvInpFile, *conservativeMulRangeInvInpFile;$/;"	m	class:pseq_t
conservativeInvMap	pseq.h	/^  InvMap aggressiveInvMap, conservativeInvMap;  $/;"	m	class:pseq_t
conservativeMulRangeInvInpFile	pseq.h	/^  std::ifstream *aggressiveInvInpFile, *conservativeInvInpFile, *conservativeMulRangeInvInpFile;$/;"	m	class:pseq_t
conservativeMulRangeInvMap	pseq.h	/^  MulRangeInvMap conservativeMulRangeInvMap; $/;"	m	class:pseq_t
consumeTrace	ptrace.C	/^bool ptrace_t::consumeTrace( void )$/;"	f	class:ptrace_t
contains	flow.C	/^bool cfg_list_t::contains( flow_inst_t *node )$/;"	f	class:cfg_list_t
contextSwitch	pseq.C	/^void pseq_t::contextSwitch( context_id_t new_context )$/;"	f	class:pseq_t
continueExecution	memop.C	/^load_inst_t::continueExecution() $/;"	f	class:load_inst_t
continueExecution	memop.C	/^store_inst_t::continueExecution(){$/;"	f	class:store_inst_t
continueSimulation	system.C	/^bool system_t::continueSimulation(uint64 instrCount)$/;"	f	class:system_t
controlRegSize	regbox.h	/^  static int16   controlRegSize( control_reg_t reg ) {$/;"	f	class:reg_box_t
control_inst_t	controlop.C	/^control_inst_t::control_inst_t( static_inst_t *s_inst, $/;"	f	class:control_inst_t
control_inst_t	controlop.h	/^class control_inst_t : public dynamic_inst_t {$/;"	c
control_reg_menomic	pstate.C	/^const char *pstate_t::control_reg_menomic[CONTROL_NUM_CONTROL_TYPES] = {$/;"	m	class:pstate_t	file:
control_reg_menomic	pstate.h	/^  static const char  *control_reg_menomic[CONTROL_NUM_CONTROL_TYPES];$/;"	m	class:pstate_t
copy	regbox.h	/^  inline void copy( reg_id_t &other, reg_box_t &rbox ) {$/;"	f	class:reg_id_t
copyBackCheckpoint	diagnosis.C	/^void multicore_diagnosis_t::copyBackCheckpoint()$/;"	f	class:multicore_diagnosis_t
copyDispatchRids	flatarf.C	/^void    flat_container_t::copyDispatchRids( reg_id_t &container_rid,$/;"	f	class:flat_container_t
copyLLB	diagnosis.C	/^void llb_t::copyLLB(llb_t *llb)$/;"	f	class:llb_t
copyProcessorState	pstate.C	/^void pstate_t::copyProcessorState( pstate_t *correct_state )$/;"	f	class:pstate_t
copyStoreValue	dynamic.h	/^  virtual void copyStoreValue() { }$/;"	f	class:dynamic_inst_t
copyStoreValue	memop.C	/^void atomic_inst_t::copyStoreValue()$/;"	f	class:atomic_inst_t
copyStoreValue	memop.C	/^void store_inst_t::copyStoreValue()$/;"	f	class:store_inst_t
core_state	diagnosis.h	/^		core_state_t *core_state;$/;"	m	class:multicore_diagnosis_t
core_state	diagnosis.h	/^typedef struct core_state {$/;"	s
core_state_main	diagnosis.h	/^		core_state_t *core_state_main;$/;"	m	class:multicore_diagnosis_t
core_state_previous	diagnosis.h	/^		core_state_t *core_state_previous;$/;"	m	class:multicore_diagnosis_t
core_state_t	diagnosis.h	/^} core_state_t;$/;"	t	typeref:struct:core_state
core_stopped_in_tmr	diagnosis.h	/^		bool *core_stopped_in_tmr;$/;"	m	class:multicore_diagnosis_t
correct_inst	statici.h	/^  unsigned int correct_inst;$/;"	m	class:static_inst_t
corrupted	dynamic.h	/^  bool corrupted ;$/;"	m	class:dynamic_inst_t
corrupted	regfile.h	/^		bool           *corrupted ;$/;"	m	class:physical_file_t
corrupting_store	memop.h	/^  bool corrupting_store;$/;"	m	class:store_inst_t
countInFlight	regmap.C	/^reg_map_t::countInFlight( uint16 logical_reg )$/;"	f	class:reg_map_t
countRegRemaining	regmap.C	/^reg_map_t::countRegRemaining(void)$/;"	f	class:reg_map_t
cpu_app	pseq.h	/^	int32 cpu_app;$/;"	m	class:pseq_t
cpu_os	pseq.h	/^	int32 cpu_os;$/;"	m	class:pseq_t
cpu_os_idle	pseq.h	/^	int32 cpu_os_idle;$/;"	m	class:pseq_t
crc_last_replay	diagnosis.h	/^		unsigned short crc_last_replay;$/;"	m	class:multicore_diagnosis_t
crc_last_replay_older	diagnosis.h	/^		unsigned short crc_last_replay_older;$/;"	m	class:multicore_diagnosis_t
crc_logging	diagnosis.h	/^		unsigned short *crc_logging;$/;"	m	class:multicore_diagnosis_t
crc_tmr	diagnosis.h	/^		unsigned short *crc_tmr;$/;"	m	class:multicore_diagnosis_t
crc_tmr_older	diagnosis.h	/^		unsigned short *crc_tmr_older;$/;"	m	class:multicore_diagnosis_t
crctable	crc16.C	/^static unsigned short crctable[256] = {$/;"	v	file:
crctable	crc16.C	/^static unsigned short crctable[256];$/;"	v	file:
createInstruction	pseq.C	/^dynamic_inst_t* pseq_t::createInstruction( static_inst_t *s_instr,$/;"	f	class:pseq_t
critical_check	checkresult.h	/^  bool critical_check;$/;"	m	class:check_result_t
critical_regs	checkresult.h	/^  reg_id_t            critical_regs[PSEQ_CRITICAL_REG_COUNT];$/;"	m	class:mstate_t
ctl_regs	diagnosis.h	/^  ireg_t   ctl_regs[MAX_CTL_REGS];$/;"	m	struct:core_state
ctxt_nucleus	pseq.h	/^    ctxt_nucleus, $/;"	e	enum:tlb_reg_t
ctxt_primary	pseq.h	/^    ctxt_primary, $/;"	e	enum:tlb_reg_t
ctxt_secondary	pseq.h	/^    ctxt_secondary, $/;"	e	enum:tlb_reg_t
cur_priv_mode	pseq.h	/^  bool     cur_priv_mode;$/;"	m	class:pseq_t
curr_chkpt	pstate.h	/^  int curr_chkpt ;$/;"	m	class:pstate_t
curr_trap_rate	pseq.h	/^  int      curr_trap_rate ;$/;"	m	class:pseq_t
current	pseq.h	/^	int32 current;$/;"	m	class:pseq_t
currentTMRCore	diagnosis.h	/^		int currentTMRCore() { return current_tmr_core; }$/;"	f	class:multicore_diagnosis_t
current_cycle_count	diagnosis.h	/^		int *current_cycle_count;$/;"	m	class:multicore_diagnosis_t
current_inst_count	diagnosis.h	/^		int *current_inst_count;$/;"	m	class:multicore_diagnosis_t
current_inst_num	pseq.h	/^	uint64 current_inst_num;$/;"	m	class:pseq_t
current_tmr_core	diagnosis.h	/^		int current_tmr_core;$/;"	m	class:multicore_diagnosis_t
cycle	ddg.h	/^	uint64 cycle ;$/;"	m	class:ddg_node_t
cycle	diagnosis.h	/^	tick_t cycle;$/;"	m	struct:__anon2
cycle	pseq.h	/^		tick_t cycle ;$/;"	m	struct:pseq_t::fault
cycle	scheduler.h	/^  tick_t   cycle;$/;"	m	class:event_t
data	pseq.h	/^    ireg_t data[MEMOP_MAX_SIZE];$/;"	m	struct:__anon24
data	pseq.h	/^    uint64 data;$/;"	m	struct:__anon21
dcu_ctrl	pseq.h	/^    dcu_ctrl, $/;"	e	enum:tlb_reg_t
ddg_a_stats	pseq.h	/^		ddg_a_stats() {$/;"	f	struct:pseq_t::ddg_a_stats
ddg_a_stats	pseq.h	/^		ddg_a_stats(uint64 f, uint64 s, uint64 l) {$/;"	f	struct:pseq_t::ddg_a_stats
ddg_a_stats	pseq.h	/^	struct ddg_a_stats {$/;"	s	class:pseq_t
ddg_a_stats_t	pseq.h	/^	typedef struct ddg_a_stats ddg_a_stats_t ;$/;"	t	class:pseq_t	typeref:struct:pseq_t::ddg_a_stats
ddg_last_producer	pseq.C	/^pseq_t::producer_t pseq_t::ddg_last_producer ;$/;"	m	class:pseq_t	file:
ddg_last_producer	pseq.h	/^	static producer_t ddg_last_producer ; \/\/ Separate as I am tracking DDG for entire exec$/;"	m	class:pseq_t
ddg_last_store	pseq.C	/^pseq_t::last_store_t pseq_t::ddg_last_store ;$/;"	m	class:pseq_t	file:
ddg_last_store	pseq.h	/^	static last_store_t ddg_last_store ;$/;"	m	class:pseq_t
ddg_node_list_t	ddg.h	/^typedef vector<ddg_node_t*> ddg_node_list_t ;$/;"	t
ddg_node_list_t	pseq.h	/^	typedef vector<ddg_node_t*> ddg_node_list_t ;$/;"	t	class:pseq_t
ddg_node_map	pseq.h	/^	ddg_node_map_t ddg_node_map ;$/;"	m	class:pseq_t
ddg_node_map_t	pseq.h	/^	typedef map<uint64, ddg_node_t*, uint64_cmp> ddg_node_map_t ;$/;"	t	class:pseq_t
ddg_node_t	ddg.C	/^ddg_node_t::ddg_node_t(uint64 s, uint64 c, uint64 p) {$/;"	f	class:ddg_node_t
ddg_node_t	ddg.h	/^class ddg_node_t {$/;"	c
ddg_root	pseq.h	/^	ddg_node_t *ddg_root ;$/;"	m	class:pseq_t
ddg_size	ddg.h	/^	uint64 ddg_size ;$/;"	m	class:ddg_node_t
ddg_stats_map	pseq.h	/^	ddg_stats_map_t ddg_stats_map ;$/;"	m	class:pseq_t
ddg_stats_map_t	pseq.h	/^	typedef map<uint64, ddg_a_stats_t*, uint64_cmp> ddg_stats_map_t ;$/;"	t	class:pseq_t
debugInputs	flow.C	/^void flow_inst_t::debugInputs( pstate_t *state )$/;"	f	class:flow_inst_t
decRefCnt	regfile.h	/^	inline void decRefCnt(uint16 reg_no) { $/;"	f	class:physical_file_t
decodeFails	statici.C	/^void static_inst_t::decodeFails( int line, uint32 inst )$/;"	f	class:static_inst_t
decodeInstruction	iwindow.C	/^dynamic_inst_t *iwindow_t::decodeInstruction( void )$/;"	f	class:iwindow_t
decodeInstruction	pseq.C	/^void pseq_t::decodeInstruction( void )$/;"	f	class:pseq_t
decodeInstructionInfo	statici.C	/^static_inst_t::decodeInstructionInfo( pa_t physical_address,$/;"	f	class:static_inst_t
decode_fail	statici.h	/^	bool      decode_fail ;$/;"	m	class:static_inst_t
decode_stat_t	decode.C	/^decode_stat_t::decode_stat_t()$/;"	f	class:decode_stat_t
decode_stat_t	decode.h	/^class decode_stat_t {$/;"	c
decoder_bin	diagnosis.h	/^	int *decoder_bin;$/;"	m	class:diagnosis_t
decrement	flatarf.C	/^static void decrement( flow_inst_t *f ) $/;"	f	file:
decrementRefCount	flow.h	/^  void      decrementRefCount( void ) {$/;"	f	class:flow_inst_t
decrementRefCount	statici.h	/^  void      decrementRefCount( void ) {$/;"	f	class:static_inst_t
decrementSequenceNumber	pseq.h	/^  void         decrementSequenceNumber( void ) {$/;"	f	class:pseq_t
del_mark	pseq.h	/^		int del_mark ;$/;"	m	struct:pseq_t::fault
delete_flow_inst	chain.C	/^void chain_t::delete_flow_inst( flow_inst_t *inst )$/;"	f	class:chain_t
deleted_faults	pseq.h	/^	deleted_faults_t deleted_faults ;$/;"	m	class:pseq_t
deleted_faults_t	pseq.h	/^	typedef set<uint64,uint64_cmp> deleted_faults_t ;$/;"	t	class:pseq_t
deleted_instructions	pseq.h	/^	deleted_instructions_t deleted_instructions ;$/;"	m	class:pseq_t
deleted_instructions_t	pseq.h	/^	typedef map<uint64, half_t, uint64_cmp> deleted_instructions_t ;$/;"	t	class:pseq_t
delink	mshr.h	/^  void delink(Type *t) {$/;"	f	class:replacement_manager_t
dependenceError	regfile.C	/^physical_file_t::dependenceError( uint16 reg_no ) const$/;"	f	class:physical_file_t
dereference	pstate.C	/^la_t pstate_t::dereference( la_t ptr, uint32 size )$/;"	f	class:pstate_t
dest	diagnosis.h	/^	func_reg_info_t dest[SI_MAX_DEST];$/;"	m	struct:__anon4
dest	diagnosis.h	/^	register_info_t dest[SI_MAX_DEST];$/;"	m	struct:__anon7
dest_regs	pseq.h	/^		reg_list_t dest_regs ;$/;"	m	struct:pseq_t::slice_inst
detectedSymp	system.C	/^void system_t::detectedSymp( void )$/;"	f	class:system_t
detected_again	pseq.h	/^  bool detected_again;$/;"	m	class:pseq_t
diag_result_t	diagnosis.h	/^} diag_result_t;$/;"	t	typeref:struct:__anon10
diagnosis_latency_cycles	diagnosis.h	/^		uint64 diagnosis_latency_cycles;$/;"	m	class:multicore_diagnosis_t
diagnosis_latency_instr	diagnosis.h	/^		int diagnosis_latency_instr;$/;"	m	class:multicore_diagnosis_t
diagnosis_started	diagnosis.h	/^		bool diagnosis_started;$/;"	m	class:multicore_diagnosis_t
diagnosis_t	diagnosis.C	/^diagnosis_t::diagnosis_t() $/;"	f	class:diagnosis_t
diagnosis_t	diagnosis.h	/^class diagnosis_t {$/;"	c
dictionary	diagnosis.h	/^	uint64 * dictionary;$/;"	m	class:llb_t
dictionaryElementAt	diagnosis.h	/^		uint64 dictionaryElementAt(int i) { return dictionary[i]; }$/;"	f	class:llb_t
dictionary_size	diagnosis.h	/^	int dictionary_size;$/;"	m	class:llb_t
disable	pstate.h	/^  void    disable( void ) {$/;"	f	class:pstate_t
disableInterrupts	pstate.C	/^void pstate_t::disableInterrupts(){$/;"	f	class:pstate_t
disableInterrupts	system.C	/^void system_t::disableInterrupts(int core_id)$/;"	f	class:system_t
dl1_mshr	pseq.h	/^  mshr_t      *dl1_mshr;$/;"	m	class:pseq_t
doInsert	lsq.C	/^void lsq_t::doInsert( memory_inst_t *memop ) {$/;"	f	class:lsq_t
do_not_advance	pseq.h	/^  bool do_not_advance;$/;"	m	class:pseq_t
do_not_sync	checkresult.h	/^  bool do_not_sync;$/;"	m	class:check_result_t
done_squash_trans	pseq.h	/^  bool done_squash_trans;$/;"	m	class:pseq_t
dont_continue	diagnosis.C	/^bool multicore_diagnosis_t::dont_continue(int core_id)$/;"	f	class:multicore_diagnosis_t
dont_continue_core	diagnosis.h	/^		int dont_continue_core;$/;"	m	class:multicore_diagnosis_t
dont_count	pseq.h	/^	bool dont_count;$/;"	m	class:pseq_t
dont_run_core	diagnosis.h	/^		int dont_run_core;$/;"	m	class:multicore_diagnosis_t
dont_run_core_id	diagnosis.h	/^		int dont_run_core_id() { return dont_run_core; }$/;"	f	class:multicore_diagnosis_t
doubleChange	inv-defs.h	/^    double doubleChange;    $/;"	m	union:Invariant::__anon15
doubleChange	inv-defs.h	/^    double doubleChange;    $/;"	m	union:MulRangeInvariant::__anon18
doubleMax	inv-defs.h	/^    double doubleMax;$/;"	m	union:Invariant::__anon14
doubleMax	inv-defs.h	/^    double doubleMax[MAX_NUM_RANGES];$/;"	m	union:MulRangeInvariant::__anon17
doubleMin	inv-defs.h	/^    double doubleMin;$/;"	m	union:Invariant::__anon13
doubleMin	inv-defs.h	/^    double doubleMin[MAX_NUM_RANGES];$/;"	m	union:MulRangeInvariant::__anon16
doubleValue	inv-defs.h	/^  double    doubleValue;$/;"	m	union:__anon19
drainBuffer	amber_api.h	/^	void (*drainBuffer)() ;$/;"	m	struct:mf_amber_api
dsfar	pseq.h	/^    dsfar,$/;"	e	enum:tlb_reg_t
dsfsr	pseq.h	/^    dsfsr, $/;"	e	enum:tlb_reg_t
dtag_access	pseq.h	/^    dtag_access, $/;"	e	enum:tlb_reg_t
dtag_access_ex	pseq.h	/^    dtag_access_ex, $/;"	e	enum:tlb_reg_t
dtag_target	pseq.h	/^    dtag_target, $/;"	e	enum:tlb_reg_t
dtlb_2w_daccess	pseq.h	/^    dtlb_2w_daccess,$/;"	e	enum:tlb_reg_t
dtlb_2w_tagread	pseq.h	/^    dtlb_2w_tagread, $/;"	e	enum:tlb_reg_t
dtlb_entry_t	dtlb.h	/^  dtlb_entry_t( la_t va, pa_t pa, context_id_t context, uint32 pagesize ) {$/;"	f	class:dtlb_entry_t
dtlb_entry_t	dtlb.h	/^class dtlb_entry_t {$/;"	c
dtlb_fa_daccess	pseq.h	/^    dtlb_fa_daccess, $/;"	e	enum:tlb_reg_t
dtlb_fa_tagread	pseq.h	/^    dtlb_fa_tagread, $/;"	e	enum:tlb_reg_t
dtlb_t	dtlb.C	/^dtlb_t::dtlb_t( uint32 dtlb_size, uint32 num_page_sizes, uint32 *page_sizes )$/;"	f	class:dtlb_t
dtlb_t	dtlb.h	/^class dtlb_t {$/;"	c
dtsb	pseq.h	/^    dtsb, $/;"	e	enum:tlb_reg_t
dtsb_nx	pseq.h	/^    dtsb_nx, $/;"	e	enum:tlb_reg_t
dtsb_px	pseq.h	/^    dtsb_px,$/;"	e	enum:tlb_reg_t
dtsb_sx	pseq.h	/^    dtsb_sx, dtsbp64k, dtsbp8k, dtsbpd, ec_control, isfsr,$/;"	e	enum:tlb_reg_t
dtsbp64k	pseq.h	/^    dtsb_sx, dtsbp64k, dtsbp8k, dtsbpd, ec_control, isfsr,$/;"	e	enum:tlb_reg_t
dtsbp8k	pseq.h	/^    dtsb_sx, dtsbp64k, dtsbp8k, dtsbpd, ec_control, isfsr,$/;"	e	enum:tlb_reg_t
dtsbpd	pseq.h	/^    dtsb_sx, dtsbp64k, dtsbp8k, dtsbpd, ec_control, isfsr,$/;"	e	enum:tlb_reg_t
dummy_default_mark	hfa.C	/^void dummy_default_mark(void *p)$/;"	f
dummy_directory	pseq.h	/^  vector<uint64> dummy_directory;$/;"	m	class:pseq_t
dynamic_inst_t	dynamic.C	/^dynamic_inst_t::dynamic_inst_t( static_inst_t *s_inst, $/;"	f	class:dynamic_inst_t
dynamic_inst_t	dynamic.h	/^class dynamic_inst_t : public waiter_t {$/;"	c
ec_control	pseq.h	/^    dtsb_sx, dtsbp64k, dtsbp8k, dtsbpd, ec_control, isfsr,$/;"	e	enum:tlb_reg_t
enable	pstate.h	/^  void    enable( void ) {$/;"	f	class:pstate_t
encounter_fatal_trap	diagnosis.h	/^	bool encounter_fatal_trap;$/;"	m	class:diagnosis_t
end	inv-defs.h	/^  uint64 end;$/;"	m	struct:SVAAddr
equals	regmap.C	/^reg_map_t::equals(reg_map_t *other) {$/;"	f	class:reg_map_t
event_t	scheduler.h	/^  event_t( void ) : wait_list_t() {$/;"	f	class:event_t
event_t	scheduler.h	/^class event_t : public wait_list_t {$/;"	c
exec_unit	diagnosis.h	/^    int32 exec_unit;$/;"	m	struct:__anon2
exec_unit	diagnosis.h	/^    int32 exec_unit;$/;"	m	struct:__anon5
exec_unit	dynamic.h	/^  int32 exec_unit ;$/;"	m	class:dynamic_inst_t
exec_unit	pseq.h	/^    int32 exec_unit;$/;"	m	struct:__anon23
exec_unit_id	diagnosis.h	/^    byte_t exec_unit_id;$/;"	m	struct:__anon2
exec_unit_id	diagnosis.h	/^    byte_t exec_unit_id;$/;"	m	struct:__anon5
exec_unit_id	pseq.h	/^    byte_t exec_unit_id;$/;"	m	struct:__anon23
exec_unit_num	dynamic.h	/^  byte_t exec_unit_num ; $/;"	m	class:dynamic_inst_t
execute	flow.h	/^  void           execute( void ) {$/;"	f	class:flow_inst_t
exitInterrupt	pseq.h	/^  void exitInterrupt() { in_interrupt = false ; interrupt_priv = -1 ; }$/;"	f	class:pseq_t
expected_diagnosis_latency_cycles	diagnosis.h	/^		uint64 expected_diagnosis_latency_cycles;$/;"	m	class:multicore_diagnosis_t
fSim	statici.C	/^faultSimulator fSim;$/;"	v
f_log	fault.h	/^		FILE *f_log ;	$/;"	m	class:Fault
fastforwardSimics	pseq.C	/^void pseq_t::fastforwardSimics( void )$/;"	f	class:pseq_t
fatalTrap	diagnosis.C	/^void diagnosis_t::fatalTrap()$/;"	f	class:diagnosis_t
fault	pseq.h	/^		fault(dynamic_inst_t *d, half_t r, half_t phys, int type) {$/;"	f	struct:pseq_t::fault
fault	pseq.h	/^	struct fault {$/;"	s	class:pseq_t
fault_cause_fatal	pseq.h	/^  bool fault_cause_fatal;$/;"	m	class:pseq_t
fault_cmp	pseq.h	/^	struct fault_cmp {$/;"	s	class:pseq_t
fault_id	pseq.h	/^		uint64 fault_id ;$/;"	m	struct:pseq_t::fault
fault_list	pseq.h	/^	fault_list_t fault_list ;$/;"	m	class:pseq_t
fault_list_t	pseq.h	/^	typedef map<uint64,fault_t*,uint64_cmp> fault_list_t ;$/;"	t	class:pseq_t
fault_set_t	pseq.h	/^	typedef set<fault_t*, fault_cmp> fault_set_t ;$/;"	t	class:pseq_t
fault_stat	pseq.h	/^  fault_stats *fault_stat;$/;"	m	class:pseq_t
fault_t	pseq.h	/^	typedef struct fault fault_t;$/;"	t	class:pseq_t	typeref:struct:pseq_t::fault
faulty_core_found	diagnosis.h	/^		bool faulty_core_found;$/;"	m	class:multicore_diagnosis_t
faulty_core_suspects	diagnosis.h	/^		int faulty_core_suspects;		\/\/current_core and (current_core+1)%numProcs are the suspects$/;"	m	class:multicore_diagnosis_t
faulty_loc_list	diagnosis.h	/^	vector<faulty_loc_t> faulty_loc_list;$/;"	m	class:diagnosis_t
faulty_loc_list2	diagnosis.h	/^	vector<faulty_loc_t> faulty_loc_list2;$/;"	m	class:diagnosis_t
faulty_loc_t	diagnosis.h	/^} faulty_loc_t;$/;"	t	typeref:struct:__anon8
faulty_store_addr_num	pseq.h	/^  uint64 faulty_store_addr_num; $/;"	m	class:pseq_t
faulty_store_value_num	pseq.h	/^  uint64 faulty_store_value_num;$/;"	m	class:pseq_t
fetchIncAgenCounter	pseq.h	/^  int fetchIncAgenCounter() { return agen_counter++; }$/;"	f	class:pseq_t
fetchIncFWayCounter	pseq.h	/^  int fetchIncFWayCounter() { return fway_counter++; }$/;"	f	class:pseq_t
fetchIncWayCounter	pseq.h	/^  int fetchIncWayCounter() { return way_counter++; }$/;"	f	class:pseq_t
fetchInstrSimple	pseq.C	/^void pseq_t::fetchInstrSimple( void )$/;"	f	class:pseq_t
fetchInstruction	pseq.C	/^void pseq_t::fetchInstruction( void )$/;"	f	class:pseq_t
fetch_id	diagnosis.h	/^    int fetch_id;$/;"	m	struct:__anon2
fetch_id	diagnosis.h	/^    int fetch_id;$/;"	m	struct:__anon5
fetch_id	pseq.h	/^    int fetch_id;$/;"	m	struct:__anon23
fetch_menomic	pseq.C	/^const char *pseq_t::fetch_menomic( pseq_fetch_status_t status )$/;"	f	class:pseq_t
finalizeControl	arf.C	/^void    abstract_rf_t::finalizeControl( reg_id_t &rid )$/;"	f	class:abstract_rf_t
finalizeControl	arf.C	/^void    arf_container_t::finalizeControl( reg_id_t &rid )$/;"	f	class:arf_container_t
finalizeControl	arf.C	/^void    arf_control_t::finalizeControl( reg_id_t &rid )$/;"	f	class:arf_control_t
finalizeControl	flatarf.C	/^void    flat_container_t::finalizeControl( reg_id_t &rid )$/;"	f	class:flat_container_t
finalizeControl	flatarf.C	/^void flat_control_t::finalizeControl( reg_id_t &rid )$/;"	f	class:flat_control_t
findDeadInstructions	pseq.C	/^bool pseq_t::findDeadInstructions(dynamic_inst_t *inst)$/;"	f	class:pseq_t
findDeadInstructions	pseq.C	/^bool pseq_t::findDeadInstructions(slice_inst_t *inst)$/;"	f	class:pseq_t
findFutureCulprit	diagnosis.C	/^bool diagnosis_t::findFutureCulprit(reg_loc_t&reg_loc) {$/;"	f	class:diagnosis_t
find_and_add_in_directory	pseq.C	/^void pseq_t::find_and_add_in_directory(uint64 * values, int size)$/;"	f	class:pseq_t
first_fatal_trap	pseq.h	/^  trap_info first_fatal_trap;$/;"	m	class:pseq_t
first_mis_cyc	diagnosis.h	/^	uint64 first_mis_cyc;$/;"	m	struct:__anon10
first_mis_ins	diagnosis.h	/^	uint64 first_mis_ins;$/;"	m	struct:__anon10
first_rat_err_on_read	arf.h	/^  bool first_rat_err_on_read;$/;"	m	class:abstract_rf_t
first_rat_err_on_read	dynamic.h	/^  bool first_rat_err_on_read;$/;"	m	class:dynamic_inst_t
first_time_rollback	diagnosis.h	/^		bool first_time_rollback;$/;"	m	class:multicore_diagnosis_t
flat_container_t	flatarf.h	/^  flat_container_t( \/*void*\/ fault_stats* fault_stat) :$/;"	f	class:flat_container_t
flat_container_t	flatarf.h	/^class flat_container_t : public flat_rf_t {$/;"	c
flat_control_t	flatarf.h	/^  flat_control_t( physical_file_t *rf, pstate_t *state, fault_stats* fault_stat ) :$/;"	f	class:flat_control_t
flat_control_t	flatarf.h	/^class flat_control_t : public flat_rf_t {$/;"	c
flat_double_t	flatarf.h	/^  flat_double_t( physical_file_t *rf, pstate_t *state,$/;"	f	class:flat_double_t
flat_double_t	flatarf.h	/^class flat_double_t : public flat_rf_t {$/;"	c
flat_int_global_t	flatarf.h	/^  flat_int_global_t( physical_file_t *rf, pstate_t *state, fault_stats *fault_stat ) :$/;"	f	class:flat_int_global_t
flat_int_global_t	flatarf.h	/^class flat_int_global_t : public flat_rf_t {$/;"	c
flat_int_t	flatarf.h	/^  flat_int_t( physical_file_t *rf, pstate_t *state, fault_stats* fault_stat ) :$/;"	f	class:flat_int_t
flat_int_t	flatarf.h	/^class flat_int_t : public flat_rf_t {$/;"	c
flat_rf_t	flatarf.h	/^  flat_rf_t( physical_file_t *rf, fault_stats* fault_stat ) :$/;"	f	class:flat_rf_t
flat_rf_t	flatarf.h	/^class flat_rf_t : public abstract_rf_t {$/;"	c
flat_single_t	flatarf.h	/^  flat_single_t( physical_file_t *rf, pstate_t *state, fault_stats* fault_stat ) :$/;"	f	class:flat_single_t
flat_single_t	flatarf.h	/^class flat_single_t : public flat_rf_t {$/;"	c
float_32	regfile.h	/^    float    float_32;$/;"	m	union:my_register_u
float_64	regfile.h	/^    double   float_64;$/;"	m	union:my_register_u
flow_event_t	flow.h	/^typedef uint16 flow_event_t;$/;"	t
flow_inst_t	flow.C	/^flow_inst_t::flow_inst_t( static_inst_t *s, $/;"	f	class:flow_inst_t
flow_inst_t	flow.h	/^class flow_inst_t {$/;"	c
fp_regs	diagnosis.h	/^  freg_t   fp_regs[MAX_FLOAT_REGS];$/;"	m	struct:core_state
free	simdist12.C	220;"	d	file:
freeCompareLog	diagnosis.C	/^void multicore_diagnosis_t::freeCompareLog(int core_id)$/;"	f	class:multicore_diagnosis_t
freeFuncInstBuffer	diagnosis.C	/^void multicore_diagnosis_t::freeFuncInstBuffer(int core_id)$/;"	f	class:multicore_diagnosis_t
freeRegister	arf.C	/^bool    abstract_rf_t::freeRegister( reg_id_t &rid )$/;"	f	class:abstract_rf_t
freeRegister	arf.C	/^bool    arf_container_t::freeRegister( reg_id_t &rid )$/;"	f	class:arf_container_t
freeRegister	arf.C	/^bool    arf_control_t::freeRegister( reg_id_t &rid )$/;"	f	class:arf_control_t
freeRegister	arf.C	/^bool    arf_double_t::freeRegister( reg_id_t &rid )$/;"	f	class:arf_double_t
freeRegister	arf.h	/^  bool    freeRegister( reg_id_t &rid ) { return (true); }$/;"	f	class:arf_none_t
freeRegister	flatarf.C	/^bool    flat_rf_t::freeRegister( reg_id_t &rid ) {$/;"	f	class:flat_rf_t
free_list_t	wait.h	/^  free_list_t() : wait_list_t() { }$/;"	f	class:free_list_t
free_list_t	wait.h	/^  free_list_t(waiter_t *n) : wait_list_t() { $/;"	f	class:free_list_t
free_list_t	wait.h	/^class free_list_t : public wait_list_t {$/;"	c
freq	diagnosis.h	/^	uint freq;$/;"	m	struct:__anon10
frequent_index	diagnosis.h	/^	int frequent_index;$/;"	m	struct:llb_queue_entry
front	diagnosis.h	/^	int front;$/;"	m	class:llb_t
fu_type_menomic	pstate.C	/^const char *pstate_t::fu_type_menomic( fu_type_t fu_type ) {$/;"	f	class:pstate_t
fullSquash	pseq.C	/^pseq_t::fullSquash( enum i_opcode offender )$/;"	f	class:pseq_t
func_inst_buffer	diagnosis.h	/^		func_inst_buffer_t* func_inst_buffer;$/;"	m	class:multicore_diagnosis_t
func_inst_buffer	pseq.h	/^  func_inst_buffer_t func_inst_buffer;$/;"	m	class:pseq_t
func_inst_buffer_element_t	diagnosis.h	/^typedef struct func_inst_info func_inst_buffer_element_t;$/;"	t	typeref:struct:func_inst_info
func_inst_buffer_t	diagnosis.h	/^typedef vector <struct func_inst_info> func_inst_buffer_t;$/;"	t
func_inst_info	diagnosis.h	/^struct func_inst_info {$/;"	s
func_inst_info_t	diagnosis.h	/^} func_inst_info_t;$/;"	t	typeref:struct:__anon4
func_reg_info_t	diagnosis.h	/^} func_reg_info_t;$/;"	t	typeref:struct:__anon3
functionalOp	decode.h	/^  void    functionalOp( enum i_opcode op ) {$/;"	f	class:decode_stat_t
fway_counter	pseq.h	/^  int      fway_counter;$/;"	m	class:pseq_t
fwrite	simdist12.C	139;"	d	file:
g_exceptionString	simdist12.C	/^static char *g_exceptionString = NULL;$/;"	v	file:
g_generalException	simdist12.C	/^static int   g_generalException = 0;$/;"	v	file:
g_initvar_obj	hfa.C	/^static initvar_t *g_initvar_obj = NULL;$/;"	v	file:
generateIndex	lsq.h	/^  uint32      generateIndex(my_addr_t addr) const { $/;"	f	class:lsq_t
generic_cache_block_t	cache.h	/^class generic_cache_block_t {$/;"	c
generic_cache_template	cache.C	/^generic_cache_template<BlockType>::generic_cache_template(const char *n, mshr_t *m,$/;"	f	class:generic_cache_template
generic_cache_template	cache.h	/^class generic_cache_template : public cache_t {$/;"	c
getAGU	dynamic.h	/^  int getAGU() {return m_agen_id; }$/;"	f	class:dynamic_inst_t
getARF	regbox.h	/^  inline abstract_rf_t *getARF( rid_type_t reg_type ) {$/;"	f	class:reg_box_t
getARF	regbox.h	/^  inline abstract_rf_t *getARF( void ) {$/;"	f	class:reg_id_t
getARFType	arf.h	/^  int  getARFType() { return arf_type; };$/;"	f	class:abstract_rf_t
getASI	memop.h	/^  uint16       getASI( void ) {$/;"	f	class:memory_inst_t
getASIinterface	pseq.h	/^  mmu_interface_t *getASIinterface( void ) {$/;"	f	class:pseq_t
getAccessSigned	statici.h	/^  bool      getAccessSigned() const {$/;"	f	class:static_inst_t
getAccessSize	dynamic.h	/^  virtual byte_t getAccessSize() const { return 0;}$/;"	f	class:dynamic_inst_t
getAccessSize	flow.h	/^  byte_t      getAccessSize() const {$/;"	f	class:flow_inst_t
getAccessSize	memop.h	/^  byte_t    getAccessSize() const {$/;"	f	class:memory_inst_t
getAccessSize	statici.h	/^  byte_t    getAccessSize() const { return (m_access_size & REG_MEMSIZE); }$/;"	f	class:static_inst_t
getActivateFault	dynamic.h	/^  bool getActivateFault() { return activate_fault ;}$/;"	f	class:dynamic_inst_t
getActualTarget	controlop.h	/^  abstract_pc_t    *getActualTarget( void ) {$/;"	f	class:control_inst_t
getActualTarget	flow.h	/^  abstract_pc_t *getActualTarget( void ) {$/;"	f	class:flow_inst_t
getAddress	memop.h	/^  my_addr_t   getAddress( void ) const { return m_address; }$/;"	f	class:memory_inst_t
getAddress	rubycache.h	/^  pa_t getAddress( void ) {$/;"	f	class:ruby_request_t
getAdvanceSimicsException	pstate.C	/^bool pstate_t::getAdvanceSimicsException()$/;"	f	class:pstate_t
getAnnul	statici.h	/^  bool                getAnnul( void ) const {$/;"	f	class:static_inst_t
getArchBPS	pseq.h	/^  predictor_state_t *getArchBPS( void ) {$/;"	f	class:pseq_t
getArchCycle	pseq.h	/^  uint64 getArchCycle()$/;"	f	class:pseq_t
getArchMismatch	pseq.h	/^  bool getArchMismatch(void) {$/;"	f	class:pseq_t
getArchMismatch	system.C	/^bool system_t::getArchMismatch(int core_id)$/;"	f	class:system_t
getAssertFail	statici.h	/^  bool getAssertFail() { return assert_fail; }$/;"	f	class:static_inst_t
getBadValue	diagnosis.h	/^	ireg_t getBadValue(reg_loc_t&reg_loc) {$/;"	f	class:diagnosis_t
getBlockAddress	cache.h	/^  inline pa_t   getBlockAddress(BlockType &cb) { return (cb.address_state & ~0x7); }$/;"	f	class:generic_cache_template
getBlockSize	cache.h	/^  \/*inline*\/ uint32 getBlockSize() { return block_size; };$/;"	f	class:generic_cache_template
getBlockSize	rubycache.h	/^  uint32 getBlockSize( void ) { return m_block_size; };$/;"	f	class:rubycache_t
getBranchType	statici.h	/^  branch_type_t       getBranchType( void ) const {$/;"	f	class:static_inst_t
getCCShift	statici.h	/^  byte_t    getCCShift(void) { return (m_ccshift); };$/;"	f	class:static_inst_t
getChangedDest	statici.h	/^  bool getChangedDest() { return changed_dest; }$/;"	f	class:static_inst_t
getCheckpointReg	pseq.C	/^ireg_t pseq_t::getCheckpointReg(reg_id_t&rid)$/;"	f	class:pseq_t
getChkptInterval	pseq.C	/^int pseq_t::getChkptInterval()$/;"	f	class:pseq_t
getChkptInterval	pstate.h	/^  int getChkptInterval() { return m_chkpt_interval ; }$/;"	f	class:pstate_t
getChkptPC	pstate.h	/^  long long int getChkptPC() { return m_state[curr_chkpt].ctl_regs[SIMICS_get_register_number(m_cpu,"pc")] ; }$/;"	f	class:pstate_t
getClock	pseq.h	/^  uint64 getClock()$/;"	f	class:pseq_t
getContext	pstate.C	/^int pstate_t::getContext( void )$/;"	f	class:pstate_t
getControl	pstate.h	/^  ireg_t  getControl( unsigned int reg ) {$/;"	f	class:pstate_t
getControlARF	pseq.h	/^  arf_control_t* getControlARF() { return m_control_arf; }$/;"	f	class:pseq_t
getControlFault	dynamic.h	/^  bool getControlFault() { return m_control_fault ; }$/;"	f	class:dynamic_inst_t
getControlMap	pstate.h	/^  int32* getControlMap() {return m_control_map; }$/;"	f	class:pstate_t
getCount	pipepool.h	/^  uint32         getCount( void ) {$/;"	f	class:pipepool_t
getCurrChkptNum	pseq.C	/^int pseq_t::getCurrChkptNum() {$/;"	f	class:pseq_t
getCurrChkptNum	pstate.h	/^  int getCurrChkptNum() { return curr_chkpt ; }$/;"	f	class:pstate_t
getCurrentInstNum	diagnosis.h	/^		uint64 getCurrentInstNum(int core_id) { return current_inst_count[core_id]; }$/;"	f	class:multicore_diagnosis_t
getCurrentThread	pseq.C	/^la_t  pseq_t::getCurrentThread( void )$/;"	f	class:pseq_t
getCycle	scheduler.h	/^  tick_t getCycle( void ) {$/;"	f	class:scheduler_t
getDDGSize	ddg.C	/^uint64 ddg_node_t::getDDGSize()$/;"	f	class:ddg_node_t
getDDGSize	ddg.C	/^uint64 ddg_node_t::getDDGSize(inst_set_t &already_seen)$/;"	f	class:ddg_node_t
getData	flow.h	/^  ireg_t     *getData( void ) {$/;"	f	class:flow_inst_t
getData	memop.h	/^  ireg_t     *getData( void ) {$/;"	f	class:memory_inst_t
getDataCache	pseq.h	/^  cache_t *getDataCache( void ) {$/;"	f	class:pseq_t
getDecodeFail	statici.h	/^	bool                getDecodeFail( void ) const {$/;"	f	class:static_inst_t
getDecodeMap	arf.h	/^  reg_map_t           *getDecodeMap( void ) {$/;"	f	class:abstract_rf_t
getDecodeRF	arf.h	/^  physical_file_t *getDecodeRF( void ) {$/;"	f	class:arf_control_t
getDepend	memop.h	/^  store_inst_t *getDepend( void ) const { return m_depend; }$/;"	f	class:atomic_inst_t
getDepend	memop.h	/^  store_inst_t *getDepend( void ) const { return m_depend; }$/;"	f	class:load_inst_t
getDependence	arf.C	/^flow_inst_t *abstract_rf_t::getDependence( reg_id_t &rid )$/;"	f	class:abstract_rf_t
getDependence	flatarf.C	/^flow_inst_t *flat_container_t::getDependence( reg_id_t &rid )$/;"	f	class:flat_container_t
getDependence	flatarf.C	/^flow_inst_t *flat_double_t::getDependence( reg_id_t &rid )$/;"	f	class:flat_double_t
getDependence	flatarf.C	/^flow_inst_t *flat_rf_t::getDependence( reg_id_t &rid )$/;"	f	class:flat_rf_t
getDestNum	dynamic.C	/^int dynamic_inst_t::getDestNum(int arch_reg_no)$/;"	f	class:dynamic_inst_t
getDestReg	dynamic.h	/^  reg_id_t &getDestReg( int destnum ) {$/;"	f	class:dynamic_inst_t
getDestReg	flow.h	/^  reg_id_t      &getDestReg( int destnum ) {$/;"	f	class:flow_inst_t
getDestReg	statici.h	/^  reg_id_t &getDestReg( int destnum ) {$/;"	f	class:static_inst_t
getDictionarySize	diagnosis.h	/^		int getDictionarySize() { return dictionary_size;}$/;"	f	class:llb_t
getDirectBP	pseq.h	/^  direct_predictor_t  *getDirectBP( void ) {$/;"	f	class:pseq_t
getDoFaultInjection	pseq.h	/^  bool getDoFaultInjection()$/;"	f	class:pseq_t
getDouble	pstate.h	/^  freg_t  getDouble( unsigned int reg ) {$/;"	f	class:pstate_t
getElement	pipestate.h	/^  waiter_t     *getElement( void ) { return m_element; }$/;"	f	class:pipestate_t
getEvent	dynamic.h	/^  bool   getEvent( inst_event_t e) { return ( (m_events & e) != 0 ); }$/;"	f	class:dynamic_inst_t
getEvent	flow.h	/^  bool   getEvent( flow_event_t e) { return ( (m_events & e) != 0 ); }$/;"	f	class:flow_inst_t
getEventQueue	cache.h	/^  scheduler_t *getEventQueue( void ) { return m_eventQueue; }$/;"	f	class:cache_t
getEventTime	dynamic.h	/^  uint16 getEventTime( inst_time_t t ) {$/;"	f	class:dynamic_inst_t
getExecUnit	dynamic.h	/^  int32 getExecUnit() 		            { return exec_unit ; }$/;"	f	class:dynamic_inst_t
getExecUnitNum	dynamic.h	/^  byte_t getExecUnitNum()               { return exec_unit_num ; }$/;"	f	class:dynamic_inst_t
getExitCode	statici.h	/^  int  getExitCode() { return m_exit_code; }$/;"	f	class:static_inst_t
getFP	pseq.h	/^  int getFP(int i, int j) {return FP_util[i-4][j]; }$/;"	f	class:pseq_t
getFP	system.C	/^int system_t::getFP(int i, int j)$/;"	f	class:system_t
getFault	arf.C	/^bool abstract_rf_t::getFault( reg_id_t &rid )$/;"	f	class:abstract_rf_t
getFault	arf.C	/^bool arf_control_t::getFault( reg_id_t &rid )$/;"	f	class:arf_control_t
getFault	arf.C	/^bool arf_double_t::getFault( reg_id_t &rid )$/;"	f	class:arf_double_t
getFault	dynamic.h	/^  bool getFault() { return has_fault ; }$/;"	f	class:dynamic_inst_t
getFault	regfile.h	/^	bool getFault( uint16 reg_no ) {$/;"	f	class:physical_file_t
getFault	regmap.h	/^  bool getFault( uint16 reg_no ) {$/;"	f	class:reg_map_t
getFault	statici.h	/^  bool getFault() { return has_fault ; }$/;"	f	class:static_inst_t
getFaultBit	pseq.h	/^  int getFaultBit()$/;"	f	class:pseq_t
getFaultId	pseq.h	/^		uint64 getFaultId() { return fault_id; }$/;"	f	struct:pseq_t::fault
getFaultSrcDst	pseq.h	/^  int getFaultSrcDst()$/;"	f	class:pseq_t
getFaultStat	arf.h	/^  fault_stats* getFaultStat() { return m_fs; }$/;"	f	class:abstract_rf_t
getFaultStat	dynamic.h	/^  fault_stats* getFaultStat() { return m_fs; }$/;"	f	class:dynamic_inst_t
getFaultStat	regfile.h	/^	fault_stats* getFaultStat() { return m_fs; }$/;"	f	class:physical_file_t
getFaultStuckat	pseq.h	/^  int getFaultStuckat()$/;"	f	class:pseq_t
getFaultType	pseq.h	/^  int getFaultType()$/;"	f	class:pseq_t
getFaultyBit	fault.h	/^		int getFaultyBit() { return bit ; }$/;"	f	class:Fault
getFaultyList	diagnosis.h	/^	vector<faulty_loc_t> &getFaultyList() {return faulty_loc_list;}$/;"	f	class:diagnosis_t
getFaultyReg	pseq.h	/^  int getFaultyReg()$/;"	f	class:pseq_t
getFaultyStaticInst	decodefault.h	/^		static_inst_t *getFaultyStaticInst() { return s_inst ; }$/;"	f	class:DecodeFault
getFetchId	statici.h	/^  int getFetchId() {return m_fetch_id;}$/;"	f	class:static_inst_t
getFetchTime	dynamic.h	/^  uint64 getFetchTime( void ) {$/;"	f	class:dynamic_inst_t
getFirstErr	arf.h	/^  bool getFirstErr() {return first_rat_err_on_read; }$/;"	f	class:abstract_rf_t
getFlag	ptrace.h	/^  bool      getFlag( const pt_memory_flags_t flag ) const { $/;"	f	class:pt_memory_t
getFlag	statici.h	/^  bool      getFlag( const byte_t flag ) const { $/;"	f	class:static_inst_t
getFlags	statici.h	/^  byte_t getFlags() const {return m_flags;}$/;"	f	class:static_inst_t
getFlatRegister	regbox.C	/^half_t  reg_id_t::getFlatRegister( void )$/;"	f	class:reg_id_t
getFloat	regfile.h	/^        float32 getFloat(uint16 reg_no) const {$/;"	f	class:physical_file_t
getFrequentIndex	diagnosis.C	/^int llb_t::getFrequentIndex(uint32 value)$/;"	f	class:llb_t
getFrequentValue	diagnosis.C	/^int llb_t::getFrequentValue(int freq_index)$/;"	f	class:llb_t
getFront	diagnosis.h	/^		int getFront() {$/;"	f	class:llb_t
getFuType	statici.h	/^  fu_type_t getFuType() const { return (fu_type_t) (m_futype); }$/;"	f	class:static_inst_t
getFuncLog	system.C	/^func_inst_buffer_t& system_t::getFuncLog(int core_id) $/;"	f	class:system_t
getGlobalCycle	system.C	/^tick_t system_t::getGlobalCycle( void )$/;"	f	class:system_t
getGlobalSet	pstate.h	/^  static uint16      getGlobalSet( ireg_t reg_pstate ) {$/;"	f	class:pstate_t
getGoodValue	diagnosis.h	/^	ireg_t getGoodValue(reg_loc_t&reg_loc) {$/;"	f	class:diagnosis_t
getID	flow.h	/^  uint64  getID( void ) { return m_sequence_id; }$/;"	f	class:flow_inst_t
getID	pseq.h	/^  int32          getID( void ) {$/;"	f	class:pseq_t
getIdealBox	pseq.h	/^  reg_box_t &getIdealBox( void ) {$/;"	f	class:pseq_t
getImmediate	statici.h	/^  ireg_t    getImmediate() const { return m_imm; }$/;"	f	class:static_inst_t
getIndirectBP	pseq.h	/^  cascaded_indirect_t *getIndirectBP( void ) {$/;"	f	class:pseq_t
getInfLoopCycle	pseq.h	/^  uint64 getInfLoopCycle()$/;"	f	class:pseq_t
getInjectFault	memop.h	/^  bool      getInjectFault() { return should_inject_fault; }$/;"	f	class:memory_inst_t
getInsertIndex	iwindow.C	/^uint32 iwindow_t::getInsertIndex( void )$/;"	f	class:iwindow_t
getInst	statici.h	/^  unsigned int        getInst( void ) const {$/;"	f	class:static_inst_t
getInstr	pseq.C	/^bool pseq_t::getInstr( la_t cur_pc, $/;"	f	class:pseq_t
getInstr	pseq.C	/^bool pseq_t::getInstr( la_t cur_pc, int32 traplevel, int32 pstate,$/;"	f	class:pseq_t
getInstrInfo	diagnosis.h	/^	instruction_information_t& getInstrInfo(reg_loc_t&reg_loc) {$/;"	f	class:diagnosis_t
getInstruction	ipage.C	/^static_inst_t *ipage_t::getInstruction( pa_t address )$/;"	f	class:ipage_t
getInstructionCache	pseq.h	/^  cache_t *getInstructionCache( void ) {$/;"	f	class:pseq_t
getInstructionCount	mf_api.h	/^  integer_t (*getInstructionCount)( int cpuNumber );$/;"	m	struct:mf_opal_api
getInt	regfile.h	/^        uint64 getInt(uint16 reg_no) const {$/;"	f	class:physical_file_t
getIntGlobal	pstate.h	/^  ireg_t  getIntGlobal( unsigned int reg, int global_set ) {$/;"	f	class:pstate_t
getIntWp	pstate.h	/^  ireg_t  getIntWp( unsigned int reg, int cwp ) {$/;"	f	class:pstate_t
getInterruptPriv	pseq.h	/^  int getInterruptPriv() { return interrupt_priv ; } $/;"	f	class:pseq_t
getIwindow	pseq.h	/^  iwindow_t   *getIwindow( void ) {$/;"	f	class:pseq_t
getLLB	pseq.h	/^  llb_t* getLLB() { return llb; }$/;"	f	class:pseq_t
getLLB	system.C	/^llb_t*  system_t::getLLB(int core_id) $/;"	f	class:system_t
getLLBQueueSize	diagnosis.h	/^		int getLLBQueueSize() { return llb_queue_size;}$/;"	f	class:llb_t
getLLFail	statici.h	/^  bool getLLFail() { return ll_decode_fail ; }$/;"	f	class:static_inst_t
getLSQ	pseq.h	/^  lsq_t       *getLSQ( void ) {$/;"	f	class:pseq_t
getLast	diagnosis.h	/^		int getLast() {return last;}$/;"	f	class:llb_t
getLastDecoded	iwindow.C	/^uint32  iwindow_t::getLastDecoded( void )$/;"	f	class:iwindow_t
getLastFetched	iwindow.C	/^uint32  iwindow_t::getLastFetched( void )$/;"	f	class:iwindow_t
getLastReadInst	ddg.C	/^uint64 ddg_node_t::getLastReadInst()$/;"	f	class:ddg_node_t
getLastRetired	iwindow.C	/^uint32  iwindow_t::getLastRetired( void )$/;"	f	class:iwindow_t
getLastScheduled	iwindow.C	/^uint32  iwindow_t::getLastScheduled( void )$/;"	f	class:iwindow_t
getLastWriter	flatarf.h	/^  flow_inst_t **getLastWriter( void ) {$/;"	f	class:flat_single_t
getLine	memstat.C	/^cache_line_stat_t *mem_stat_t::getLine( pa_t address, la_t virtual_address )$/;"	f	class:mem_stat_t
getLineAddress	memop.h	/^  my_addr_t getLineAddress(void) {$/;"	f	class:memory_inst_t
getLocalCycle	pseq.h	/^  tick_t       getLocalCycle( void ) {$/;"	f	class:pseq_t
getLocalCycle	system.C	/^uint64 system_t::getLocalCycle(int core_id)$/;"	f	class:system_t
getLog	diagnosis.C	/^void multicore_diagnosis_t::getLog(int from, int to)$/;"	f	class:multicore_diagnosis_t
getLogical	arf.C	/^half_t    arf_cc_t::getLogical( reg_id_t &rid )$/;"	f	class:arf_cc_t
getLogical	arf.C	/^half_t    arf_container_t::getLogical( reg_id_t &rid )$/;"	f	class:arf_container_t
getLogical	arf.C	/^half_t    arf_control_t::getLogical( reg_id_t &rid )$/;"	f	class:arf_control_t
getLogical	arf.C	/^half_t    arf_double_t::getLogical( reg_id_t &rid )$/;"	f	class:arf_double_t
getLogical	arf.C	/^half_t    arf_int_t::getLogical( reg_id_t &rid )$/;"	f	class:arf_int_t
getLogical	arf.C	/^half_t    arf_single_t::getLogical( reg_id_t &rid )$/;"	f	class:arf_single_t
getLogical	arf.C	/^half_t   arf_int_global_t::getLogical( reg_id_t &rid )$/;"	f	class:arf_int_global_t
getLogical	arf.C	/^half_t  abstract_rf_t::getLogical( reg_id_t &rid )$/;"	f	class:abstract_rf_t
getLogical	arf.h	/^  half_t  getLogical( reg_id_t &rid ) { return (0); }$/;"	f	class:arf_none_t
getLogical	diagnosis.h	/^	half_t getLogical(reg_loc_t&reg_loc) {$/;"	f	class:diagnosis_t
getLogical	flatarf.C	/^half_t    flat_control_t::getLogical( reg_id_t &rid )$/;"	f	class:flat_control_t
getLogical	flatarf.C	/^half_t    flat_double_t::getLogical( reg_id_t &rid )$/;"	f	class:flat_double_t
getLogical	flatarf.C	/^half_t    flat_int_global_t::getLogical( reg_id_t &rid )$/;"	f	class:flat_int_global_t
getLogical	flatarf.C	/^half_t    flat_int_t::getLogical( reg_id_t &rid )$/;"	f	class:flat_int_t
getLogical	flatarf.C	/^half_t    flat_single_t::getLogical( reg_id_t &rid )$/;"	f	class:flat_single_t
getLogical	flatarf.C	/^half_t  flat_container_t::getLogical( reg_id_t &rid ) {$/;"	f	class:flat_container_t
getMMUName	pstate.C	/^void pstate_t::getMMUName( int id, char *mmuname, int len )$/;"	f	class:pstate_t
getMMUObjects	diagnosis.C	/^void multicore_diagnosis_t::getMMUObjects()$/;"	f	class:multicore_diagnosis_t
getMSHR	cache.h	/^  mshr_t      *getMSHR( void ) { return mshr; }$/;"	f	class:cache_t
getMSHR	pseq.h	/^  mshr_t      *getMSHR( void ) {$/;"	f	class:pseq_t
getMapping	regmap.h	/^  inline uint16 getMapping(uint16 logical_reg) const$/;"	f	class:reg_map_t
getMaskedData	memop.h	/^  ireg_t	getMaskedData(ireg_t *A) {$/;"	f	class:memory_inst_t
getMemDepth	flow.h	/^  int32     getMemDepth( void ) {$/;"	f	class:flow_inst_t
getMemFault	memop.h	/^  bool      getMemFault() { return has_mem_fault ; }$/;"	f	class:memory_inst_t
getMemoryWaiter	ptrace.C	/^pt_memory_waiter_t *ptrace_t::getMemoryWaiter( void )$/;"	f	class:ptrace_t
getMemtrace	pseq.h	/^  memtrace_t *getMemtrace( void ) {$/;"	f	class:pseq_t
getMismatch	diagnosis.h	/^	bool getMismatch(reg_loc_t&reg_loc) {$/;"	f	class:diagnosis_t
getMode	ptrace.h	/^  ptrace_mode_t getMode( void ) {$/;"	f	class:ptrace_t
getMulticoreDiagnosis	pseq.h	/^  multicore_diagnosis_t * getMulticoreDiagnosis() { return m_multicore_diagnosis;}$/;"	f	class:pseq_t
getNewInst	decodefault.h	/^		unsigned int getNewInst() { return new_inst ; }$/;"	f	class:DecodeFault
getNext	flow.h	/^  cfg_list_t *getNext( void ) { return m_next; }$/;"	f	class:cfg_list_t
getNextAgenId	pseq.h	/^	int getNextAgenId() {$/;"	f	class:pseq_t
getNextBusId	pseq.h	/^	int getNextBusId() {$/;"	f	class:pseq_t
getNextInline	iwindow.C	/^dynamic_inst_t *iwindow_t::getNextInline( void )$/;"	f	class:iwindow_t
getNextRecoveryInstr	pseq.C	/^unsigned int pseq_t::getNextRecoveryInstr()$/;"	f	class:pseq_t
getNextUnchecked	pseq.C	/^dynamic_inst_t *pseq_t::getNextUnchecked( void )$/;"	f	class:pseq_t
getNode	flow.h	/^  flow_inst_t *getNode( void ) { return m_node; }$/;"	f	class:cfg_list_t
getNumChildren	ddg.C	/^uint64 ddg_node_t::getNumChildren()$/;"	f	class:ddg_node_t
getNumLoggingPhases	diagnosis.h	/^		int getNumLoggingPhases() { return num_logging_phases; }$/;"	f	class:multicore_diagnosis_t
getNumLogical	regmap.h	/^  uint32 getNumLogical( void ) {$/;"	f	class:reg_map_t
getNumParents	ddg.C	/^uint64 ddg_node_t::getNumParents()$/;"	f	class:ddg_node_t
getNumRegisters	regfile.h	/^        uint16 getNumRegisters( void ) const {$/;"	f	class:physical_file_t
getOSInstr	pseq.h	/^  int getOSInstr()$/;"	f	class:pseq_t
getOffset	statici.h	/^  my_addr_t getOffset() const { return (m_imm); }$/;"	f	class:static_inst_t
getOldData	memop.h	/^  ireg_t     *getOldData( void ) {$/;"	f	class:memory_inst_t
getOldInst	decodefault.h	/^		unsigned int getOldInst() { return old_inst ; }$/;"	f	class:DecodeFault
getOldLineAddress	memop.h	/^  my_addr_t getOldLineAddress(void) {$/;"	f	class:memory_inst_t
getOldPhysicalAddress	memop.h	/^  my_addr_t getOldPhysicalAddress() { return m_old_physical_addr; } $/;"	f	class:memory_inst_t
getOldReg	regmap.h	/^  half_t getOldReg() { return old_phys ; }         $/;"	f	class:reg_map_t
getOpcode	statici.h	/^  half_t              getOpcode( void ) const {$/;"	f	class:static_inst_t
getOpstat	pseq.h	/^  decode_stat_t* getOpstat( void ) {$/;"	f	class:pseq_t
getOrigDest	statici.h	/^  void getOrigDest(static_inst_t *A) {$/;"	f	class:static_inst_t
getOrigDestReg	statici.h	/^  reg_id_t &getOrigDestReg(int destnum) { $/;"	f	class:static_inst_t
getOriginalInstr	statici.h	/^  static_inst_t* getOriginalInstr() { return original;}$/;"	f	class:static_inst_t
getPC	pstate.h	/^  ireg_t getPC() {$/;"	f	class:pstate_t
getPIL	pstate.C	/^uinteger_t pstate_t::getPIL()$/;"	f	class:pstate_t
getPSEQ	dynamic.h	/^  pseq_t* getPSEQ() {return m_pseq;}$/;"	f	class:dynamic_inst_t
getPhysical	diagnosis.h	/^	half_t getPhysical(reg_loc_t&reg_loc) {$/;"	f	class:diagnosis_t
getPhysical	regbox.h	/^  inline half_t     getPhysical( void ) {$/;"	f	class:reg_id_t
getPhysicalAddress	flow.h	/^  pa_t    getPhysicalAddress(void) const {$/;"	f	class:flow_inst_t
getPhysicalAddress	memop.h	/^  my_addr_t getPhysicalAddress(void) const {$/;"	f	class:memory_inst_t
getPhysicalAddressAddress	memop.h	/^  my_addr_t* getPhysicalAddressAddress(void) {$/;"	f	class:memory_inst_t
getPhysicalRF	arf.h	/^  physical_file_t* getPhysicalRF() { return m_rf; }$/;"	f	class:abstract_rf_t
getPid	pseq.C	/^int32 pseq_t::getPid( la_t thread_p )$/;"	f	class:pseq_t
getPid	pseq.C	/^int32 pseq_t::getPid( void )$/;"	f	class:pseq_t
getPredecessor	flow.h	/^  cfg_list_t  *getPredecessor( void ) {$/;"	f	class:flow_inst_t
getPredictorState	controlop.h	/^  predictor_state_t &getPredictorState() {$/;"	f	class:control_inst_t
getPriority	wait.h	/^  uint64 getPriority( void ) { return priority; }$/;"	f	class:waiter_t
getPriv	pseq.h	/^  int getPriv()$/;"	f	class:pseq_t
getPrivilegeMode	dynamic.h	/^  bool        getPrivilegeMode( void ) {$/;"	f	class:dynamic_inst_t
getProcessorState	pstate.C	/^core_state_t  *pstate_t::getProcessorState( void ) {$/;"	f	class:pstate_t
getRAS	pseq.h	/^  ras_t  *getRAS( void ) {$/;"	f	class:pseq_t
getRID	diagnosis.h	/^	reg_id_t&getRID(reg_loc_t&reg_loc) {$/;"	f	class:diagnosis_t
getRawAccessSize	statici.h	/^  byte_t getRawAccessSize() const {return m_access_size;}$/;"	f	class:static_inst_t
getReadFault	arf.C	/^bool abstract_rf_t::getReadFault( reg_id_t &rid )$/;"	f	class:abstract_rf_t
getReadFault	arf.C	/^bool arf_double_t::getReadFault( reg_id_t &rid )$/;"	f	class:arf_double_t
getReadFault	regfile.h	/^	inline bool getReadFault( uint16 reg_no ) { return read_fault[reg_no] ; }$/;"	f	class:physical_file_t
getReadPointer	diagnosis.C	/^int llb_t::getReadPointer()$/;"	f	class:llb_t
getReady	arf.C	/^bool abstract_rf_t::getReady( reg_id_t &rid )$/;"	f	class:abstract_rf_t
getReady	arf.C	/^bool arf_control_t::getReady( reg_id_t &rid )$/;"	f	class:arf_control_t
getReady	arf.C	/^bool arf_double_t::getReady( reg_id_t &rid )$/;"	f	class:arf_double_t
getReady	regfile.h	/^	bool getReady( uint16 reg_no ) {$/;"	f	class:physical_file_t
getRefCnt	arf.C	/^int abstract_rf_t::getRefCnt(reg_id_t& rid) {$/;"	f	class:abstract_rf_t
getRefCnt	regfile.h	/^	inline int getRefCnt(uint16 reg_no) { $/;"	f	class:physical_file_t
getRefCount	flow.h	/^  int32     getRefCount( void ) {$/;"	f	class:flow_inst_t
getRefCount	statici.h	/^  uint16    getRefCount( void ) {$/;"	f	class:static_inst_t
getRegBox	pseq.h	/^  reg_box_t &getRegBox( void ) {$/;"	f	class:pseq_t
getResBus	dynamic.h	/^  int getResBus() {return m_result_bus_id; }$/;"	f	class:dynamic_inst_t
getRetInst	pseq.h	/^  uint64 getRetInst()$/;"	f	class:pseq_t
getRetPriv	pseq.h	/^  unsigned int getRetPriv()$/;"	f	class:pseq_t
getRetireMap	arf.h	/^  reg_map_t           *getRetireMap( void ) {$/;"	f	class:abstract_rf_t
getRetireRF	arf.h	/^  physical_file_t *getRetireRF( void ) {$/;"	f	class:arf_control_t
getRetiredICount	pseq.h	/^  uint64       getRetiredICount( void ) {$/;"	f	class:pseq_t
getRtype	regbox.h	/^  inline rid_type_t getRtype( void ) {$/;"	f	class:reg_id_t
getRubyCache	pseq.h	/^  rubycache_t *getRubyCache( void ) {$/;"	f	class:pseq_t
getScheduler	pseq.h	/^  scheduler_t *getScheduler( void ) {$/;"	f	class:pseq_t
getSelector	regbox.h	/^  inline byte_t     getSelector( void ) {$/;"	f	class:reg_id_t
getSeqNum	fault.h	/^		unsigned int getSeqNum() { return seq_num ; }$/;"	f	class:Fault
getSequenceNumber	dynamic.h	/^  uint64         getSequenceNumber() const { return seq_num; }$/;"	f	class:dynamic_inst_t
getSequencer	dynamic.h	/^  pseq_t* getSequencer() { return m_pseq; }$/;"	f	class:dynamic_inst_t
getSequencer	regfile.h	/^	pseq_t* getSequencer() { return m_pseq; }$/;"	f	class:physical_file_t
getSequencerID	flow.h	/^  int32   getSequencerID( void ) {$/;"	f	class:flow_inst_t
getSignedData	flow.h	/^  ireg_t      getSignedData( void ) {$/;"	f	class:flow_inst_t
getSignedData	memop.h	/^  ireg_t      getSignedData( void ) {$/;"	f	class:memory_inst_t
getSimicsCycleCount	pstate.h	/^  cycles_t   getSimicsCycleCount( void ) {$/;"	f	class:pstate_t
getSimicsMMU	pstate.h	/^  conf_object_t *getSimicsMMU( void ) {$/;"	f	class:pstate_t
getSimicsNPC	pseq.C	/^ireg_t pseq_t::getSimicsNPC() {$/;"	f	class:pseq_t
getSimicsProcessor	pstate.h	/^  conf_object_t *getSimicsProcessor( void ) {$/;"	f	class:pstate_t
getSimulationStatus	system.h	/^  sim_status_t getSimulationStatus( void ) {$/;"	f	class:system_t
getSize	iwindow.h	/^  uint32 getSize( void ) { return m_rob_size; };$/;"	f	class:iwindow_t
getSortOrder	pipestate.h	/^  virtual uint64 getSortOrder( void ) { return 0; }$/;"	f	class:pipestate_t
getSortOrder	rubycache.C	/^uint64 ruby_request_t::getSortOrder( void )$/;"	f	class:ruby_request_t
getSourceNum	dynamic.C	/^int dynamic_inst_t::getSourceNum(int arch_reg_no)$/;"	f	class:dynamic_inst_t
getSourceReg	dynamic.h	/^  reg_id_t &getSourceReg( int sourcenum ) {$/;"	f	class:dynamic_inst_t
getSourceReg	flow.h	/^  reg_id_t      &getSourceReg( int sourcenum ) {$/;"	f	class:flow_inst_t
getSourceReg	statici.h	/^  reg_id_t &getSourceReg( int sourcenum ) {$/;"	f	class:static_inst_t
getSourceRegBasePtr	statici.h	/^  reg_id_t *getSourceRegBasePtr( void ) {$/;"	f	class:static_inst_t
getSpecBPS	pseq.h	/^  predictor_state_t *getSpecBPS( void ) {$/;"	f	class:pseq_t
getStage	dynamic.h	/^  stage_t getStage( void ) { return (m_stage); };$/;"	f	class:dynamic_inst_t
getStartStopPC	pseq.h	/^   char *getStartStopPC() {$/;"	f	class:pseq_t
getState	cache.h	/^  inline uint32 getState(BlockType &cb) { return (cb.address_state & 0x7); }$/;"	f	class:generic_cache_template
getStaticInst	dynamic.h	/^  static_inst_t *getStaticInst( void ) const { return s; }$/;"	f	class:dynamic_inst_t
getStaticInst	flow.h	/^  static_inst_t *getStaticInst( void ) const { return m_static_inst; }$/;"	f	class:flow_inst_t
getStats	statici.C	/^static_stat_t *static_inst_t::getStats( void )$/;"	f	class:static_inst_t
getStoreValueReady	memop.h	/^  bool getStoreValueReady() const {$/;"	f	class:store_inst_t
getStuckAt	fault.h	/^		int getStuckAt() { return stuck_at ; }$/;"	f	class:Fault
getStuckSrc	dynamic.h	/^  int getStuckSrc() {return stuck_src; }$/;"	f	class:dynamic_inst_t
getSuccessor	flow.h	/^  cfg_list_t  *getSuccessor( void ) {$/;"	f	class:flow_inst_t
getSymptomSeen	pseq.h	/^  bool getSymptomSeen() { return symptom_seen ; }$/;"	f	class:pseq_t
getSyncTarget	regfile.h	/^	uint16 getSyncTarget(uint16 phy_reg) {$/;"	f	class:physical_file_t
getTLstack	pseq.h	/^  tlstack_t *getTLstack( void ) {$/;"	f	class:pseq_t
getTaken	flow.h	/^  bool           getTaken( void ) {$/;"	f	class:flow_inst_t
getThreadPhysAddress	pseq.C	/^la_t pseq_t::getThreadPhysAddress( void )$/;"	f	class:pseq_t
getTime	mf_api.h	/^  uint64 (*getTime)( void );$/;"	m	struct:mf_ruby_api
getTime	pstate.h	/^  pc_step_t      getTime( void ) {$/;"	f	class:pstate_t
getToFreeReg	dynamic.h	/^  reg_id_t &getToFreeReg( int destnum ) {$/;"	f	class:dynamic_inst_t
getTrapRate	pseq.h	/^  int getTrapRate() { return curr_trap_rate ; } $/;"	f	class:pseq_t
getTrapType	dynamic.h	/^  trap_type_t getTrapType( void ) {$/;"	f	class:dynamic_inst_t
getTrapType	flow.h	/^  trap_type_t getTrapType( void ) {$/;"	f	class:flow_inst_t
getType	statici.h	/^  dyn_execute_type_t  getType( void ) const {$/;"	f	class:static_inst_t
getUnreadySubId	arf.C	/^reg_id_t& arf_container_t::getUnreadySubId(reg_id_t &rid) $/;"	f	class:arf_container_t
getUnsignedData	flow.h	/^  ireg_t      getUnsignedData( void ) {$/;"	f	class:flow_inst_t
getUnsignedData	memop.h	/^  ireg_t      getUnsignedData( void ) {$/;"	f	class:memory_inst_t
getVPC	dynamic.h	/^  la_t           getVPC( void ) const {$/;"	f	class:dynamic_inst_t
getVPC	flow.h	/^  la_t           getVPC( void ) const {$/;"	f	class:flow_inst_t
getValue	diagnosis.h	/^	ireg_t getValue(reg_loc_t&reg_loc) {$/;"	f	class:diagnosis_t
getVanPtr	regbox.h	/^  char* getVanPtr() { return &m_vanilla;}$/;"	f	class:reg_id_t
getVanilla	regbox.h	/^  inline byte_t     getVanilla( void ) {$/;"	f	class:reg_id_t
getVanillaState	regbox.h	/^  inline byte_t     getVanillaState( void ) {$/;"	f	class:reg_id_t
getWayCounter	pseq.h	/^  int getWayCounter() { return way_counter; } $/;"	f	class:pseq_t
getWindowIndex	dynamic.h	/^  int32          getWindowIndex() const { return m_windex; }$/;"	f	class:dynamic_inst_t
get_cache_data	cache.C	/^attr_value_t generic_cache_template<BlockType>::get_cache_data( void *ptr, void *obj ) {$/;"	f	class:generic_cache_template
global_regs	diagnosis.h	/^  ireg_t   global_regs[MAX_GLOBAL_REGS];$/;"	m	struct:core_state
goldenResult	dynamic.h	/^  ireg_t goldenResult; $/;"	m	class:dynamic_inst_t
good_inst	diagnosis.h	/^	func_inst_info_t good_inst;$/;"	m	struct:__anon7
good_value	diagnosis.h	/^	ireg_t good_value;$/;"	m	struct:__anon6
good_value	diagnosis.h	/^    ireg_t good_value;$/;"	m	struct:__anon1
half_cmp	pseq.h	/^	struct half_cmp {$/;"	s	class:pseq_t
haltSimulation	system.C	/^void system_t::haltSimulation( void )$/;"	f	class:system_t
hasDiagnosisStarted	diagnosis.h	/^		bool hasDiagnosisStarted() {return diagnosis_started; }$/;"	f	class:multicore_diagnosis_t
hasExecuted	dynamic.h	/^  bool   hasExecuted() const { return (m_stage > READY_STAGE); }$/;"	f	class:dynamic_inst_t
hasPhysicalAddress	dynamic.h	/^  virtual bool hasPhysicalAddress() { return true; }$/;"	f	class:dynamic_inst_t
hasPhysicalAddress	memop.h	/^  bool hasPhysicalAddress() { return (m_physical_addr != -1); }$/;"	f	class:memory_inst_t
has_fault	dynamic.h	/^  bool has_fault ;$/;"	m	class:dynamic_inst_t
has_fault	regfile.h	/^		bool           *has_fault ;$/;"	m	class:physical_file_t
has_fault	regmap.h	/^  bool           *has_fault ;$/;"	m	class:reg_map_t
has_fault	statici.h	/^  bool      has_fault ;$/;"	m	class:static_inst_t
has_mem_fault	memop.h	/^  bool       has_mem_fault;$/;"	m	class:memory_inst_t
hash_ent	histogram.h	/^struct hash_ent {$/;"	s
hash_function	ipagemap.h	/^  inline uint32  hash_function( pa_t address ) {$/;"	f	class:ipagemap_t
hash_next	mshr.h	/^  miss_t         *hash_next;$/;"	m	class:miss_t
hfa_allocate	hfa.C	/^void hfa_allocate( void )$/;"	f
hfa_checkerr	hfa.C	/^void hfa_checkerr( const char *location )$/;"	f
hfa_checkpoint_interval	hfa.C	/^static void hfa_checkpoint_interval(int interval)$/;"	f	file:
hfa_compare_point	hfa.C	/^static void hfa_compare_point( int r ) $/;"	f	file:
hfa_config_generate_values	hfa.C	/^static void hfa_config_generate_values( void )$/;"	f	file:
hfa_connect_amber	hfa.C	/^static void hfa_connect_amber()$/;"	f	file:
hfa_construct_initvar	hfa.C	/^void hfa_construct_initvar( void )$/;"	f
hfa_deallocate	hfa.C	/^void hfa_deallocate( void )$/;"	f
hfa_debug_time	hfa.C	/^static void hfa_debug_time( int procid, int64 dbgtime )$/;"	f	file:
hfa_dispatch_get	hfa.C	/^attr_value_t hfa_dispatch_get( void *id, conf_object_t *obj,$/;"	f
hfa_dispatch_set	hfa.C	/^set_error_t hfa_dispatch_set( void *id, conf_object_t *obj, $/;"	f
hfa_fault_bit	hfa.C	/^static void hfa_fault_bit( int bit )$/;"	f	file:
hfa_fault_inj_inst	hfa.C	/^static void hfa_fault_inj_inst( int r ) $/;"	f	file:
hfa_fault_log	hfa.C	/^static void hfa_fault_log( const char *filename)$/;"	f	file:
hfa_fault_stuck_at	hfa.C	/^static void hfa_fault_stuck_at( int bit )$/;"	f	file:
hfa_fault_type	hfa.C	/^static void hfa_fault_type( int faulttype)$/;"	f	file:
hfa_faulty_core	hfa.C	/^static void hfa_faulty_core( int c ) $/;"	f	file:
hfa_faulty_fanout_id	hfa.C	/^static void hfa_faulty_fanout_id( int id )$/;"	f	file:
hfa_faulty_gate_id	hfa.C	/^static void hfa_faulty_gate_id( int id )$/;"	f	file:
hfa_faulty_machine	hfa.C	/^static void hfa_faulty_machine( string s )$/;"	f	file:
hfa_faulty_reg_no	hfa.C	/^static void hfa_faulty_reg_no( int r ) $/;"	f	file:
hfa_faulty_reg_srcdest	hfa.C	/^static void hfa_faulty_reg_srcdest( int r ) $/;"	f	file:
hfa_inf_loop_start	hfa.C	/^static void hfa_inf_loop_start( uint64 start_cycle )$/;"	f	file:
hfa_inorder_step	hfa.C	/^static void hfa_inorder_step( int64 numSteps )$/;"	f	file:
hfa_install_snoop	hfa.C	/^static void hfa_install_snoop( void )$/;"	f	file:
hfa_list_param	hfa.C	/^void hfa_list_param( FILE *fp )$/;"	f
hfa_print_fault_stats	hfa.C	/^static void hfa_print_fault_stats( )$/;"	f	file:
hfa_response_pipe	hfa.C	/^static void hfa_response_pipe( string s )$/;"	f	file:
hfa_server_client	hfa.C	/^static void hfa_server_client( const int mode)$/;"	f	file:
hfa_sim_break	hfa.C	/^static void hfa_sim_break( void )$/;"	f	file:
hfa_sim_start	hfa.C	/^static void hfa_sim_start( const char *simname )$/;"	f	file:
hfa_sim_step	hfa.C	/^static void hfa_sim_step( int64 numSteps )$/;"	f	file:
hfa_sim_stop	hfa.C	/^static void hfa_sim_stop( void )$/;"	f	file:
hfa_sim_warmup	hfa.C	/^void hfa_sim_warmup( void )$/;"	f
hfa_simcheck	hfa.C	/^void hfa_simcheck( void )$/;"	f
hfa_start_branch_trace	hfa.C	/^static void hfa_start_branch_trace( const char *tracename )$/;"	f	file:
hfa_start_checkpointing	hfa.C	/^static void hfa_start_checkpointing()$/;"	f	file:
hfa_start_logging	hfa.C	/^static void hfa_start_logging( int r ) $/;"	f	file:
hfa_start_trace	hfa.C	/^static void hfa_start_trace( const char *tracename )$/;"	f	file:
hfa_stepper	hfa.C	/^static void hfa_stepper( int64 n, int64 k )$/;"	f	file:
hfa_stim_pipe	hfa.C	/^static void hfa_stim_pipe( string s )$/;"	f	file:
hfa_stop_branch_trace	hfa.C	/^static void hfa_stop_branch_trace( void )$/;"	f	file:
hfa_stop_trace	hfa.C	/^static void hfa_stop_trace( void )$/;"	f	file:
hfa_take_branch_trace	hfa.C	/^static void hfa_take_branch_trace( int64 numSteps )$/;"	f	file:
hfa_take_branch_trace_inf	hfa.C	/^static void hfa_take_branch_trace_inf( void )$/;"	f	file:
hfa_take_skip_trace	hfa.C	/^static void hfa_take_skip_trace( int64 numSteps )$/;"	f	file:
hfa_take_trace	hfa.C	/^static void hfa_take_trace( int64 numSteps )$/;"	f	file:
hfa_togglemh	hfa.C	/^static void hfa_togglemh( void )$/;"	f	file:
hfa_writeTraceStep	hfa.C	/^static void hfa_writeTraceStep( void )$/;"	f	file:
histo_x_t	histogram.h	/^typedef int32 histo_x_t; \/* 32 bits *\/$/;"	t
histo_y_t	histogram.h	/^typedef int32 histo_y_t; \/* 32 bits *\/$/;"	t
histogram_t	histogram.C	/^histogram_t::histogram_t(const char* name, int size)$/;"	f	class:histogram_t
histogram_t	histogram.h	/^class histogram_t {$/;"	c
hitCallback	mf_api.h	/^  void (*hitCallback)( int cpuNumber, unsigned long long int phys_address );$/;"	m	struct:mf_opal_api
hw_hang_cnt	pseq.h	/^  int hw_hang_cnt;$/;"	m	class:pseq_t
i_idx	diagnosis.h	/^	int i_idx;$/;"	m	struct:__anon9
id	diagnosis.h	/^	int id;$/;"	m	struct:__anon1
idealCheckTo	pseq.C	/^void pseq_t::idealCheckTo( int64 seq_num )$/;"	f	class:pseq_t
idealRunTo	pseq.C	/^pseq_fetch_status_t pseq_t::idealRunTo( int64 runto_seq_num )$/;"	f	class:pseq_t
il1_mshr	pseq.h	/^  mshr_t      *il1_mshr;$/;"	m	class:pseq_t
imapentry_t	ipagemap.h	/^  imapentry_t( ipage_t *entry, uint32 tag ) {$/;"	f	class:imapentry_t
imapentry_t	ipagemap.h	/^class imapentry_t {$/;"	c
imm	diagnosis.h	/^	ireg_t imm;$/;"	m	struct:__anon4
immediate	diagnosis.h	/^	ireg_t immediate;$/;"	m	struct:__anon7
inFuncTrap	pseq.h	/^  void inFuncTrap()$/;"	f	class:pseq_t
inIdleLoop	dynamic.C	/^bool dynamic_inst_t::inIdleLoop()$/;"	f	class:dynamic_inst_t
inIdleLoop	pseq.C	/^bool pseq_t::inIdleLoop(la_t virtual_address)$/;"	f	class:pseq_t
inSameRF	diagnosis.h	/^	bool inSameRF(reg_id_t&A, reg_id_t&B) {$/;"	f	class:diagnosis_t
in_interrupt	pseq.h	/^  bool in_interrupt ;$/;"	m	class:pseq_t
incBranches	pseq.h	/^  void incBranches()$/;"	f	class:pseq_t
incFP	pseq.h	/^  void incFP(int i, int j) { FP_util[i-4][j]++; }$/;"	f	class:pseq_t
incFatalTraps	pseq.h	/^  void incFatalTraps()$/;"	f	class:pseq_t
incReadInj	pseq.h	/^  void incReadInj()$/;"	f	class:pseq_t
incReadMask	pseq.h	/^  void incReadMask()$/;"	f	class:pseq_t
incRefCnt	regfile.h	/^	inline void incRefCnt(uint16 reg_no) { $/;"	f	class:physical_file_t
incStores	pseq.h	/^  void incStores()$/;"	f	class:pseq_t
incTotalInj	pseq.h	/^  void incTotalInj()$/;"	f	class:pseq_t
incTotalMask	pseq.h	/^  void incTotalMask()$/;"	f	class:pseq_t
incTotalTraps	pseq.h	/^  void incTotalTraps()$/;"	f	class:pseq_t
incWayCounter	pseq.h	/^  void incWayCounter() { way_counter++; } $/;"	f	class:pseq_t
increment	flatarf.C	/^static void increment( flow_inst_t *f ) $/;"	f	file:
incrementNoncompliant	decode.h	/^  void    incrementNoncompliant( enum i_opcode op ) {$/;"	f	class:decode_stat_t
incrementRefCount	flow.h	/^  void      incrementRefCount( void ) {$/;"	f	class:flow_inst_t
incrementRefCount	statici.h	/^  void      incrementRefCount( void ) {$/;"	f	class:static_inst_t
index	diagnosis.h	/^	int index;$/;"	m	struct:llb_queue_entry
index2	diagnosis.h	/^	uint16 index2;$/;"	m	struct:llb_queue_entry
infectedAGEN	dynamic.h	/^  bool infectedAGEN ;$/;"	m	class:dynamic_inst_t
infectedALU	dynamic.h	/^  bool infectedALU;$/;"	m	class:dynamic_inst_t
infectedResult	dynamic.h	/^  ireg_t infectedResult;$/;"	m	class:dynamic_inst_t
inflight_miss_manager	mshr.h	/^  replacement_manager_t<miss_t>   inflight_miss_manager;$/;"	m	class:mshr_t
init	mshr.C	/^void miss_t::init(mshr_t *mshr) {$/;"	f	class:miss_t
init	mshr.C	/^void miss_t::init(void) {$/;"	f	class:miss_t
initAmber	system.h	/^  void initAmber() {$/;"	f	class:system_t
initControlSizeMap	regbox.C	/^reg_box_t::initControlSizeMap( control_reg_t reg )$/;"	f	class:reg_box_t
initHead	pipestate.h	/^  void initHead( void ) {$/;"	f	class:pipestate_t
initIregGlobalMap	regbox.C	/^reg_box_t::initIregGlobalMap( byte_t arch_reg, uint16 gset )$/;"	f	class:reg_box_t
initIregWindowMap	regbox.C	/^reg_box_t::initIregWindowMap( byte_t arch_reg, uint16 cwp )$/;"	f	class:reg_box_t
initOpcodeExecTable	system.C	/^void system_t::initOpcodeExecTable() {$/;"	f	class:system_t
initStateregMap	regbox.C	/^reg_box_t::initStateregMap( byte_t reg_no, bool isPriv )$/;"	f	class:reg_box_t
initThreadPointers	system.C	/^void system_t::initThreadPointers( void ) {$/;"	f	class:system_t
initialize	amber_api.h	/^	void (*initialize)() ;$/;"	m	struct:mf_amber_api
initialize	arf.C	/^void      arf_cc_t::initialize( void )$/;"	f	class:arf_cc_t
initialize	arf.C	/^void      arf_int_global_t::initialize( void )$/;"	f	class:arf_int_global_t
initialize	arf.C	/^void      arf_int_t::initialize( void )$/;"	f	class:arf_int_t
initialize	arf.C	/^void      arf_single_t::initialize( void )$/;"	f	class:arf_single_t
initialize	arf.C	/^void    abstract_rf_t::initialize( void )$/;"	f	class:abstract_rf_t
initialize	arf.C	/^void    arf_container_t::initialize( void )$/;"	f	class:arf_container_t
initialize	arf.C	/^void    arf_control_t::initialize( void )$/;"	f	class:arf_control_t
initialize	arf.C	/^void    arf_double_t::initialize( void )$/;"	f	class:arf_double_t
initialize	arf.h	/^  void    initialize( void ) { }$/;"	f	class:arf_none_t
initialize	dynamic.C	/^void dynamic_inst_t::initialize( void )$/;"	f	class:dynamic_inst_t
initialize	iwindow.C	/^void iwindow_t::initialize( void ) {$/;"	f	class:iwindow_t
initialize	lsq.h	/^  void initialize( void ) {$/;"	f	class:lsq_t
initialize	statici.C	/^void static_inst_t::initialize( void )$/;"	f	class:static_inst_t
initializeControl	arf.C	/^void    abstract_rf_t::initializeControl( reg_id_t &rid )$/;"	f	class:abstract_rf_t
initializeControl	arf.C	/^void    arf_container_t::initializeControl( reg_id_t &rid )$/;"	f	class:arf_container_t
initializeControl	arf.C	/^void    arf_control_t::initializeControl( reg_id_t &rid )$/;"	f	class:arf_control_t
initializeControl	flatarf.C	/^void    flat_container_t::initializeControl( reg_id_t &rid )$/;"	f	class:flat_container_t
initializeControl	flatarf.C	/^void flat_control_t::initializeControl( reg_id_t &rid )$/;"	f	class:flat_control_t
initializeMappings	regbox.C	/^void reg_box_t::initializeMappings( void )$/;"	f	class:reg_box_t
initializeRecoveryInstrMem	pseq.C	/^void pseq_t::initializeRecoveryInstrMem() $/;"	f	class:pseq_t
initializeState	flatarf.C	/^void      flat_control_t::initializeState( pstate_t *state )$/;"	f	class:flat_control_t
initializeState	flatarf.C	/^void      flat_int_global_t::initializeState( pstate_t *state )$/;"	f	class:flat_int_global_t
initializeState	flatarf.C	/^void      flat_single_t::initializeState( pstate_t *state )$/;"	f	class:flat_single_t
initializeState	flatarf.C	/^void    flat_double_t::initializeState( pstate_t *state )$/;"	f	class:flat_double_t
initializeState	flatarf.C	/^void    flat_int_t::initializeState( pstate_t *state )$/;"	f	class:flat_int_t
initializeStats	pseq.C	/^pseq_t::initializeStats(void) {$/;"	f	class:pseq_t
injectFault	pseq.h	/^  byte_t injectFault(byte_t value)$/;"	f	class:pseq_t
injectFault	pseq.h	/^  half_t injectFault(half_t value)$/;"	f	class:pseq_t
injectFault	pseq.h	/^  uint32 injectFault(uint32 value)$/;"	f	class:pseq_t
injectFault	pseq.h	/^  uint64 injectFault(uint64 value)$/;"	f	class:pseq_t
injectTransientFault	iwindow.h	/^  void injectTransientFault() {$/;"	f	class:iwindow_t
injectTransientFault	pseq.C	/^void pseq_t::injectTransientFault(half_t physical_reg_no) $/;"	f	class:pseq_t
injectTransientFault	regfile.h	/^	void injectTransientFault(half_t inj_reg_no = -1) {$/;"	f	class:physical_file_t
injectTransientFault	regmap.h	/^  void injectTransientFault() {$/;"	f	class:reg_map_t
inject_cycle	fault.h	/^		tick_t inject_cycle ;	\/\/ Cycle at which fault was injected$/;"	m	class:Fault
insert	lsq.h	/^  bool        insert( memory_inst_t *memop ) {$/;"	f	class:lsq_t
insert	lsq.h	/^  bool        insert( store_inst_t *memop ) {$/;"	f	class:lsq_t
insertElement	pipestate.C	/^void pipestate_t::insertElement( pipestate_t *pool )$/;"	f	class:pipestate_t
insertEntry	dtlb.C	/^void dtlb_t::insertEntry( dtlb_entry_t *entry )$/;"	f	class:dtlb_t
insertFakeInstr	diagnosis.C	/^int diagnosis_t::insertFakeInstr(dynamic_inst_t* d)$/;"	f	class:diagnosis_t
insertHead	mshr.C	/^void replacement_manager_t<Type>::insertHead(Type *t) {$/;"	f	class:replacement_manager_t
insertInstr	ipagemap.C	/^uint16 ipagemap_t::insertInstr( pa_t address, uint32 instr,$/;"	f	class:ipagemap_t
insertInstrInfo	diagnosis.C	/^void diagnosis_t::insertInstrInfo(instruction_information_t &info)$/;"	f	class:diagnosis_t
insertInstruction	ipage.C	/^uint16 ipage_t::insertInstruction( pa_t address, uint32 instr,$/;"	f	class:ipage_t
insertInstruction	iwindow.C	/^void  iwindow_t::insertInstruction( dynamic_inst_t *instr )$/;"	f	class:iwindow_t
insertInstruction	pseq.C	/^static_inst_t *pseq_t::insertInstruction( pa_t fetch_ppc, unsigned int instr )$/;"	f	class:pseq_t
insertMismatchInfo	dynamic.C	/^void dynamic_inst_t::insertMismatchInfo(reg_mismatch_info_t &mismatch)$/;"	f	class:dynamic_inst_t
insertOrdered	pipepool.C	/^void pipepool_t::insertOrdered( pipestate_t *state )$/;"	f	class:pipepool_t
insertOrdered	pipestate.C	/^void pipestate_t::insertOrdered( pipestate_t *head )$/;"	f	class:pipestate_t
insertTail	mshr.C	/^void replacement_manager_t<Type>::insertTail(Type *t) {$/;"	f	class:replacement_manager_t
inst	pseq.h	/^		slice_inst *inst ;$/;"	m	struct:pseq_t::fault
inst	system.C	/^system_t  *system_t::inst = NULL;$/;"	m	class:system_t	file:
inst	system.h	/^  static system_t *inst;$/;"	m	class:system_t
inst_arith	dynamic.h	/^  bool inst_arith;$/;"	m	class:dynamic_inst_t
inst_arrival	chain.C	/^void chain_t::inst_arrival( pt_inst_t *inst )$/;"	f	class:chain_t
inst_event_t	dynamic.h	/^typedef uint16 inst_event_t;$/;"	t
inst_logic	dynamic.h	/^  bool inst_logic;$/;"	m	class:dynamic_inst_t
inst_set_t	ddg.h	/^typedef set<uint64, uint64_cmp> inst_set_t ;$/;"	t
inst_time_t	dynamic.h	/^enum inst_time_t {$/;"	g
installExceptionHandler	system.C	/^void system_t::installExceptionHandler( sim_status_t status )$/;"	f	class:system_t
installHapHandlers	system.C	/^void system_t::installHapHandlers( void )$/;"	f	class:system_t
installInterfaces	pseq.C	/^void pseq_t::installInterfaces( void )$/;"	f	class:pseq_t
installMemoryHierarchy	system.C	/^void system_t::installMemoryHierarchy( sim_status_t status )$/;"	f	class:system_t
installMemoryObserver	system.C	/^void system_t::installMemoryObserver( void )$/;"	f	class:system_t
instr	diagnosis.h	/^	uint64 instr;$/;"	m	struct:__anon2
instr_counter	diagnosis.h	/^	int instr_counter;$/;"	m	class:diagnosis_t
instr_diag_info_t	diagnosis.h	/^} instr_diag_info_t;$/;"	t	typeref:struct:__anon2
instr_diag_list	diagnosis.h	/^    vector<instr_diag_info_t> instr_diag_list;$/;"	m	class:diagnosis_t
instr_pc	pseq.h	/^  la_t   instr_pc;$/;"	m	struct:__anon20
instr_priv	pseq.h	/^  bool   instr_priv;$/;"	m	struct:__anon20
instr_seq_num	pseq.h	/^  uint64 instr_seq_num;$/;"	m	struct:__anon20
instruction_information_t	diagnosis.h	/^} instruction_information_t;$/;"	t	typeref:struct:__anon7
instruction_trace	diagnosis.h	/^	vector<instruction_information_t> instruction_trace;$/;"	m	class:diagnosis_t
intControl	pstate.C	/^ireg_t pstate_t::intControl( unsigned int reg )$/;"	f	class:pstate_t
intDouble	pstate.C	/^freg_t pstate_t::intDouble( unsigned int reg )$/;"	f	class:pstate_t
intIntGlobal	pstate.C	/^ireg_t  pstate_t::intIntGlobal( unsigned int reg, int global_set )$/;"	f	class:pstate_t
intIntWp	pstate.C	/^ireg_t  pstate_t::intIntWp( unsigned int reg, int cwp )$/;"	f	class:pstate_t
int_32	regfile.h	/^    int32    int_32;$/;"	m	union:my_register_u
int_64	regfile.h	/^    int64    int_64;$/;"	m	union:my_register_u
int_regs	diagnosis.h	/^  ireg_t   int_regs[MAX_INT_REGS];$/;"	m	struct:core_state
interrupt_priv	pseq.h	/^  int interrupt_priv ;$/;"	m	class:pseq_t
invalidateInstr	ipagemap.C	/^void ipagemap_t::invalidateInstr( pa_t address )$/;"	f	class:ipagemap_t
invalidateInstruction	ipage.C	/^void ipage_t::invalidateInstruction( pa_t address )$/;"	f	class:ipage_t
invalidateInstruction	pseq.C	/^void pseq_t::invalidateInstruction( pa_t address )$/;"	f	class:pseq_t
invariant_failed_id	pseq.h	/^  int64 invariant_failed_id ;$/;"	m	class:pseq_t
invariant_falpos_ids	pseq.h	/^  set<int64> invariant_falpos_ids ;$/;"	m	class:pseq_t
invariant_faulty_run	pseq.h	/^  bool invariant_faulty_run ;$/;"	m	class:pseq_t
invariant_last_seq_number	pseq.h	/^  uint64 invariant_last_seq_number ;$/;"	m	class:pseq_t
invariant_org_fault_injection_pt	pseq.h	/^  uint64 invariant_org_fault_injection_pt;$/;"	m	class:pseq_t
ipage_callback_t	ipage.h	/^typedef bool (*ipage_callback_t)( void *user_data, static_inst_t *s );$/;"	t
ipage_t	ipage.C	/^ipage_t::ipage_t()$/;"	f	class:ipage_t
ipage_t	ipage.h	/^class ipage_t {$/;"	c
ipagemap_t	ipagemap.C	/^ipagemap_t::ipagemap_t( uint32 tablesize )$/;"	f	class:ipagemap_t
ipagemap_t	ipagemap.h	/^class ipagemap_t {$/;"	c
iregGlobalMap	regbox.h	/^  static half_t  iregGlobalMap( byte_t arch_reg, uint16 gset ) {$/;"	f	class:reg_box_t
iregWindowMap	regbox.h	/^  static half_t  iregWindowMap( byte_t arch_reg, uint16 cwp ) {$/;"	f	class:reg_box_t
isAmberLoaded	system.h	/^  bool        isAmberLoaded( void ) {$/;"	f	class:system_t
isAppAbort	pseq.C	/^bool pseq_t::isAppAbort(la_t pc)$/;"	f	class:pseq_t
isAtPosition	iwindow.h	/^  bool   isAtPosition(dynamic_inst_t *d, uint32 position) {$/;"	f	class:iwindow_t
isBranch	diagnosis.h	/^	bool isBranch;$/;"	m	struct:__anon12
isCacheable	memop.C	/^bool memory_inst_t::isCacheable( void )$/;"	f	class:memory_inst_t
isCheckingType	diagnosis.h	/^	bool isCheckingType(reg_id_t&rid) {$/;"	f	class:diagnosis_t
isChildless	ddg.h	/^	bool isChildless() 		{ return children.empty() ; }$/;"	f	class:ddg_node_t
isCoreStoppedInTMR	diagnosis.h	/^		bool isCoreStoppedInTMR(int core_id) { return core_stopped_in_tmr[core_id]; }$/;"	f	class:multicore_diagnosis_t
isCorrupted	arf.C	/^bool abstract_rf_t::isCorrupted( reg_id_t &rid )$/;"	f	class:abstract_rf_t
isCorrupted	arf.C	/^bool arf_control_t::isCorrupted( reg_id_t &rid )$/;"	f	class:arf_control_t
isCorrupted	arf.C	/^bool arf_double_t::isCorrupted( reg_id_t &rid )$/;"	f	class:arf_double_t
isCorrupted	dynamic.h	/^  bool isCorrupted() { return corrupted;}$/;"	f	class:dynamic_inst_t
isCorrupted	regfile.h	/^	bool isCorrupted(uint16 reg_no) {$/;"	f	class:physical_file_t
isCorruptingStore	memop.h	/^  bool isCorruptingStore() {return corrupting_store;};$/;"	f	class:store_inst_t
isDataValid	flow.h	/^  bool        isDataValid( void ) const {$/;"	f	class:flow_inst_t
isDataValid	memop.h	/^  bool        isDataValid( void ) const {$/;"	f	class:memory_inst_t
isDetected	system.h	/^  bool isDetected() { return m_is_detected ; }$/;"	f	class:system_t
isEqual	memop.C	/^bool atomic_inst_t::isEqual(ireg_t* A, ireg_t* B)$/;"	f	class:atomic_inst_t
isEqual	memop.C	/^bool load_inst_t::isEqual(ireg_t* A, ireg_t* B)$/;"	f	class:load_inst_t
isEqual	memop.C	/^bool memory_inst_t::isEqual(ireg_t* A, ireg_t* B)$/;"	f	class:memory_inst_t
isFewerCand	diagnosis.h	/^	bool isFewerCand() {$/;"	f	class:diagnosis_t
isFirstTimeRollback	diagnosis.h	/^		bool isFirstTimeRollback() { return first_time_rollback; }$/;"	f	class:multicore_diagnosis_t
isFree	regfile.h	/^        bool        isFree;$/;"	m	class:physical_reg_t
isHandlingInterrupt	pseq.h	/^  bool isHandlingInterrupt() { return in_interrupt ; }$/;"	f	class:pseq_t
isIE	pstate.C	/^bool pstate_t::isIE()$/;"	f	class:pstate_t
isIOAccess	memop.h	/^  static bool isIOAccess( pa_t phys_addr ) {$/;"	f	class:memory_inst_t
isInWindow	dynamic.h	/^  bool isInWindow() {$/;"	f	class:dynamic_inst_t
isInWindow	iwindow.C	/^bool   iwindow_t::isInWindow( uint32 testNum )$/;"	f	class:iwindow_t
isInitialized	chain.h	/^  bool isInitialized( void ) {$/;"	f	class:chain_t
isInjectionInstr	pseq.C	/^bool pseq_t::isInjectionInstr(dynamic_inst_t * d_inst) {$/;"	f	class:pseq_t
isKernelPanic	pseq.C	/^bool pseq_t::isKernelPanic(la_t pc)$/;"	f	class:pseq_t
isLLBEmpty	diagnosis.C	/^bool llb_t::isLLBEmpty()$/;"	f	class:llb_t
isLLBFull	diagnosis.C	/^bool llb_t::isLLBFull()$/;"	f	class:llb_t
isLLBFull	system.C	/^bool system_t::isLLBFull(int core_id)$/;"	f	class:system_t
isLLBHit	diagnosis.C	/^bool llb_t::isLLBHit(uint64 physical_address, int core_id)$/;"	f	class:llb_t
isLastReplay	diagnosis.h	/^		bool isLastReplay() { return last_replay; }$/;"	f	class:multicore_diagnosis_t
isLater	diagnosis.C	/^bool diagnosis_t::isLater(reg_loc_t&A,reg_loc_t&B)$/;"	f	class:diagnosis_t
isLoad	pseq.h	/^    bool isLoad;$/;"	m	struct:__anon21
isLoggingPhase	diagnosis.h	/^		bool isLoggingPhase() { return logging_step; }$/;"	f	class:multicore_diagnosis_t
isLoop	pseq.C	/^void pseq_t::isLoop(dynamic_inst_t *cinst) {$/;"	f	class:pseq_t
isMarked	pseq.h	/^		bool isMarked() { return (del_mark==1) ; }$/;"	f	struct:pseq_t::fault
isMasked	decodefault.h	/^		bool isMasked() { return (old_inst == new_inst) ; }$/;"	f	class:DecodeFault
isMem	diagnosis.h	/^	bool isMem;$/;"	m	struct:__anon2
isMem	diagnosis.h	/^	bool isMem;$/;"	m	struct:__anon7
isNormal	diagnosis.h	/^	bool isNormal;$/;"	m	struct:__anon12
isOrphan	ddg.h	/^	bool isOrphan() 		{ return parents.empty() ; }$/;"	f	class:ddg_node_t
isPatched	arf.C	/^bool abstract_rf_t::isPatched( reg_id_t &rid )$/;"	f	class:abstract_rf_t
isPatched	arf.C	/^bool arf_control_t::isPatched( reg_id_t &rid )$/;"	f	class:arf_control_t
isPatched	arf.C	/^bool arf_double_t::isPatched( reg_id_t &rid )$/;"	f	class:arf_double_t
isPatched	regfile.h	/^	bool isPatched( uint16 reg_no ) {$/;"	f	class:physical_file_t
isReady	arf.C	/^bool    abstract_rf_t::isReady( reg_id_t &rid )$/;"	f	class:abstract_rf_t
isReady	arf.C	/^bool    arf_container_t::isReady( reg_id_t &rid )$/;"	f	class:arf_container_t
isReady	arf.C	/^bool    arf_control_t::isReady( reg_id_t &rid )$/;"	f	class:arf_control_t
isReady	arf.C	/^bool    arf_double_t::isReady( reg_id_t &rid )$/;"	f	class:arf_double_t
isReady	arf.h	/^  bool    isReady( reg_id_t &rid ) { return (true); }$/;"	f	class:arf_none_t
isReady	flatarf.C	/^bool    flat_rf_t::isReady( reg_id_t &rid ) {$/;"	f	class:flat_rf_t
isReady	mf_api.h	/^  int  (*isReady)( int cpuNumber, pa_t physicalAddr, OpalMemop_t typeOfRequest );$/;"	m	struct:mf_ruby_api
isReady	regfile.C	/^physical_file_t::isReady(uint16 reg_no) const {$/;"	f	class:physical_file_t
isReady	regfile.h	/^        bool        isReady;$/;"	m	class:physical_reg_t
isRecovering	pseq.h	/^  bool isRecovering() { return m_op_mode==RECOVERING;}$/;"	f	class:pseq_t
isReplayPhase	diagnosis.h	/^		bool isReplayPhase() { return is_replay_phase; }$/;"	f	class:multicore_diagnosis_t
isRetireReady	dynamic.C	/^bool dynamic_inst_t::isRetireReady() const {$/;"	f	class:dynamic_inst_t
isRubyLoaded	system.h	/^  bool        isRubyLoaded( void ) {$/;"	f	class:system_t
isSimulating	system.h	/^  bool        isSimulating( void ) {$/;"	f	class:system_t
isSlotAvailable	iwindow.h	/^  bool   isSlotAvailable( void ) {$/;"	f	class:iwindow_t
isSource	diagnosis.h	/^	bool isSource;$/;"	m	struct:__anon9
isSquashingOnAddress	diagnosis.C	/^bool multicore_diagnosis_t::isSquashingOnAddress(uint64 addr, int from_core_id)$/;"	f	class:multicore_diagnosis_t
isStore	diagnosis.h	/^	bool isStore;$/;"	m	struct:__anon12
isStuck	diagnosis.h	/^	bool isStuck;$/;"	m	struct:__anon7
isStuck	dynamic.h	/^  bool isStuck() { return m_is_stuck ; }$/;"	f	class:dynamic_inst_t
isSymptom	diagnosis.h	/^	bool isSymptom;$/;"	m	struct:__anon12
isTMRPhase	diagnosis.h	/^		bool isTMRPhase() { return tmr_phase; }$/;"	f	class:multicore_diagnosis_t
isTracing	system.h	/^  bool        isTracing( void ) {$/;"	f	class:system_t
isTrap	diagnosis.h	/^	bool isTrap;$/;"	m	struct:__anon7
isTrapFatal	pseq.C	/^pseq_t::isTrapFatal(uint16 traptype) {$/;"	f	class:pseq_t
isTriggerLoggingStep	diagnosis.h	/^		bool isTriggerLoggingStep(uint32 core_id) {return trigger_logging_step[core_id];}$/;"	f	class:multicore_diagnosis_t
isTriggerTMRStep	diagnosis.h	/^		bool isTriggerTMRStep(uint32 core_id) {return trigger_tmr_step[core_id];}$/;"	f	class:multicore_diagnosis_t
isUnknownRun	system.h	/^  bool isUnknownRun() { $/;"	f	class:system_t
isValidControlRegister	pstate.h	/^  bool    isValidControlRegister( uint32 reg ) {$/;"	f	class:pstate_t
isWaitEmpty	regfile.C	/^physical_file_t::isWaitEmpty(uint16 reg_no)$/;"	f	class:physical_file_t
isWarmingUp	system.h	/^  bool        isWarmingUp( void ) {$/;"	f	class:system_t
isZero	regbox.h	/^  inline bool isZero( void ) {$/;"	f	class:reg_id_t
is_cacheable	pstate.h	/^  static bool        is_cacheable( uint16 asi ) {$/;"	f	class:pstate_t
is_replay_phase	diagnosis.h	/^		bool is_replay_phase;$/;"	m	class:multicore_diagnosis_t
is_rob_fault	diagnosis.h	/^	bool is_rob_fault;$/;"	m	class:diagnosis_t
isfsr	pseq.h	/^    dtsb_sx, dtsbp64k, dtsbp8k, dtsbpd, ec_control, isfsr,$/;"	e	enum:tlb_reg_t
itag_access	pseq.h	/^    itag_access, itag_target, itlb_2w_daccess, itlb_2w_tagread, itlb_fa_daccess, $/;"	e	enum:tlb_reg_t
itag_target	pseq.h	/^    itag_access, itag_target, itlb_2w_daccess, itlb_2w_tagread, itlb_fa_daccess, $/;"	e	enum:tlb_reg_t
itlb_2w_daccess	pseq.h	/^    itag_access, itag_target, itlb_2w_daccess, itlb_2w_tagread, itlb_fa_daccess, $/;"	e	enum:tlb_reg_t
itlb_2w_tagread	pseq.h	/^    itag_access, itag_target, itlb_2w_daccess, itlb_2w_tagread, itlb_fa_daccess, $/;"	e	enum:tlb_reg_t
itlb_fa_daccess	pseq.h	/^    itag_access, itag_target, itlb_2w_daccess, itlb_2w_tagread, itlb_fa_daccess, $/;"	e	enum:tlb_reg_t
itlb_fa_tagread	pseq.h	/^    itlb_fa_tagread, itsb, itsb_nx, itsb_px, itsbp64k, itsbp8k,$/;"	e	enum:tlb_reg_t
itsb	pseq.h	/^    itlb_fa_tagread, itsb, itsb_nx, itsb_px, itsbp64k, itsbp8k,$/;"	e	enum:tlb_reg_t
itsb_nx	pseq.h	/^    itlb_fa_tagread, itsb, itsb_nx, itsb_px, itsbp64k, itsbp8k,$/;"	e	enum:tlb_reg_t
itsb_px	pseq.h	/^    itlb_fa_tagread, itsb, itsb_nx, itsb_px, itsbp64k, itsbp8k,$/;"	e	enum:tlb_reg_t
itsbp64k	pseq.h	/^    itlb_fa_tagread, itsb, itsb_nx, itsb_px, itsbp64k, itsbp8k,$/;"	e	enum:tlb_reg_t
itsbp8k	pseq.h	/^    itlb_fa_tagread, itsb, itsb_nx, itsb_px, itsbp64k, itsbp8k,$/;"	e	enum:tlb_reg_t
iwin_decrement	iwindow.h	/^  uint32 iwin_decrement( uint32 index ) {$/;"	f	class:iwindow_t
iwin_increment	iwindow.h	/^  uint32 iwin_increment( uint32 index ) {$/;"	f	class:iwindow_t
iwin_wrap	iwindow.h	/^  uint32 iwin_wrap( uint32 index ) {$/;"	f	class:iwindow_t
iwindow_t	iwindow.C	/^iwindow_t::iwindow_t(uint32 rob_size, uint32 win_size)$/;"	f	class:iwindow_t
iwindow_t	iwindow.h	/^class iwindow_t {$/;"	c
iword	diagnosis.h	/^	uint32 iword;$/;"	m	struct:__anon4
iword	diagnosis.h	/^	uint32 iword;$/;"	m	struct:__anon7
ix_build_jump_table	ix.C	/^void flow_inst_t::ix_build_jump_table( void )$/;"	f	class:flow_inst_t
l1_data_cache	pseq.h	/^  generic_cache_template<generic_cache_block_t> *l1_data_cache;$/;"	m	class:pseq_t
l1_inst_cache	pseq.h	/^  generic_cache_template<generic_cache_block_t> *l1_inst_cache;$/;"	m	class:pseq_t
l2_cache	pseq.h	/^  generic_cache_template<generic_cache_block_t> *l2_cache;$/;"	m	class:pseq_t
l2_mshr	pseq.h	/^  mshr_t      *l2_mshr;$/;"	m	class:pseq_t
la_t	mf_api.h	/^typedef physical_address_t la_t;$/;"	t
last	diagnosis.h	/^	int last;$/;"	m	class:llb_t
lastLogicalWriter	diagnosis.C	/^void diagnosis_t::lastLogicalWriter(reg_loc_t &reg_loc, reg_loc_t &ret_loc)$/;"	f	class:diagnosis_t
lastPhysicalWriter	diagnosis.C	/^void diagnosis_t::lastPhysicalWriter(reg_loc_t &reg_loc, reg_loc_t &ret_loc)$/;"	f	class:diagnosis_t
last_access	cache.h	/^  tick_t     last_access;$/;"	m	class:generic_cache_block_t
last_addr_fault	pseq.C	/^pseq_t::last_addr_fault_t pseq_t::last_addr_fault ;$/;"	m	class:pseq_t	file:
last_addr_fault	pseq.h	/^	static last_addr_fault_t last_addr_fault ;$/;"	m	class:pseq_t
last_addr_fault_t	pseq.h	/^	typedef map<uint64, uint64, uint64_cmp> last_addr_fault_t ;$/;"	t	class:pseq_t
last_alu_used	scheduler.h	/^  byte_t last_alu_used[FU_NUM_FU_TYPES] ;$/;"	m	class:scheduler_t
last_app_inst	pseq.h	/^  uint64 last_app_inst;$/;"	m	class:pseq_t
last_etag_write	pseq.h	/^    last_etag_write, lfsr, lsu_ctrl, madr_1, madr_2, madr_3, madr_4,$/;"	e	enum:tlb_reg_t
last_processed_inst	diagnosis.h	/^	int last_processed_inst;$/;"	m	class:diagnosis_t
last_reader	ddg.h	/^	uint64 last_reader ;$/;"	m	class:ddg_node_t
last_reg_fault	pseq.C	/^pseq_t::last_reg_fault_t pseq_t::last_reg_fault ;$/;"	m	class:pseq_t	file:
last_reg_fault	pseq.h	/^	static last_reg_fault_t last_reg_fault ;$/;"	m	class:pseq_t
last_reg_fault_t	pseq.h	/^	typedef map<half_t, uint64, half_cmp> last_reg_fault_t ;$/;"	t	class:pseq_t
last_replay	diagnosis.h	/^		bool last_replay;$/;"	m	class:multicore_diagnosis_t
last_rollback_time	pseq.h	/^  uint64 last_rollback_time;$/;"	m	class:pseq_t
last_store_t	pseq.h	/^	typedef map<la_t, ddg_node_t*, addr_cmp> last_store_t ;$/;"	t	class:pseq_t
leakCheck	regmap.C	/^reg_map_t::leakCheck( uint32 id, const char *map_name ) const$/;"	f	class:reg_map_t
lfsr	pseq.h	/^    last_etag_write, lfsr, lsu_ctrl, madr_1, madr_2, madr_3, madr_4,$/;"	e	enum:tlb_reg_t
ll_decode_fail	statici.h	/^	bool 	  ll_decode_fail ; $/;"	m	class:static_inst_t
llb	diagnosis.h	/^		llb_t **llb;$/;"	m	class:multicore_diagnosis_t
llb	pseq.h	/^  llb_t *llb;$/;"	m	class:pseq_t
llbQueueElementAt	diagnosis.h	/^		llb_queue_entry_t llbQueueElementAt(int i) { return llb_queue[i]; }$/;"	f	class:llb_t
llb_miss	diagnosis.h	/^		bool *llb_miss;$/;"	m	class:multicore_diagnosis_t
llb_miss_instr	diagnosis.h	/^		uint64 *llb_miss_instr;$/;"	m	class:multicore_diagnosis_t
llb_miss_last_replay	diagnosis.h	/^		bool llb_miss_last_replay;$/;"	m	class:multicore_diagnosis_t
llb_miss_last_replay_instr	diagnosis.h	/^		uint64 llb_miss_last_replay_instr;$/;"	m	class:multicore_diagnosis_t
llb_queue	diagnosis.h	/^	struct llb_queue_entry * llb_queue;$/;"	m	class:llb_t	typeref:struct:llb_t::llb_queue_entry
llb_queue_entry	diagnosis.h	/^struct llb_queue_entry {$/;"	s
llb_queue_entry_t	diagnosis.h	/^typedef struct llb_queue_entry llb_queue_entry_t;$/;"	t	typeref:struct:llb_queue_entry
llb_queue_size	diagnosis.h	/^	int llb_queue_size;$/;"	m	class:llb_t
llb_read_pointer	memop.h	/^	int llb_read_pointer;$/;"	m	class:atomic_inst_t
llb_read_pointer	memop.h	/^	int llb_read_pointer;$/;"	m	class:load_inst_t
llb_t	diagnosis.C	/^llb_t::llb_t() {$/;"	f	class:llb_t
llb_t	diagnosis.h	/^class llb_t {$/;"	c
loadCheckpoint	diagnosis.C	/^void multicore_diagnosis_t::loadCheckpoint(int from, int to)$/;"	f	class:multicore_diagnosis_t
loadRegState	diagnosis.C	/^void multicore_diagnosis_t::loadRegState(int from, int to)$/;"	f	class:multicore_diagnosis_t
loadSearch	lsq.C	/^bool lsq_t::loadSearch( memory_inst_t *memop ) {$/;"	f	class:lsq_t
loadTLB	diagnosis.C	/^void multicore_diagnosis_t::loadTLB(int from, int to)$/;"	f	class:multicore_diagnosis_t
load_buffer_cmp	diagnosis.h	/^struct load_buffer_cmp {$/;"	s
load_buffer_t	diagnosis.h	/^typedef vector<struct load_info> load_buffer_t;	\/\/queue of load_info storing value and address of load instructions$/;"	t
load_info	diagnosis.h	/^struct load_info {$/;"	s
load_info_t	diagnosis.h	/^typedef struct load_info load_info_t;$/;"	t	typeref:struct:load_info
load_inst_t	memop.C	/^load_inst_t::load_inst_t( static_inst_t *s_inst, $/;"	f	class:load_inst_t
load_inst_t	memop.h	/^class load_inst_t : public memory_inst_t, public load_interface_t {$/;"	c
load_interface_t	memop.h	/^class load_interface_t {$/;"	c
loc_id_t	diagnosis.h	/^enum loc_id_t {INVALID,$/;"	g
loc_list	diagnosis.h	/^	vector<faulty_loc_t> loc_list;$/;"	m	struct:__anon10
localCycleIncrement	pseq.h	/^  void         localCycleIncrement( void ) {$/;"	f	class:pseq_t
lock_atomic	lockstat.C	/^void lock_stat_t::lock_atomic( pseq_t *pseq, atomic_inst_t *atomicop )$/;"	f	class:lock_stat_t
lock_compare	sysstat.C	/^static int lock_compare( const void *el1, const void *el2 )$/;"	f	file:
lock_read	lockstat.C	/^void lock_stat_t::lock_read( pseq_t *pseq, load_inst_t *loadop )$/;"	f	class:lock_stat_t
lock_stat_t	lockstat.C	/^lock_stat_t::lock_stat_t( void )$/;"	f	class:lock_stat_t
lock_stat_t	lockstat.h	/^class lock_stat_t {$/;"	c
lock_write	lockstat.C	/^void lock_stat_t::lock_write( pseq_t *pseq, store_inst_t *storeop )$/;"	f	class:lock_stat_t
logLogicalRenameCount	pseq.C	/^void pseq_t::logLogicalRenameCount( rid_type_t rid, half_t logical, $/;"	f	class:pseq_t
logMemEvent	pseq.C	/^void pseq_t::logMemEvent(uint64 addr, int access_size, ireg_t *data)$/;"	f	class:pseq_t
log_func_inst_info	pseq.C	/^void pseq_t::log_func_inst_info( dynamic_inst_t *dinst )$/;"	f	class:pseq_t
log_reg_bin	diagnosis.h	/^	int *log_reg_bin;$/;"	m	class:diagnosis_t
loggingStepTriggered	diagnosis.h	/^		void loggingStepTriggered(uint32 core_id) {trigger_logging_step[core_id] = false;}$/;"	f	class:multicore_diagnosis_t
logging_latency_cycles	diagnosis.h	/^		uint64 logging_latency_cycles;$/;"	m	class:multicore_diagnosis_t
logging_step	diagnosis.h	/^		bool logging_step;$/;"	m	class:multicore_diagnosis_t
logical_reg	diagnosis.h	/^    int logical_reg;$/;"	m	struct:__anon1
longChange	inv-defs.h	/^    long long longChange;$/;"	m	union:Invariant::__anon15
longChange	inv-defs.h	/^    long long longChange;$/;"	m	union:MulRangeInvariant::__anon18
longMax	inv-defs.h	/^    long long longMax;$/;"	m	union:Invariant::__anon14
longMax	inv-defs.h	/^    long long longMax[MAX_NUM_RANGES];$/;"	m	union:MulRangeInvariant::__anon17
longMin	inv-defs.h	/^    long long longMin;$/;"	m	union:Invariant::__anon13
longMin	inv-defs.h	/^    long long longMin[MAX_NUM_RANGES];$/;"	m	union:MulRangeInvariant::__anon16
longValue	inv-defs.h	/^  long long longValue;$/;"	m	union:__anon19
lookupInstruction	pseq.C	/^void pseq_t::lookupInstruction( const abstract_pc_t *apc,$/;"	f	class:pseq_t
lookupOpExecTab	system.C	/^dyn_execute_type_t system_t::lookupOpExecTab(int y) {$/;"	f	class:system_t
loop_info	pseq.h	/^  uint64     loop_info[LOOP_HASH_SIZE][VALUE_START+2];$/;"	m	class:pseq_t
lsqBypass	memop.C	/^atomic_inst_t::lsqBypass( void ) {$/;"	f	class:atomic_inst_t
lsqBypass	memop.C	/^load_inst_t::lsqBypass( void ) {$/;"	f	class:load_inst_t
lsqWait	memop.C	/^atomic_inst_t::lsqWait( void ) {$/;"	f	class:atomic_inst_t
lsqWait	memop.C	/^load_inst_t::lsqWait( void ) {$/;"	f	class:load_inst_t
lsq_next	memop.h	/^  memory_inst_t *lsq_next;$/;"	m	class:memory_inst_t
lsq_prev	memop.h	/^  memory_inst_t *lsq_prev;$/;"	m	class:memory_inst_t
lsq_t	lsq.h	/^  lsq_t( pseq_t *seq ) {$/;"	f	class:lsq_t
lsq_t	lsq.h	/^class lsq_t {$/;"	c
lsu_ctrl	pseq.h	/^    last_etag_write, lfsr, lsu_ctrl, madr_1, madr_2, madr_3, madr_4,$/;"	e	enum:tlb_reg_t
m_access_size	flow.h	/^  byte_t           m_access_size;$/;"	m	class:flow_inst_t
m_access_size	memop.h	/^  byte_t         m_access_size;$/;"	m	class:memory_inst_t
m_access_size	statici.h	/^  byte_t    m_access_size;$/;"	m	class:static_inst_t
m_acquire_time	lockstat.h	/^  uint32                m_acquire_time;$/;"	m	class:lock_stat_t
m_acquires	lockstat.h	/^  uint32                m_acquires;$/;"	m	class:lock_stat_t
m_act_schedule	pseq.h	/^  actor_t    *m_act_schedule;$/;"	m	class:pseq_t
m_actual	controlop.h	/^  abstract_pc_t     m_actual;$/;"	m	class:control_inst_t
m_actual_at	flow.h	/^  abstract_pc_t    m_actual_at;$/;"	m	class:flow_inst_t
m_address	flow.h	/^  la_t             m_address;$/;"	m	class:flow_inst_t
m_address	memop.h	/^  my_addr_t  m_address;$/;"	m	class:memory_inst_t
m_address	mshr.h	/^  pa_t            m_address;$/;"	m	class:miss_t
m_advance_simics_exception	pstate.h	/^	bool m_advance_simics_exception;$/;"	m	class:pstate_t
m_agen_id	dynamic.h	/^  int  m_agen_id;$/;"	m	class:dynamic_inst_t
m_alias_table	chain.h	/^  CFGIndex       m_alias_table;$/;"	m	class:chain_t
m_alias_table	system.h	/^  CFGIndex      m_alias_table;$/;"	m	class:system_t
m_amber_api	system.h	/^  amber_api_t *m_amber_api;$/;"	m	class:system_t
m_arch_bpred	pseq.h	/^  predictor_state_t *m_arch_bpred;$/;"	m	class:pseq_t
m_arf	regbox.h	/^  abstract_rf_t *m_arf;$/;"	m	class:reg_id_t
m_arf	regbox.h	/^  abstract_rf_t *m_arf[RID_NUM_RID_TYPES];$/;"	m	class:reg_box_t
m_asi	flow.h	/^  uint16           m_asi;$/;"	m	class:flow_inst_t
m_asi	memop.h	/^  uint16     m_asi;$/;"	m	class:memory_inst_t
m_asi_at_stat	pseq.h	/^  uint64             m_asi_at_stat[MAX_NUM_ASI];$/;"	m	class:pseq_t
m_asi_is_cacheable	pstate.C	/^char *pstate_t::m_asi_is_cacheable;$/;"	m	class:pstate_t	file:
m_asi_is_cacheable	pstate.h	/^  static char       *m_asi_is_cacheable;$/;"	m	class:pstate_t
m_asi_rd_stat	pseq.h	/^  uint64             m_asi_rd_stat[MAX_NUM_ASI];$/;"	m	class:pseq_t
m_asi_wr_stat	pseq.h	/^  uint64             m_asi_wr_stat[MAX_NUM_ASI];$/;"	m	class:pseq_t
m_assoc	cache.h	/^  uint32 m_assoc;$/;"	m	class:generic_cache_template
m_atomic_fails	lockstat.h	/^  uint32                m_atomic_fails;$/;"	m	class:lock_stat_t
m_atomic_pc	lockstat.h	/^  histogram_t          *m_atomic_pc;$/;"	m	class:lock_stat_t
m_atomic_swap	memop.h	/^  bool        m_atomic_swap;$/;"	m	class:store_inst_t
m_atomics	memstat.h	/^  int32     m_atomics;$/;"	m	class:cache_line_stat_t
m_bit_flips	diagnosis.h	/^	unsigned int m_bit_flips;$/;"	m	class:diagnosis_t
m_bits	regmap.h	/^  bitfield_t     *m_bits;$/;"	m	class:reg_map_t
m_block_bits	mshr.h	/^  word_t           m_block_bits;$/;"	m	class:mshr_t
m_block_mask	mshr.h	/^  pa_t             m_block_mask;$/;"	m	class:mshr_t
m_block_mask	rubycache.h	/^  pa_t           m_block_mask;$/;"	m	class:rubycache_t
m_block_size	rubycache.h	/^  uint32         m_block_size;$/;"	m	class:rubycache_t
m_bpred	pseq.h	/^  direct_predictor_t   *m_bpred;$/;"	m	class:pseq_t
m_branch_except_stat	pseq.h	/^  uint64             m_branch_except_stat[BRANCH_NUM_BRANCH_TYPES];$/;"	m	class:pseq_t
m_branch_pred_stat	pseq.h	/^  uint64             m_branch_pred_stat[BRANCH_NUM_BRANCH_TYPES][TOTAL_INSTR_MODE];$/;"	m	class:pseq_t
m_branch_right_stat	pseq.h	/^  uint64             m_branch_right_stat[BRANCH_NUM_BRANCH_TYPES][TOTAL_INSTR_MODE];$/;"	m	class:pseq_t
m_branch_seen_stat	pseq.h	/^  uint64             m_branch_seen_stat[BRANCH_NUM_BRANCH_TYPES][TOTAL_INSTR_MODE];$/;"	m	class:pseq_t
m_branch_trace	pseq.h	/^  branchfile_t   *m_branch_trace;$/;"	m	class:pseq_t
m_branch_type	statici.h	/^  byte_t    m_branch_type;$/;"	m	class:static_inst_t
m_branch_wrong_stat	pseq.h	/^  uint64             m_branch_wrong_stat[BRANCH_NUM_BRANCH_TYPES][TOTAL_INSTR_MODE];$/;"	m	class:pseq_t
m_branch_wrong_static_stat	pseq.h	/^  uint64             m_branch_wrong_static_stat;$/;"	m	class:pseq_t
m_breakpoint_table	system.h	/^  BreakpointTable *m_breakpoint_table;$/;"	m	class:system_t
m_bus_cycles	mshr.h	/^  word_t           m_bus_cycles;$/;"	m	class:mshr_t
m_bus_next_free	mshr.h	/^  tick_t  m_bus_next_free;$/;"	m	class:mshr_t
m_bytes_written	memstat.h	/^  uint64    m_bytes_written;$/;"	m	class:cache_line_stat_t
m_cache_fetch_from	mshr.h	/^  generic_cache_template<generic_cache_block_t> *m_cache_fetch_from;$/;"	m	class:mshr_t
m_cache_line_mask	memstat.h	/^  pa_t               m_cache_line_mask;$/;"	m	class:mem_stat_t
m_cache_to_fill	mshr.h	/^  cache_t        *m_cache_to_fill;$/;"	m	class:miss_t
m_cc_retire_map	pseq.h	/^  reg_map_t       *m_cc_retire_map;$/;"	m	class:pseq_t
m_cc_rf	pseq.h	/^  physical_file_t *m_cc_rf;$/;"	m	class:pseq_t
m_ccshift	statici.h	/^  byte_t    m_ccshift;$/;"	m	class:static_inst_t
m_cfg_index	pseq.h	/^  CFGIndex            m_cfg_index;$/;"	m	class:pseq_t
m_cfg_pred	pseq.h	/^  flow_inst_t        *m_cfg_pred;$/;"	m	class:pseq_t
m_chain	system.h	/^  chain_t     **m_chain;$/;"	m	class:system_t
m_check	pseq.h	/^  mstate_t            m_check;$/;"	m	class:pseq_t
m_check_at_retire	memop.h	/^  bool m_check_at_retire;$/;"	m	class:memory_inst_t
m_check_at_retire_value	memop.h	/^  uint64 m_check_at_retire_value;$/;"	m	class:memory_inst_t
m_chkpt_interval	pstate.h	/^  int m_chkpt_interval ;$/;"	m	class:pstate_t
m_coherence_state	memstat.h	/^  stat_coherence_state_t m_coherence_state;$/;"	m	class:cache_line_stat_t
m_complete_cycle	dynamic.h	/^  tick_t         m_complete_cycle;$/;"	m	class:dynamic_inst_t
m_conf	pseq.h	/^  confio_t     *m_conf;$/;"	m	class:pseq_t
m_conf_mmu	pstate.h	/^  conf_object_t     *m_conf_mmu;$/;"	m	class:pstate_t
m_configFile	system.h	/^  const char   *m_configFile;$/;"	m	class:system_t
m_constant_pred	chain.h	/^  flow_inst_t   *m_constant_pred;$/;"	m	class:chain_t
m_consumable_mem_count	chain.h	/^  uint64         m_consumable_mem_count;$/;"	m	class:chain_t
m_contended	lockstat.h	/^  uint32                m_contended;$/;"	m	class:lock_stat_t
m_context	dtlb.h	/^  context_id_t       m_context;$/;"	m	class:dtlb_entry_t
m_control_arf	pseq.h	/^  arf_control_t    *m_control_arf;$/;"	m	class:pseq_t
m_control_fault	dynamic.h	/^  bool m_control_fault;$/;"	m	class:dynamic_inst_t
m_control_flow_depth	chain.h	/^  int64          m_control_flow_depth;$/;"	m	class:chain_t
m_control_map	pstate.h	/^  int32             *m_control_map;$/;"	m	class:pstate_t
m_control_map	regbox.C	/^byte_t     **reg_box_t::m_control_map;$/;"	m	class:reg_box_t	file:
m_control_map	regbox.h	/^  static byte_t     **m_control_map;$/;"	m	class:reg_box_t
m_control_rf	pseq.h	/^  physical_file_t **m_control_rf;$/;"	m	class:pseq_t
m_control_size	regbox.C	/^byte_t      *reg_box_t::m_control_size;$/;"	m	class:reg_box_t	file:
m_control_size	regbox.h	/^  static byte_t      *m_control_size;$/;"	m	class:reg_box_t
m_count	dtlb.h	/^  uint32          m_count;$/;"	m	class:dtlb_t
m_count	pipepool.h	/^  uint32       m_count;$/;"	m	class:pipepool_t
m_count_execute	sstat.h	/^  uint64    m_count_execute;$/;"	m	class:static_stat_t
m_count_mispredict	sstat.h	/^  uint32    m_count_mispredict;$/;"	m	class:static_stat_t
m_count_mispredict_inf	sstat.h	/^  uint32    m_count_mispredict_inf;$/;"	m	class:static_stat_t
m_count_static_mispredict	sstat.h	/^  uint32    m_count_static_mispredict;$/;"	m	class:static_stat_t
m_count_taken	sstat.h	/^  uint64    m_count_taken;$/;"	m	class:static_stat_t
m_cpu	pstate.h	/^  conf_object_t     *m_cpu;$/;"	m	class:pstate_t
m_cpu_transfer	lockstat.h	/^  uint32                m_cpu_transfer;$/;"	m	class:lock_stat_t
m_cpuid	stopwatch.h	/^  int    m_cpuid;$/;"	m	class:stopwatch_t
m_cpuid	threadstat.h	/^  int32      m_cpuid;$/;"	m	class:thread_stat_t
m_cur_element	arf.h	/^  int32            m_cur_element;$/;"	m	class:arf_container_t
m_cur_element	flatarf.h	/^  int32            m_cur_element;$/;"	m	class:flat_container_t
m_cur_type	arf.h	/^  rid_container_t  m_cur_type;$/;"	m	class:arf_container_t
m_cur_type	flatarf.h	/^  rid_container_t  m_cur_type;$/;"	m	class:flat_container_t
m_current_cycle	scheduler.h	/^  tick_t        m_current_cycle;$/;"	m	class:scheduler_t
m_cycle_start	stopwatch.h	/^  uint64 m_cycle_start;$/;"	m	class:stopwatch_t
m_cycle_wait_list	scheduler.h	/^  FiniteCycle<wait_list_t> m_cycle_wait_list;$/;"	m	class:scheduler_t
m_data_consumer	chain.h	/^  pf_consumer_t  m_data_consumer; $/;"	m	class:chain_t
m_data_storage	flow.h	/^  ireg_t           m_data_storage[MEMOP_MAX_SIZE];$/;"	m	class:flow_inst_t
m_data_storage	memop.h	/^  ireg_t     m_data_storage[MEMOP_MAX_SIZE];$/;"	m	class:memory_inst_t
m_data_valid	flow.h	/^  bool             m_data_valid;$/;"	m	class:flow_inst_t
m_data_valid	memop.h	/^  bool       m_data_valid;$/;"	m	class:memory_inst_t
m_decode_map	arf.h	/^  reg_map_t         *m_decode_map;$/;"	m	class:abstract_rf_t
m_decode_per_cycle	pseq.h	/^  FiniteCycle<uint32> m_decode_per_cycle;$/;"	m	class:pseq_t
m_decode_rf	arf.h	/^  uint32             m_decode_rf;$/;"	m	class:arf_control_t
m_decode_stall_count_stat	pseq.h	/^  uint64             m_decode_stall_count_stat;$/;"	m	class:pseq_t
m_delayed_pool	rubycache.h	/^  pipepool_t    *m_delayed_pool;$/;"	m	class:rubycache_t
m_deleted_misses	chain.h	/^  uint64         m_deleted_misses;$/;"	m	class:chain_t
m_depend	memop.h	/^  store_inst_t *m_depend;$/;"	m	class:atomic_inst_t
m_depend	memop.h	/^  store_inst_t *m_depend;$/;"	m	class:load_inst_t
m_dependent_loads	memop.h	/^  wait_list_t m_dependent_loads;$/;"	m	class:store_inst_t
m_descendent	mshr.h	/^  miss_t         *m_descendent;$/;"	m	class:miss_t
m_dest_ready	dynamic.h	/^  bool m_dest_ready[SI_MAX_DEST];$/;"	m	class:dynamic_inst_t
m_dest_reg	dynamic.h	/^  reg_id_t       m_dest_reg[SI_MAX_DEST];$/;"	m	class:dynamic_inst_t
m_dest_reg	flow.h	/^  reg_id_t         m_dest_reg[SI_MAX_DEST];$/;"	m	class:flow_inst_t
m_dest_reg	statici.h	/^  reg_id_t  m_dest_reg[SI_MAX_DEST];$/;"	m	class:static_inst_t
m_diagnosis	pseq.h	/^  diagnosis_t* m_diagnosis;$/;"	m	class:pseq_t
m_dirty	mshr.h	/^  bool            m_dirty;$/;"	m	class:miss_t
m_dispatch_map	arf.h	/^  reg_id_t    *m_dispatch_map[CONTAINER_NUM_CONTAINER_TYPES];$/;"	m	class:arf_container_t
m_dispatch_map	flatarf.h	/^  reg_id_t    *m_dispatch_map[CONTAINER_NUM_CONTAINER_TYPES];$/;"	m	class:flat_container_t
m_dispatch_size	arf.h	/^  uint32       m_dispatch_size[CONTAINER_NUM_CONTAINER_TYPES];$/;"	m	class:arf_container_t
m_dispatch_size	flatarf.h	/^  uint32       m_dispatch_size[CONTAINER_NUM_CONTAINER_TYPES];$/;"	m	class:flat_container_t
m_element	pipestate.h	/^  waiter_t     *m_element;$/;"	m	class:pipestate_t
m_entry	ipagemap.h	/^  ipage_t       *m_entry;$/;"	m	class:imapentry_t
m_eventQueue	cache.h	/^  scheduler_t *m_eventQueue;$/;"	m	class:cache_t
m_event_queue	mshr.h	/^  scheduler_t     *m_event_queue;$/;"	m	class:mshr_t
m_event_queue	rubycache.h	/^  scheduler_t   *m_event_queue;$/;"	m	class:rubycache_t
m_event_times	dynamic.h	/^  uint16         m_event_times[EVENT_TIME_NUM_EVENT_TIMES];$/;"	m	class:dynamic_inst_t
m_events	dynamic.h	/^  inst_event_t   m_events; $/;"	m	class:dynamic_inst_t
m_events	flow.h	/^  flow_event_t     m_events;$/;"	m	class:flow_inst_t
m_except_access_addr	pseq.h	/^  my_addr_t   m_except_access_addr;$/;"	m	class:pseq_t
m_except_continue_at	pseq.h	/^  abstract_pc_t m_except_continue_at;$/;"	m	class:pseq_t
m_except_count	chain.h	/^  uint64         m_except_count;$/;"	m	class:chain_t
m_except_offender	pseq.h	/^  enum i_opcode m_except_offender;$/;"	m	class:pseq_t	typeref:enum:pseq_t::i_opcode
m_except_penalty	pseq.h	/^  uint32      m_except_penalty;$/;"	m	class:pseq_t
m_except_type	pseq.h	/^  exception_t m_except_type;$/;"	m	class:pseq_t
m_exception_haphandle	system.h	/^  hap_handle_t  m_exception_haphandle;$/;"	m	class:system_t
m_exception_stat	pseq.h	/^  uint64             m_exception_stat[EXCEPT_NUM_EXCEPT_TYPES];$/;"	m	class:pseq_t
m_exclude_count	pseq.h	/^  uint64             m_exclude_count;$/;"	m	class:pseq_t
m_exclude_lock_table	sysstat.h	/^  PerPCLockTable    *m_exclude_lock_table;$/;"	m	class:sys_stat_t
m_exec_per_page	threadstat.h	/^  PhysicalToLogicalMap  m_exec_per_page;$/;"	m	class:thread_stat_t
m_execution_count	threadstat.h	/^  uint64     m_execution_count;$/;"	m	class:thread_stat_t
m_exit_code	statici.h	/^  int       m_exit_code;$/;"	m	class:static_inst_t
m_fastpath_hit	rubycache.h	/^  bool           m_fastpath_hit;$/;"	m	class:rubycache_t
m_fastpath_outstanding	rubycache.h	/^  bool           m_fastpath_outstanding;$/;"	m	class:rubycache_t
m_fastpath_request	rubycache.h	/^  pa_t           m_fastpath_request;$/;"	m	class:rubycache_t
m_faulty_rob	dynamic.h	/^  bool m_faulty_rob;$/;"	m	class:dynamic_inst_t
m_fetch_at	memop.h	/^  abstract_pc_t m_fetch_at;$/;"	m	class:atomic_inst_t
m_fetch_at	memop.h	/^  abstract_pc_t m_fetch_at;$/;"	m	class:load_inst_t
m_fetch_at	pseq.h	/^  abstract_pc_t   *m_fetch_at;$/;"	m	class:pseq_t
m_fetch_cycle	dynamic.h	/^  tick_t         m_fetch_cycle;$/;"	m	class:dynamic_inst_t
m_fetch_id	statici.h	/^  int m_fetch_id;$/;"	m	class:static_inst_t
m_fetch_itlbmiss	pseq.h	/^  static_inst_t   *m_fetch_itlbmiss;$/;"	m	class:pseq_t
m_fetch_per_cycle	pseq.h	/^  FiniteCycle<uint32> m_fetch_per_cycle;$/;"	m	class:pseq_t
m_fetch_ready_cycle	pseq.h	/^  tick_t     m_fetch_ready_cycle;$/;"	m	class:pseq_t
m_fetch_requested_line	pseq.h	/^  pa_t       m_fetch_requested_line;$/;"	m	class:pseq_t
m_fetch_status	pseq.h	/^  pseq_fetch_status_t m_fetch_status;$/;"	m	class:pseq_t
m_filename	ptrace.h	/^  char          *m_filename;$/;"	m	class:ptrace_t
m_flags	ptrace.h	/^  pt_memory_flags_t  m_flags;$/;"	m	class:pt_memory_t
m_flags	statici.h	/^  byte_t    m_flags;$/;"	m	class:static_inst_t
m_fp	ptrace.h	/^  FILE          *m_fp;$/;"	m	class:ptrace_t
m_freelist	regmap.h	/^  uint16         *m_freelist;$/;"	m	class:reg_map_t
m_freelist_index	regmap.h	/^  uint16          m_freelist_index;$/;"	m	class:reg_map_t
m_fs	arf.h	/^  fault_stats *m_fs;$/;"	m	class:abstract_rf_t
m_fs	dynamic.h	/^	fault_stats *m_fs;$/;"	m	class:dynamic_inst_t
m_fs	iwindow.h	/^  fault_stats *m_fs;$/;"	m	class:iwindow_t
m_fs	regfile.h	/^		fault_stats 	*m_fs;$/;"	m	class:physical_file_t
m_futype	statici.h	/^  byte_t    m_futype;$/;"	m	class:static_inst_t
m_fwd_progress_cycle	pseq.h	/^  uint64      m_fwd_progress_cycle;$/;"	m	class:pseq_t
m_global_cycles	system.h	/^  tick_t        m_global_cycles;$/;"	m	class:system_t
m_global_map	regbox.C	/^byte_t     **reg_box_t::m_global_map;$/;"	m	class:reg_box_t	file:
m_global_map	regbox.h	/^  static byte_t     **m_global_map;$/;"	m	class:reg_box_t
m_got_deeper	chain.h	/^  int64          m_got_deeper;$/;"	m	class:chain_t
m_got_shallower	chain.h	/^  int64          m_got_shallower;$/;"	m	class:chain_t
m_has_recovered	diagnosis.h	/^	bool   m_has_recovered;$/;"	m	class:diagnosis_t
m_hash_table	histogram.h	/^  struct hash_ent **m_hash_table;  \/* the array of the hash_table with$/;"	m	class:histogram_t	typeref:struct:histogram_t::hash_ent
m_hashmask	ipagemap.h	/^  uint32   m_hashmask;$/;"	m	class:ipagemap_t
m_head	chain.h	/^  uint32         m_head;$/;"	m	class:chain_t
m_head	mshr.h	/^  Type  *m_head, *m_tail;$/;"	m	class:replacement_manager_t
m_head	pipepool.h	/^  pipestate_t *m_head;$/;"	m	class:pipepool_t
m_header	ipage.h	/^  si_page_header_t  m_header;$/;"	m	class:ipage_t
m_held	lockstat.h	/^  bool                  m_held;$/;"	m	class:lock_stat_t
m_hist_active	mshr.h	/^  uint64   *m_hist_active;$/;"	m	class:mshr_t
m_hist_cpus_overwritten	chain.h	/^  histogram_t   *m_hist_cpus_overwritten;$/;"	m	class:chain_t
m_hist_cpus_read_from	chain.h	/^  histogram_t   *m_hist_cpus_read_from;$/;"	m	class:chain_t
m_hist_decode_per_cycle	pseq.h	/^  uint64            *m_hist_decode_per_cycle;$/;"	m	class:pseq_t
m_hist_decode_return	pseq.h	/^  uint64            *m_hist_decode_return;$/;"	m	class:pseq_t
m_hist_dep_branch_dist	chain.h	/^  histogram_t   *m_hist_dep_branch_dist;$/;"	m	class:chain_t
m_hist_dep_cti_dist	chain.h	/^  histogram_t   *m_hist_dep_cti_dist;$/;"	m	class:chain_t
m_hist_dependent	chain.h	/^  histogram_t   *m_hist_dependent;$/;"	m	class:chain_t
m_hist_dependent_miss	chain.h	/^  histogram_t   *m_hist_dependent_miss;$/;"	m	class:chain_t
m_hist_depth	chain.h	/^  histogram_t   *m_hist_depth;$/;"	m	class:chain_t
m_hist_fetch_per_cycle	pseq.h	/^  uint64            *m_hist_fetch_per_cycle;$/;"	m	class:pseq_t
m_hist_fetch_stalls	pseq.h	/^  uint64            *m_hist_fetch_stalls;$/;"	m	class:pseq_t
m_hist_ff_length	pseq.h	/^  uint64            *m_hist_ff_length;$/;"	m	class:pseq_t
m_hist_ideal_coverage	pseq.h	/^  uint64            *m_hist_ideal_coverage;$/;"	m	class:pseq_t
m_hist_ind_branch_dist	chain.h	/^  histogram_t   *m_hist_ind_branch_dist;$/;"	m	class:chain_t
m_hist_ind_cti_dist	chain.h	/^  histogram_t   *m_hist_ind_cti_dist;$/;"	m	class:chain_t
m_hist_independent	chain.h	/^  histogram_t   *m_hist_independent;$/;"	m	class:chain_t
m_hist_independent_miss	chain.h	/^  histogram_t   *m_hist_independent_miss;$/;"	m	class:chain_t
m_hist_inst_per_misses	chain.h	/^  histogram_t   *m_hist_inst_per_misses;$/;"	m	class:chain_t
m_hist_miss	sstat.h	/^  uint16          m_hist_miss[SI_MISS_COUNT];$/;"	m	class:static_stat_t
m_hist_miss_seen	sstat.h	/^  uint16          m_hist_miss_seen[SI_MISS_COUNT];$/;"	m	class:static_stat_t
m_hist_pc_critical	chain.h	/^  histogram_t   *m_hist_pc_critical;$/;"	m	class:chain_t
m_hist_pc_non_critical	chain.h	/^  histogram_t   *m_hist_pc_non_critical;$/;"	m	class:chain_t
m_hist_retire_per_cycle	pseq.h	/^  uint64            *m_hist_retire_per_cycle;$/;"	m	class:pseq_t
m_hist_retire_stalls	pseq.h	/^  uint64            *m_hist_retire_stalls;$/;"	m	class:pseq_t
m_hist_schedule_per_cycle	pseq.h	/^  uint64            *m_hist_schedule_per_cycle;$/;"	m	class:pseq_t
m_hist_squash_stage	pseq.h	/^  uint64           **m_hist_squash_stage;$/;"	m	class:pseq_t
m_hist_static_miss_count	chain.h	/^  histogram_t   *m_hist_static_miss_count;$/;"	m	class:chain_t
m_hist_static_pred	chain.h	/^  histogram_t   *m_hist_static_pred;$/;"	m	class:chain_t
m_hist_static_succ	chain.h	/^  histogram_t   *m_hist_static_succ;$/;"	m	class:chain_t
m_i_cache_line_queue	pseq.h	/^  FiniteCycle<pa_t>   m_i_cache_line_queue;$/;"	m	class:pseq_t
m_id	chain.h	/^  int            m_id;$/;"	m	class:chain_t
m_id	dependence.h	/^  int       m_id;$/;"	m	class:mem_dependence_t
m_id	pseq.h	/^  int32      m_id;$/;"	m	class:pseq_t
m_id	pstate.h	/^  int                m_id;$/;"	m	class:pstate_t
m_id	rubycache.h	/^  int32          m_id;$/;"	m	class:rubycache_t
m_ideal	cache.h	/^  bool m_ideal;$/;"	m	class:generic_cache_template
m_ideal_control_rf	pseq.h	/^  physical_file_t    *m_ideal_control_rf;$/;"	m	class:pseq_t
m_ideal_first_predictable	pseq.h	/^  int64               m_ideal_first_predictable;$/;"	m	class:pseq_t
m_ideal_last_checked	pseq.h	/^  int64               m_ideal_last_checked;$/;"	m	class:pseq_t
m_ideal_last_freed	pseq.h	/^  int64               m_ideal_last_freed;$/;"	m	class:pseq_t
m_ideal_last_predictable	pseq.h	/^  int64               m_ideal_last_predictable;$/;"	m	class:pseq_t
m_ideal_opstat	pseq.h	/^  decode_stat_t       m_ideal_opstat;$/;"	m	class:pseq_t
m_ideal_retire_count	pseq.h	/^  int64               m_ideal_retire_count;$/;"	m	class:pseq_t
m_ideal_status	pseq.h	/^  pseq_fetch_status_t m_ideal_status;$/;"	m	class:pseq_t
m_imap	chain.h	/^  ipagemap_t    *m_imap;$/;"	m	class:chain_t
m_imap	pseq.h	/^  ipagemap_t   *m_imap;$/;"	m	class:pseq_t
m_imm	statici.h	/^  ireg_t    m_imm;$/;"	m	class:static_inst_t
m_inorder	pseq.h	/^  mstate_t            m_inorder;$/;"	m	class:pseq_t
m_inorder_at	pseq.h	/^  abstract_pc_t   *m_inorder_at;$/;"	m	class:pseq_t
m_inorder_partial_success	pseq.h	/^  uint64   m_inorder_partial_success;$/;"	m	class:pseq_t
m_inst	ptrace.h	/^  uint32    m_inst;$/;"	m	class:pt_inst_t
m_inst	statici.h	/^  uint32    m_inst;$/;"	m	class:static_inst_t
m_inst_consumer	chain.h	/^  pf_consumer_t  m_inst_consumer; $/;"	m	class:chain_t
m_inst_consumer	ptrace.h	/^  pf_consumer_t  m_inst_consumer;$/;"	m	class:ptrace_t
m_inst_count	chain.h	/^  uint64         m_inst_count;$/;"	m	class:chain_t
m_inst_written	ptrace.h	/^  uint64         m_inst_written;$/;"	m	class:ptrace_t
m_instr	ipage.h	/^  static_inst_t    *m_instr[ IPAGE_MAX_INSTR ];$/;"	m	class:ipage_t
m_instr_start	stopwatch.h	/^  uint64 m_instr_start;$/;"	m	class:stopwatch_t
m_instructions_per_miss	chain.h	/^  int64          m_instructions_per_miss;$/;"	m	class:chain_t
m_internal_id	threadstat.h	/^  int32      m_internal_id;$/;"	m	class:thread_stat_t
m_invalid_load_address	chain.h	/^  uint64         m_invalid_load_address;$/;"	m	class:chain_t
m_invalid_store_address	chain.h	/^  uint64         m_invalid_store_address;$/;"	m	class:chain_t
m_io_thread	sysstat.h	/^  thread_stat_t     *m_io_thread;$/;"	m	class:sys_stat_t
m_ipred	pseq.h	/^  cascaded_indirect_t  *m_ipred;$/;"	m	class:pseq_t
m_isTaken	controlop.h	/^  bool              m_isTaken;$/;"	m	class:control_inst_t
m_is_detected	system.h	/^  bool m_is_detected ;$/;"	m	class:system_t
m_is_disk_trace	ptrace.h	/^  bool      m_is_disk_trace;$/;"	m	class:pt_memory_waiter_t
m_is_init	chain.h	/^  bool           m_is_init;$/;"	m	class:chain_t
m_is_init	regbox.C	/^bool         reg_box_t::m_is_init = false;$/;"	m	class:reg_box_t	file:
m_is_init	regbox.h	/^  static bool         m_is_init;$/;"	m	class:reg_box_t
m_is_scheduled	rubycache.h	/^  bool           m_is_scheduled;$/;"	m	class:rubycache_t
m_is_stuck	dynamic.h	/^  bool m_is_stuck;$/;"	m	class:dynamic_inst_t
m_is_taken	flow.h	/^  bool             m_is_taken;$/;"	m	class:flow_inst_t
m_is_unknown_run	system.h	/^  bool m_is_unknown_run;$/;"	m	class:system_t
m_issue_count	actor.h	/^  int32   m_issue_count;$/;"	m	class:act_schedule_t
m_itlb_logical_address	pseq.h	/^  la_t          m_itlb_logical_address;$/;"	m	class:pseq_t
m_itlb_physical_address	pseq.h	/^  pa_t          m_itlb_physical_address;$/;"	m	class:pseq_t
m_iwin	pseq.h	/^  iwindow_t  m_iwin;$/;"	m	class:pseq_t
m_iwin_stall_count_stat	pseq.h	/^  uint64             m_iwin_stall_count_stat;$/;"	m	class:pseq_t
m_jump_table	dynamic.C	/^pmf_dynamicExecute dynamic_inst_t::m_jump_table[i_maxcount];$/;"	m	class:dynamic_inst_t	file:
m_jump_table	dynamic.h	/^  static  pmf_dynamicExecute  m_jump_table[i_maxcount];$/;"	m	class:dynamic_inst_t
m_jump_table	flow.C	/^pmf_flowExecute flow_inst_t::m_jump_table[i_maxcount];$/;"	m	class:flow_inst_t	file:
m_jump_table	flow.h	/^  static  pmf_flowExecute  m_jump_table[i_maxcount];$/;"	m	class:flow_inst_t
m_last_access_satisfied	ptrace.h	/^  pa_t          *m_last_access_satisfied;$/;"	m	class:ptrace_t
m_last_agen_id	pseq.h	/^  int m_last_agen_id ;$/;"	m	class:pseq_t
m_last_analyzed	chain.h	/^  uint64         m_last_analyzed;$/;"	m	class:chain_t
m_last_decoded	iwindow.h	/^  uint32     m_last_decoded;$/;"	m	class:iwindow_t
m_last_fetch_index	mshr.h	/^  word_t    m_last_fetch_index;$/;"	m	class:mshr_t
m_last_fetch_physical_address	pseq.h	/^  pa_t       m_last_fetch_physical_address;$/;"	m	class:pseq_t
m_last_fetched	chain.h	/^  flow_inst_t   *m_last_fetched;$/;"	m	class:chain_t
m_last_fetched	iwindow.h	/^  uint32     m_last_fetched;$/;"	m	class:iwindow_t
m_last_fetches	mshr.h	/^  pa_t      m_last_fetches[LAST_FETCH_SIZE];$/;"	m	class:mshr_t
m_last_line_buffer_address	pseq.h	/^  pa_t       m_last_line_buffer_address;$/;"	m	class:pseq_t
m_last_mismatch_cycle	diagnosis.h	/^	tick_t m_last_mismatch_cycle;$/;"	m	class:diagnosis_t
m_last_mismatch_instr	diagnosis.h	/^	uint64 m_last_mismatch_instr;$/;"	m	class:diagnosis_t
m_last_result_bus_id	pseq.h	/^  int m_last_result_bus_id ;$/;"	m	class:pseq_t
m_last_retired	iwindow.h	/^  uint32     m_last_retired;$/;"	m	class:iwindow_t
m_last_scheduled	iwindow.h	/^  uint32     m_last_scheduled;$/;"	m	class:iwindow_t
m_last_symptom	pseq.h	/^  trap_type_t m_last_symptom;$/;"	m	class:pseq_t
m_last_thread	lockstat.h	/^  la_t                  m_last_thread;$/;"	m	class:lock_stat_t
m_last_touched	lockstat.h	/^  int32                 m_last_touched;$/;"	m	class:lock_stat_t
m_last_transaction_time	threadstat.h	/^  uint64     m_last_transaction_time;$/;"	m	class:thread_stat_t
m_last_writer	arf.h	/^  flow_inst_t      **m_last_writer;$/;"	m	class:abstract_rf_t
m_last_writer	flatarf.h	/^  flow_inst_t      **m_last_writer;$/;"	m	class:flat_rf_t
m_last_writer	memstat.h	/^  int16     m_last_writer;$/;"	m	class:cache_line_stat_t
m_latency	mshr.h	/^  word_t           m_latency;$/;"	m	class:mshr_t
m_length_held	lockstat.h	/^  histogram_t          *m_length_held;$/;"	m	class:lock_stat_t
m_line_buffer_fetch_stall	pseq.h	/^  bool       m_line_buffer_fetch_stall;$/;"	m	class:pseq_t
m_list_tail	scheduler.h	/^  tail_waiter_t m_list_tail;$/;"	m	class:scheduler_t
m_local_cycles	pseq.h	/^  tick_t     m_local_cycles;$/;"	m	class:pseq_t
m_local_icount	pseq.h	/^  uint64     m_local_icount;$/;"	m	class:pseq_t
m_local_inorder_number	pseq.h	/^  uint64     m_local_inorder_number;$/;"	m	class:pseq_t
m_local_sequence_number	pseq.h	/^  uint64     m_local_sequence_number;$/;"	m	class:pseq_t
m_logical_address	threadstat.h	/^  uint64     m_logical_address;$/;"	m	class:thread_stat_t
m_logical_reg	regmap.h	/^  uint16         *m_logical_reg;$/;"	m	class:reg_map_t
m_logical_rename_count	regmap.h	/^  uint16         *m_logical_rename_count;$/;"	m	class:reg_map_t
m_lsq	pseq.h	/^  lsq_t       *m_lsq;$/;"	m	class:pseq_t
m_magic_call_hap	system.h	/^  hap_handle_t  m_magic_call_hap;$/;"	m	class:system_t
m_marked_counted	chain.h	/^  uint64         m_marked_counted;$/;"	m	class:chain_t
m_max_branch_count	chain.h	/^  uint32         m_max_branch_count;$/;"	m	class:chain_t
m_max_dispatch_size	flatarf.h	/^  int32            m_max_dispatch_size;$/;"	m	class:flat_container_t
m_max_elements	arf.h	/^  int32            m_max_elements;$/;"	m	class:arf_container_t
m_max_elements	flatarf.h	/^  int32            m_max_elements;$/;"	m	class:flat_container_t
m_max_hist_depth	chain.h	/^  histogram_t   *m_max_hist_depth;$/;"	m	class:chain_t
m_max_memory_depth	chain.h	/^  int64          m_max_memory_depth;$/;"	m	class:chain_t
m_max_misses	mshr.h	/^  word_t           m_max_misses;$/;"	m	class:mshr_t
m_max_predecessors	sstat.h	/^  bool            m_max_predecessors;$/;"	m	class:static_stat_t
m_max_successors	sstat.h	/^  bool            m_max_successors;$/;"	m	class:static_stat_t
m_mem_consumer	ptrace.h	/^  pf_consumer_t  m_mem_consumer;$/;"	m	class:ptrace_t
m_mem_count	chain.h	/^  uint64         m_mem_count;$/;"	m	class:chain_t
m_mem_dep	chain.h	/^  mem_dependence_t *m_mem_dep;$/;"	m	class:chain_t
m_mem_deps	pseq.h	/^  mem_dependence_t   *m_mem_deps;$/;"	m	class:pseq_t
m_mem_depth	flow.h	/^  int32            m_mem_depth;$/;"	m	class:flow_inst_t
m_mem_miss_count	chain.h	/^  uint64         m_mem_miss_count;$/;"	m	class:chain_t
m_mem_stat	sysstat.h	/^  mem_stat_t        *m_mem_stat;$/;"	m	class:sys_stat_t
m_mem_trace	pseq.h	/^  vector<mem_rec_t> m_mem_trace;$/;"	m	class:pseq_t
m_mem_unusual_miss_count	chain.h	/^  uint64         m_mem_unusual_miss_count;$/;"	m	class:chain_t
m_mem_written	ptrace.h	/^  uint64         m_mem_written;$/;"	m	class:ptrace_t
m_memory_depth	chain.h	/^  int64          m_memory_depth;$/;"	m	class:chain_t
m_memtracefp	pseq.h	/^  memtrace_t     *m_memtracefp;$/;"	m	class:pseq_t
m_mhinstalled	system.h	/^  bool          m_mhinstalled;$/;"	m	class:system_t
m_migrations	threadstat.h	/^  int32      m_migrations;$/;"	m	class:thread_stat_t
m_mismatch_cycle	diagnosis.h	/^	tick_t m_mismatch_cycle;$/;"	m	class:diagnosis_t
m_mismatch_instr	diagnosis.h	/^	uint64 m_mismatch_instr;$/;"	m	class:diagnosis_t
m_miss_count	sstat.h	/^  uint32          m_miss_count;$/;"	m	class:static_stat_t
m_miss_critical_count	sstat.h	/^  uint32          m_miss_critical_count;$/;"	m	class:static_stat_t
m_miss_hash	mshr.h	/^  miss_t   *m_miss_hash[MSHR_HASH_SIZE];$/;"	m	class:mshr_t
m_miss_state	mshr.h	/^  miss_state_t    m_miss_state;$/;"	m	class:miss_t
m_misses	mshr.h	/^  miss_t          *m_misses;$/;"	m	class:mshr_t
m_misses	mshr.h	/^  miss_t  *m_misses[STREAM_BUFFER_SIZE];$/;"	m	class:stream_t
m_mmu_access	pseq.h	/^  mmu_interface_t *m_mmu_access;$/;"	m	class:pseq_t
m_mmu_asi	pseq.h	/^  mmu_interface_t *m_mmu_asi;$/;"	m	class:pseq_t
m_mmu_haphandle	pseq.h	/^  hap_handle_t  m_mmu_haphandle;$/;"	m	class:pseq_t
m_mmu_object	pseq.h	/^  conf_object_t * m_mmu_object;$/;"	m	class:pseq_t
m_mode	ptrace.h	/^  ptrace_mode_t  m_mode;$/;"	m	class:ptrace_t
m_most_recent_fetch	chain.h	/^  pa_t  m_most_recent_fetch;$/;"	m	class:chain_t
m_mshr	mshr.h	/^  mshr_t         *m_mshr;$/;"	m	class:miss_t
m_mshr	mshr.h	/^  mshr_t  *m_mshr;$/;"	m	class:stream_t
m_mshr	pseq.h	/^  mshr_t    *m_mshr;$/;"	m	class:pseq_t
m_mshr_count	rubycache.h	/^  uint32         m_mshr_count;$/;"	m	class:rubycache_t
m_multicore_diagnosis	pseq.h	/^  multicore_diagnosis_t* m_multicore_diagnosis;$/;"	m	class:pseq_t
m_multicore_diagnosis	pstate.h	/^	multicore_diagnosis_t * m_multicore_diagnosis;$/;"	m	class:pstate_t
m_multicore_diagnosis	system.h	/^  multicore_diagnosis_t* m_multicore_diagnosis;$/;"	m	class:system_t
m_myalloc	controlop.C	/^listalloc_t control_inst_t::m_myalloc;$/;"	m	class:control_inst_t	file:
m_myalloc	controlop.h	/^  static listalloc_t m_myalloc;$/;"	m	class:control_inst_t
m_myalloc	dynamic.C	/^listalloc_t dynamic_inst_t::m_myalloc;$/;"	m	class:dynamic_inst_t	file:
m_myalloc	dynamic.h	/^  static listalloc_t m_myalloc;$/;"	m	class:dynamic_inst_t
m_myalloc	flow.C	/^listalloc_t     flow_inst_t::m_myalloc;$/;"	m	class:flow_inst_t	file:
m_myalloc	flow.h	/^  static listalloc_t m_myalloc;$/;"	m	class:flow_inst_t
m_myalloc	memop.C	/^listalloc_t atomic_inst_t::m_myalloc;$/;"	m	class:atomic_inst_t	file:
m_myalloc	memop.C	/^listalloc_t load_inst_t::m_myalloc;$/;"	m	class:load_inst_t	file:
m_myalloc	memop.C	/^listalloc_t prefetch_inst_t::m_myalloc;$/;"	m	class:prefetch_inst_t	file:
m_myalloc	memop.C	/^listalloc_t store_inst_t::m_myalloc;$/;"	m	class:store_inst_t	file:
m_myalloc	memop.h	/^  static listalloc_t m_myalloc;$/;"	m	class:atomic_inst_t
m_myalloc	memop.h	/^  static listalloc_t m_myalloc;$/;"	m	class:load_inst_t
m_myalloc	memop.h	/^  static listalloc_t m_myalloc;$/;"	m	class:prefetch_inst_t
m_myalloc	memop.h	/^  static listalloc_t m_myalloc;$/;"	m	class:store_inst_t
m_myalloc	rubycache.C	/^listalloc_t ruby_request_t::m_myalloc;$/;"	m	class:ruby_request_t	file:
m_myalloc	rubycache.h	/^  static listalloc_t m_myalloc;$/;"	m	class:ruby_request_t
m_name	histogram.h	/^  const char* m_name;              \/* name of the this histogram *\/$/;"	m	class:histogram_t
m_name	mshr.h	/^  char             m_name[32];$/;"	m	class:mshr_t
m_next	dtlb.h	/^  dtlb_entry_t      *m_next;$/;"	m	class:dtlb_entry_t
m_next	flow.h	/^  cfg_list_t  *m_next;$/;"	m	class:cfg_list_t
m_next	ipagemap.h	/^  imapentry_t   *m_next;$/;"	m	class:imapentry_t
m_next	pipestate.h	/^  pipestate_t  *m_next;$/;"	m	class:pipestate_t
m_next_exception	pseq.h	/^  uint32      m_next_exception;$/;"	m	class:pseq_t
m_next_line_address	pseq.h	/^  pa_t       m_next_line_address;$/;"	m	class:pseq_t
m_node	flow.h	/^  flow_inst_t *m_node;$/;"	m	class:cfg_list_t
m_non_cpu_ini_count	chain.h	/^  uint64         m_non_cpu_ini_count;$/;"	m	class:chain_t
m_nonpred_count_stat	pseq.h	/^  uint64             m_nonpred_count_stat;$/;"	m	class:pseq_t
m_nonpred_retire_count_stat	pseq.h	/^  uint64             m_nonpred_retire_count_stat;$/;"	m	class:pseq_t
m_not_memory_count	chain.h	/^  uint64         m_not_memory_count;$/;"	m	class:chain_t
m_not_stallable_count	chain.h	/^  uint64         m_not_stallable_count;$/;"	m	class:chain_t
m_null_static	chain.h	/^  static_inst_t *m_null_static;$/;"	m	class:chain_t
m_numProcs	system.h	/^  int           m_numProcs;$/;"	m	class:system_t
m_num_active	mshr.h	/^  uint64    m_num_active;$/;"	m	class:mshr_t
m_num_actual	regfile.h	/^		uint16          m_num_actual;$/;"	m	class:physical_file_t
m_num_cache_not_ready	pseq.h	/^  uint64   m_num_cache_not_ready;$/;"	m	class:pseq_t
m_num_collisions	ipagemap.h	/^  uint32   m_num_collisions;$/;"	m	class:ipagemap_t
m_num_instr	ipagemap.h	/^  uint32   m_num_instr;$/;"	m	class:ipagemap_t
m_num_interrupts	diagnosis.h	/^		int m_num_interrupts;$/;"	m	class:multicore_diagnosis_t
m_num_logical	regmap.h	/^  uint32          m_num_logical;$/;"	m	class:reg_map_t
m_num_pages	dtlb.h	/^  uint32          m_num_pages;$/;"	m	class:dtlb_t
m_num_physical	regfile.h	/^		uint16          m_num_physical;$/;"	m	class:physical_file_t
m_num_physical	regmap.h	/^  uint32          m_num_physical;$/;"	m	class:reg_map_t
m_num_queued	mshr.h	/^  uint64    m_num_queued;$/;"	m	class:mshr_t
m_num_totalpages	ipagemap.h	/^  uint32   m_num_totalpages;$/;"	m	class:ipagemap_t
m_num_unmatched	decode.h	/^  uint64             m_num_unmatched;$/;"	m	class:decode_stat_t
m_old_address	memop.h	/^  my_addr_t  m_old_address;$/;"	m	class:memory_inst_t
m_old_data_storage	memop.h	/^  ireg_t     m_old_data_storage[MEMOP_MAX_SIZE];$/;"	m	class:memory_inst_t
m_old_data_valid	memop.h	/^  bool       m_old_data_valid;$/;"	m	class:memory_inst_t
m_old_physical_addr	memop.h	/^  pa_t       m_old_physical_addr;$/;"	m	class:memory_inst_t
m_ooo	pseq.h	/^  mstate_t         m_ooo;$/;"	m	class:pseq_t
m_op_functional	decode.h	/^  uint64            *m_op_functional;$/;"	m	class:decode_stat_t
m_op_max_execute	decode.h	/^  uint64            *m_op_max_execute;$/;"	m	class:decode_stat_t
m_op_memory_counter	decode.h	/^  uint64            *m_op_memory_counter;$/;"	m	class:decode_stat_t
m_op_memory_latency	decode.h	/^  uint64            *m_op_memory_latency;$/;"	m	class:decode_stat_t
m_op_min_execute	decode.h	/^  uint64            *m_op_min_execute;$/;"	m	class:decode_stat_t
m_op_mode	pseq.h	/^  operation_mode_t m_op_mode;$/;"	m	class:pseq_t
m_op_noncompliant	decode.h	/^  uint64            *m_op_noncompliant;$/;"	m	class:decode_stat_t
m_op_seen	decode.h	/^  uint64            *m_op_seen;$/;"	m	class:decode_stat_t
m_op_squash	decode.h	/^  uint64            *m_op_squash;$/;"	m	class:decode_stat_t
m_op_succ	decode.h	/^  uint64            *m_op_succ;$/;"	m	class:decode_stat_t
m_op_total_execute	decode.h	/^  uint64            *m_op_total_execute;$/;"	m	class:decode_stat_t
m_opal_api	system.h	/^  mf_opal_api_t *m_opal_api;$/;"	m	class:system_t
m_opcode	statici.h	/^  half_t    m_opcode;$/;"	m	class:static_inst_t
m_opstat	pseq.h	/^  decode_stat_t      m_opstat;$/;"	m	class:pseq_t
m_orig_dest_reg	dynamic.h	/^  reg_id_t       m_orig_dest_reg[SI_MAX_DEST];$/;"	m	class:dynamic_inst_t
m_outstanding	mshr.h	/^  word_t   m_outstanding;$/;"	m	class:stream_t
m_overall_timer	chain.h	/^  utimer_t       m_overall_timer;$/;"	m	class:chain_t
m_overall_timer	pseq.h	/^  stopwatch_t       *m_overall_timer;$/;"	m	class:pseq_t
m_overlap_loads	memop.h	/^  wait_list_t m_overlap_loads;$/;"	m	class:store_inst_t
m_ownership_changes	memstat.h	/^  int32     m_ownership_changes;$/;"	m	class:cache_line_stat_t
m_p2l_map	threadstat.h	/^  PhysicalToLogicalMap  m_p2l_map;$/;"	m	class:thread_stat_t
m_page_mask	dtlb.h	/^  uint64         *m_page_mask;$/;"	m	class:dtlb_t
m_page_size	dtlb.h	/^  uint32         *m_page_size;$/;"	m	class:dtlb_t
m_pagesize	dtlb.h	/^  uint32             m_pagesize;$/;"	m	class:dtlb_entry_t
m_partial_prefetches	mshr.h	/^  uint64    m_partial_prefetches;$/;"	m	class:mshr_t
m_pc_lock_table	sysstat.h	/^  PerPCLockTable    *m_pc_lock_table;$/;"	m	class:sys_stat_t
m_physical	regbox.h	/^  half_t         m_physical;$/;"	m	class:reg_id_t
m_physical	regmap.h	/^  physical_file_t *m_physical;$/;"	m	class:reg_map_t
m_physical_addr	flow.h	/^  pa_t             m_physical_addr;$/;"	m	class:flow_inst_t
m_physical_addr	memop.h	/^  pa_t       m_physical_addr;$/;"	m	class:memory_inst_t
m_physical_addr	ptrace.h	/^  uint64    m_physical_addr;$/;"	m	class:pt_inst_t
m_physical_addr	ptrace.h	/^  uint64    m_physical_addr;$/;"	m	class:pt_memory_t
m_physical_addr	statici.h	/^  pa_t      m_physical_addr;$/;"	m	struct:si_page_header
m_physical_address	lockstat.h	/^  pa_t                  m_physical_address;$/;"	m	class:lock_stat_t
m_physical_address	rubycache.h	/^  pa_t        m_physical_address;$/;"	m	class:ruby_request_t
m_physical_pc	sstat.h	/^  uint64          m_physical_pc;$/;"	m	class:static_stat_t
m_pid	ptrace.h	/^  uint8     m_pid;$/;"	m	class:pt_inst_t
m_pid	ptrace.h	/^  uint8     m_pid;$/;"	m	class:pt_memory_t
m_pid	threadstat.h	/^  int32      m_pid;$/;"	m	class:thread_stat_t
m_positive_stride	mshr.h	/^  bool     m_positive_stride;$/;"	m	class:stream_t
m_post_time	rubycache.h	/^  uint64      m_post_time;$/;"	m	class:ruby_request_t
m_posted_interrupt	pseq.h	/^  trap_type_t m_posted_interrupt;$/;"	m	class:pseq_t
m_pred	flow.h	/^  cfg_list_t       m_pred;$/;"	m	class:flow_inst_t
m_pred_count	sstat.h	/^  uint32          m_pred_count[SI_MAX_SUCCESSORS];$/;"	m	class:static_stat_t
m_pred_count_nottaken_stat	pseq.h	/^  uint64             m_pred_count_nottaken_stat;$/;"	m	class:pseq_t
m_pred_count_stat	pseq.h	/^  uint64             m_pred_count_stat;$/;"	m	class:pseq_t
m_pred_count_taken_stat	pseq.h	/^  uint64             m_pred_count_taken_stat;$/;"	m	class:pseq_t
m_pred_reg_count_stat	pseq.h	/^  uint64             m_pred_reg_count_stat;$/;"	m	class:pseq_t
m_pred_reg_nottaken_stat	pseq.h	/^  uint64             m_pred_reg_nottaken_stat;$/;"	m	class:pseq_t
m_pred_reg_retire_count_stat	pseq.h	/^  uint64             m_pred_reg_retire_count_stat;$/;"	m	class:pseq_t
m_pred_reg_retire_nottaken_stat	pseq.h	/^  uint64             m_pred_reg_retire_nottaken_stat;$/;"	m	class:pseq_t
m_pred_reg_retire_taken_stat	pseq.h	/^  uint64             m_pred_reg_retire_taken_stat;$/;"	m	class:pseq_t
m_pred_reg_taken_stat	pseq.h	/^  uint64             m_pred_reg_taken_stat;$/;"	m	class:pseq_t
m_pred_retire_count_nottaken_stat	pseq.h	/^  uint64             m_pred_retire_count_nottaken_stat;$/;"	m	class:pseq_t
m_pred_retire_count_stat	pseq.h	/^  uint64             m_pred_retire_count_stat;$/;"	m	class:pseq_t
m_pred_retire_count_taken_stat	pseq.h	/^  uint64             m_pred_retire_count_taken_stat;$/;"	m	class:pseq_t
m_pred_state	controlop.h	/^  predictor_state_t m_pred_state;$/;"	m	class:control_inst_t
m_predecessors	sstat.h	/^  static_inst_t  *m_predecessors[SI_MAX_PREDECESSORS];$/;"	m	class:static_stat_t
m_predicted	controlop.h	/^  abstract_pc_t     m_predicted;$/;"	m	class:control_inst_t
m_predicted_storage	memop.h	/^  ireg_t        m_predicted_storage[MEMOP_MAX_SIZE];$/;"	m	class:load_inst_t
m_prefetch_addr	mshr.h	/^  pa_t     m_prefetch_addr;$/;"	m	class:stream_t
m_prefetch_hits	mshr.h	/^  uint64    m_prefetch_hits;$/;"	m	class:mshr_t
m_prefetch_prefetch	mshr.h	/^  uint64    m_prefetch_prefetch;$/;"	m	class:mshr_t
m_prev	pipestate.h	/^  pipestate_t  *m_prev;$/;"	m	class:pipestate_t
m_primary	mshr.h	/^  uint64    m_primary;$/;"	m	class:mshr_t
m_primary_ctx	pseq.h	/^  context_id_t     m_primary_ctx;$/;"	m	class:pseq_t
m_priority	mshr.h	/^  mshr_priority_t m_priority;$/;"	m	class:miss_t
m_priv	dynamic.h	/^  bool           m_priv;$/;"	m	class:dynamic_inst_t
m_priv	rubycache.h	/^  bool        m_priv;$/;"	m	class:ruby_request_t
m_producer_consumer	memstat.h	/^  int32            **m_producer_consumer;$/;"	m	class:mem_stat_t
m_pseq	chain.h	/^  pseq_t        *m_pseq;$/;"	m	class:chain_t
m_pseq	dynamic.h	/^  pseq_t        *m_pseq;$/;"	m	class:dynamic_inst_t
m_pseq	fault.h	/^		pseq_t *m_pseq ;	\/\/ Main processor$/;"	m	class:Fault
m_pseq	flow.h	/^  pseq_t          *m_pseq;$/;"	m	class:flow_inst_t
m_pseq	lsq.h	/^  pseq_t        *m_pseq;$/;"	m	class:lsq_t
m_pseq	regfile.h	/^		pseq_t         *m_pseq;$/;"	m	class:physical_file_t
m_pseq	scheduler.h	/^  pseq_t       *m_pseq;$/;"	m	class:scheduler_t
m_pstate	chain.h	/^  pstate_t      *m_pstate;$/;"	m	class:chain_t
m_pstate	memop.h	/^  uint16     m_pstate;$/;"	m	class:memory_inst_t
m_queue	lsq.h	/^  memory_inst_t *m_queue[LSQ_HASH_SIZE];$/;"	m	class:lsq_t
m_queue_head	scheduler.h	/^  event_t      *m_queue_head;$/;"	m	class:scheduler_t
m_queue_size	actor.h	/^  int32       m_queue_size;$/;"	m	class:actor_t
m_queue_tail	scheduler.h	/^  event_t      *m_queue_tail;$/;"	m	class:scheduler_t
m_ras	pseq.h	/^  ras_t     *m_ras;$/;"	m	class:pseq_t
m_reads	memstat.h	/^  int32     m_reads;$/;"	m	class:cache_line_stat_t
m_recent_retire_index	pseq.h	/^  int32      m_recent_retire_index;$/;"	m	class:pseq_t
m_recent_retire_instr	pseq.h	/^  dynamic_inst_t **m_recent_retire_instr;$/;"	m	class:pseq_t
m_record_type	ptrace.h	/^  uint8    m_record_type;$/;"	m	class:pt_record_t
m_recorded_mismatch	diagnosis.h	/^	bool   m_recorded_mismatch;$/;"	m	class:diagnosis_t
m_recovery_cycle	diagnosis.h	/^	tick_t m_recovery_cycle;$/;"	m	class:diagnosis_t
m_recovery_instr	diagnosis.h	/^	uint64 m_recovery_instr;$/;"	m	class:diagnosis_t
m_ref_count	flow.h	/^  int16            m_ref_count;$/;"	m	class:flow_inst_t
m_ref_count	statici.h	/^  int16     m_ref_count;$/;"	m	class:static_inst_t
m_reg	regfile.h	/^		physical_reg_t *m_reg;$/;"	m	class:physical_file_t
m_reg_stall_count_stat	pseq.h	/^  uint64             m_reg_stall_count_stat;$/;"	m	class:pseq_t
m_reg_use	pseq.h	/^  uint32           **m_reg_use[RID_NUM_RID_TYPES];$/;"	m	class:pseq_t
m_reissue_count	chain.h	/^  uint64         m_reissue_count;$/;"	m	class:chain_t
m_releases	lockstat.h	/^  uint32                m_releases;$/;"	m	class:lock_stat_t
m_rename_index	arf.h	/^  int32        m_rename_index[CONTAINER_NUM_CONTAINER_TYPES];$/;"	m	class:arf_container_t
m_rename_map	arf.h	/^  reg_id_t   **m_rename_map[CONTAINER_NUM_CONTAINER_TYPES];$/;"	m	class:arf_container_t
m_repeated_accesses	chain.h	/^  uint64         m_repeated_accesses;$/;"	m	class:chain_t
m_repeated_misses	chain.h	/^  uint64         m_repeated_misses;$/;"	m	class:chain_t
m_report_interrupt_to_diagnosis	pseq.h	/^  bool m_report_interrupt_to_diagnosis;$/;"	m	class:pseq_t
m_request_pool	rubycache.h	/^  pipepool_t    *m_request_pool;$/;"	m	class:rubycache_t
m_request_type	rubycache.h	/^  OpalMemop_t m_request_type;$/;"	m	class:ruby_request_t
m_reserves	arf.h	/^  uint32             m_reserves;$/;"	m	class:abstract_rf_t
m_result_bus_id	dynamic.h	/^  int m_result_bus_id ;$/;"	m	class:dynamic_inst_t
m_retire_map	arf.h	/^  reg_map_t         *m_retire_map;$/;"	m	class:abstract_rf_t
m_retire_rf	arf.h	/^  uint32             m_retire_rf;$/;"	m	class:arf_control_t
m_retirement_timer	pseq.h	/^  utimer_t           m_retirement_timer;$/;"	m	class:pseq_t
m_rf	arf.h	/^  physical_file_t   *m_rf;$/;"	m	class:abstract_rf_t
m_rf_array	arf.h	/^  physical_file_t  **m_rf_array;$/;"	m	class:arf_control_t
m_rf_count	arf.h	/^  uint32             m_rf_count;$/;"	m	class:arf_control_t
m_rob_size	iwindow.h	/^  uint32    m_rob_size;$/;"	m	class:iwindow_t
m_rtype	regbox.h	/^  char           m_rtype;$/;"	m	class:reg_id_t
m_ruby_api	system.h	/^  mf_ruby_api_t *m_ruby_api;$/;"	m	class:system_t
m_ruby_cache	pseq.h	/^  rubycache_t *m_ruby_cache;$/;"	m	class:pseq_t
m_schedule_stall_count_stat	pseq.h	/^  uint64             m_schedule_stall_count_stat;$/;"	m	class:pseq_t
m_scheduler	pseq.h	/^  scheduler_t     *m_scheduler;$/;"	m	class:pseq_t
m_secondary	mshr.h	/^  uint64    m_secondary;$/;"	m	class:mshr_t
m_seq	actor.h	/^  pseq_t     *m_seq;$/;"	m	class:actor_t
m_seq	system.h	/^  pseq_t      **m_seq;$/;"	m	class:system_t
m_sequence_id	flow.h	/^  uint64           m_sequence_id;$/;"	m	class:flow_inst_t
m_shadow_pstate	pseq.h	/^  uint16     m_shadow_pstate;$/;"	m	class:pseq_t
m_sharer_mask	memstat.h	/^  uint64    m_sharer_mask;$/;"	m	class:cache_line_stat_t
m_sim_message_buffer	system.h	/^  char          m_sim_message_buffer[256];$/;"	m	class:system_t
m_sim_status	system.h	/^  sim_status_t  m_sim_status;$/;"	m	class:system_t
m_simics_time	pseq.h	/^  pc_step_t  m_simics_time;$/;"	m	class:pseq_t
m_simtrapstat	pseq.h	/^  uint64             m_simtrapstat[TRAP_NUM_TRAP_TYPES];$/;"	m	class:pseq_t
m_simulation_timer	pseq.h	/^  utimer_t           m_simulation_timer;$/;"	m	class:pseq_t
m_size	arf.h	/^  uint32           m_size;$/;"	m	class:arf_container_t
m_size	dtlb.h	/^  uint32          m_size;$/;"	m	class:dtlb_t
m_size	histogram.h	/^  int m_size;                      \/* length of the hash_table, it is$/;"	m	class:histogram_t
m_size	mshr.h	/^  uint32 m_size;$/;"	m	class:replacement_manager_t
m_size	ptrace.h	/^  uint8     m_size;$/;"	m	class:pt_memory_t
m_sizemask	histogram.h	/^  int m_sizemask;                  \/* mask derived from the size *\/$/;"	m	class:histogram_t
m_snoop_installed	system.h	/^  bool          m_snoop_installed;$/;"	m	class:system_t
m_source_reg	dynamic.h	/^  reg_id_t       m_source_reg[SI_MAX_SOURCE];$/;"	m	class:dynamic_inst_t
m_source_reg	flow.h	/^  reg_id_t         m_source_reg[SI_MAX_SOURCE];$/;"	m	class:flow_inst_t
m_source_reg	statici.h	/^  reg_id_t  m_source_reg[SI_MAX_SOURCE];$/;"	m	class:static_inst_t
m_sparc_intf	pstate.h	/^  sparc_v9_interface_t *m_sparc_intf;$/;"	m	class:pstate_t
m_spec_bpred	pseq.h	/^  predictor_state_t *m_spec_bpred;$/;"	m	class:pseq_t
m_st_ld_forward_count	chain.h	/^  uint64         m_st_ld_forward_count;$/;"	m	class:chain_t
m_stage	dynamic.h	/^  stage_t        m_stage;$/;"	m	class:dynamic_inst_t
m_stage_owner	dynamic.h	/^  actor_t       *m_stage_owner;$/;"	m	class:dynamic_inst_t
m_stall_time	ptrace.h	/^  uint16    m_stall_time;$/;"	m	class:pt_memory_t
m_standalone_tlb	pseq.h	/^  dtlb_t       *m_standalone_tlb;$/;"	m	class:pseq_t
m_start_cycle	ptrace.h	/^  uint64    m_start_cycle;$/;"	m	class:pt_memory_waiter_t
m_start_logging	pseq.h	/^  bool m_start_logging;$/;"	m	class:pseq_t
m_stat_atomics_exec	pseq.h	/^  uint64   m_stat_atomics_exec;$/;"	m	class:pseq_t
m_stat_atomics_retired	pseq.h	/^  uint64   m_stat_atomics_retired;$/;"	m	class:pseq_t
m_stat_bypasses	pseq.h	/^  uint64   m_stat_bypasses;$/;"	m	class:pseq_t
m_stat_commit_bad	pseq.h	/^  uint64   m_stat_commit_bad;$/;"	m	class:pseq_t
m_stat_commit_good	pseq.h	/^  uint64   m_stat_commit_good;$/;"	m	class:pseq_t
m_stat_commit_squash	pseq.h	/^  uint64   m_stat_commit_squash;$/;"	m	class:pseq_t
m_stat_commit_unimplemented	pseq.h	/^  uint64   m_stat_commit_unimplemented;$/;"	m	class:pseq_t
m_stat_committed	pseq.h	/^  uint64   m_stat_committed;$/;"	m	class:pseq_t
m_stat_continue_calls	pseq.h	/^  uint64   m_stat_continue_calls;$/;"	m	class:pseq_t
m_stat_control_exec	pseq.h	/^  uint64   m_stat_control_exec;$/;"	m	class:pseq_t
m_stat_control_retired	pseq.h	/^  uint64   m_stat_control_retired;$/;"	m	class:pseq_t
m_stat_count_asistoresquash	pseq.h	/^  uint64   m_stat_count_asistoresquash;$/;"	m	class:pseq_t
m_stat_count_badretire	pseq.h	/^  uint64             m_stat_count_badretire;$/;"	m	class:pseq_t
m_stat_count_except	pseq.h	/^  uint64   m_stat_count_except;$/;"	m	class:pseq_t
m_stat_count_functionalretire	pseq.h	/^  uint64             m_stat_count_functionalretire;$/;"	m	class:pseq_t
m_stat_count_io_access	pseq.h	/^  uint64   m_stat_count_io_access;$/;"	m	class:pseq_t
m_stat_count_retiresquash	pseq.h	/^  uint64             m_stat_count_retiresquash;$/;"	m	class:pseq_t
m_stat_decoded	pseq.h	/^  uint64   m_stat_decoded;$/;"	m	class:pseq_t
m_stat_early_store_bypass	pseq.h	/^  uint64             m_stat_early_store_bypass;$/;"	m	class:pseq_t
m_stat_exception_count	pseq.h	/^  uint64   m_stat_exception_count;$/;"	m	class:pseq_t
m_stat_fatal_trap_count	pseq.h	/^  uint64   m_stat_fatal_trap_count;$/;"	m	class:pseq_t
m_stat_fetched	pseq.h	/^  uint64   m_stat_fetched;$/;"	m	class:pseq_t
m_stat_fill	pseq.h	/^  uint64   m_stat_fill;$/;"	m	class:pseq_t
m_stat_fu_util_retired	pseq.h	/^  uint64            *m_stat_fu_util_retired;$/;"	m	class:pseq_t
m_stat_fu_utilization	pseq.h	/^  uint64            *m_stat_fu_utilization;$/;"	m	class:pseq_t
m_stat_hist_dep_ops	pseq.h	/^  histogram_t *m_stat_hist_dep_ops;$/;"	m	class:pseq_t
m_stat_hist_effective_dep	pseq.h	/^  histogram_t *m_stat_hist_effective_dep;$/;"	m	class:pseq_t
m_stat_hist_effective_ind	pseq.h	/^  histogram_t *m_stat_hist_effective_ind;$/;"	m	class:pseq_t
m_stat_hist_inter_cluster	pseq.h	/^  histogram_t *m_stat_hist_inter_cluster;$/;"	m	class:pseq_t
m_stat_hist_interarrival	pseq.h	/^  histogram_t *m_stat_hist_interarrival;$/;"	m	class:pseq_t
m_stat_hist_misses	pseq.h	/^  histogram_t *m_stat_hist_misses;$/;"	m	class:pseq_t
m_stat_icache_mshr_hits	pseq.h	/^  uint64   m_stat_icache_mshr_hits;$/;"	m	class:pseq_t
m_stat_last_miss_fetch	pseq.h	/^  tick_t   m_stat_last_miss_fetch;$/;"	m	class:pseq_t
m_stat_last_miss_issue	pseq.h	/^  tick_t   m_stat_last_miss_issue;$/;"	m	class:pseq_t
m_stat_last_miss_retire	pseq.h	/^  tick_t   m_stat_last_miss_retire;$/;"	m	class:pseq_t
m_stat_last_miss_seq	pseq.h	/^  uint64   m_stat_last_miss_seq;$/;"	m	class:pseq_t
m_stat_loads_exec	pseq.h	/^  uint64   m_stat_loads_exec;$/;"	m	class:pseq_t
m_stat_loads_found	pseq.h	/^  uint64   m_stat_loads_found;$/;"	m	class:pseq_t
m_stat_loads_notfound	pseq.h	/^  uint64   m_stat_loads_notfound;$/;"	m	class:pseq_t
m_stat_loads_retired	pseq.h	/^  uint64   m_stat_loads_retired;$/;"	m	class:pseq_t
m_stat_mem_atomics	ptrace.C	/^uint64         ptrace_t::m_stat_mem_atomics;$/;"	m	class:ptrace_t	file:
m_stat_mem_atomics	ptrace.h	/^  static uint64         m_stat_mem_atomics;$/;"	m	class:ptrace_t
m_stat_mem_ignores	ptrace.C	/^uint64         ptrace_t::m_stat_mem_ignores;$/;"	m	class:ptrace_t	file:
m_stat_mem_ignores	ptrace.h	/^  static uint64         m_stat_mem_ignores;$/;"	m	class:ptrace_t
m_stat_mem_ldda	ptrace.C	/^uint64         ptrace_t::m_stat_mem_ldda;$/;"	m	class:ptrace_t	file:
m_stat_mem_ldda	ptrace.h	/^  static uint64         m_stat_mem_ldda;$/;"	m	class:ptrace_t
m_stat_mini_itlb_misses	pseq.h	/^  uint64   m_stat_mini_itlb_misses;$/;"	m	class:pseq_t
m_stat_miss_count	pseq.h	/^  uint64   m_stat_miss_count;$/;"	m	class:pseq_t
m_stat_miss_effective_dep	pseq.h	/^  uint64   m_stat_miss_effective_dep;$/;"	m	class:pseq_t
m_stat_miss_effective_ind	pseq.h	/^  uint64   m_stat_miss_effective_ind;$/;"	m	class:pseq_t
m_stat_miss_inter_cluster	pseq.h	/^  uint64   m_stat_miss_inter_cluster;$/;"	m	class:pseq_t
m_stat_modified_instructions	pseq.h	/^  uint64   m_stat_modified_instructions;$/;"	m	class:pseq_t
m_stat_no_fetch_across_lines	pseq.h	/^  uint64             m_stat_no_fetch_across_lines;$/;"	m	class:pseq_t
m_stat_no_fetch_taken_branch	pseq.h	/^  uint64             m_stat_no_fetch_taken_branch;$/;"	m	class:pseq_t
m_stat_non_cpu_init	ptrace.C	/^uint64         ptrace_t::m_stat_non_cpu_init;$/;"	m	class:ptrace_t	file:
m_stat_non_cpu_init	ptrace.h	/^  static uint64         m_stat_non_cpu_init;$/;"	m	class:ptrace_t
m_stat_non_stallable	ptrace.C	/^uint64         ptrace_t::m_stat_non_stallable;$/;"	m	class:ptrace_t	file:
m_stat_non_stallable	ptrace.h	/^  static uint64         m_stat_non_stallable;$/;"	m	class:ptrace_t
m_stat_num_dcache_miss	pseq.h	/^  uint64   m_stat_num_dcache_miss;$/;"	m	class:pseq_t
m_stat_num_early_atomics	pseq.h	/^  uint64   m_stat_num_early_atomics;$/;"	m	class:pseq_t
m_stat_num_early_store_bypasses	pseq.h	/^  uint64   m_stat_num_early_store_bypasses;$/;"	m	class:pseq_t
m_stat_num_early_stores	pseq.h	/^  uint64   m_stat_num_early_stores;$/;"	m	class:pseq_t
m_stat_num_icache_miss	pseq.h	/^  uint64   m_stat_num_icache_miss;$/;"	m	class:pseq_t
m_stat_prefetches_exec	pseq.h	/^  uint64   m_stat_prefetches_exec;$/;"	m	class:pseq_t
m_stat_prefetches_retired	pseq.h	/^  uint64   m_stat_prefetches_retired;$/;"	m	class:pseq_t
m_stat_repeated_access	ptrace.C	/^uint64         ptrace_t::m_stat_repeated_access;$/;"	m	class:ptrace_t	file:
m_stat_repeated_access	ptrace.h	/^  static uint64         m_stat_repeated_access;$/;"	m	class:ptrace_t
m_stat_retired_dcache_miss	pseq.h	/^  uint64   m_stat_retired_dcache_miss;$/;"	m	class:pseq_t
m_stat_retired_memory_miss	pseq.h	/^  uint64   m_stat_retired_memory_miss;$/;"	m	class:pseq_t
m_stat_retired_mshr_hits	pseq.h	/^  uint64   m_stat_retired_mshr_hits;$/;"	m	class:pseq_t
m_stat_spill	pseq.h	/^  uint64   m_stat_spill;$/;"	m	class:pseq_t
m_stat_stale_histogram	pseq.h	/^  uint64  *m_stat_stale_histogram;$/;"	m	class:pseq_t
m_stat_stale_predictions	pseq.h	/^  uint64   m_stat_stale_predictions;$/;"	m	class:pseq_t
m_stat_stale_success	pseq.h	/^  uint64   m_stat_stale_success;$/;"	m	class:pseq_t
m_stat_stores_exec	pseq.h	/^  uint64   m_stat_stores_exec;$/;"	m	class:pseq_t
m_stat_stores_retired	pseq.h	/^  uint64   m_stat_stores_retired;$/;"	m	class:pseq_t
m_stat_total_insts	pseq.h	/^  uint64   m_stat_total_insts;$/;"	m	class:pseq_t
m_stat_total_squash	pseq.h	/^  uint64   m_stat_total_squash;$/;"	m	class:pseq_t
m_stat_trace_insn	pseq.h	/^  uint64   m_stat_trace_insn;$/;"	m	class:pseq_t
m_stat_trap_count	pseq.h	/^  uint64   m_stat_trap_count;$/;"	m	class:pseq_t
m_state	chain.h	/^  mstate_t       m_state;$/;"	m	class:chain_t
m_state	diagnosis.h	/^		pstate_t **m_state;$/;"	m	class:multicore_diagnosis_t
m_state	pstate.h	/^  core_state_t       m_state[NUM_CHKPTS];$/;"	m	class:pstate_t
m_state	system.h	/^  pstate_t    **m_state;$/;"	m	class:system_t
m_static_inst	flow.h	/^  static_inst_t   *m_static_inst;$/;"	m	class:flow_inst_t
m_stats	statici.h	/^  static_stat_t *m_stats;$/;"	m	class:static_inst_t
m_store_pc	lockstat.h	/^  histogram_t          *m_store_pc;$/;"	m	class:lock_stat_t
m_stream	mshr.h	/^  stream_t       *m_stream;$/;"	m	class:miss_t
m_stream_prefetches	mshr.h	/^  uint64    m_stream_prefetches;$/;"	m	class:mshr_t
m_streams	mshr.h	/^  stream_t        *m_streams;$/;"	m	class:mshr_t
m_succ	flow.h	/^  cfg_list_t       m_succ;$/;"	m	class:flow_inst_t
m_succ_count	sstat.h	/^  uint32          m_succ_count[SI_MAX_SUCCESSORS];$/;"	m	class:static_stat_t
m_successors	sstat.h	/^  static_inst_t  *m_successors[SI_MAX_SUCCESSORS];$/;"	m	class:static_stat_t
m_symtrace	system.h	/^  symtrace_t   *m_symtrace;$/;"	m	class:system_t
m_sys	diagnosis.h	/^		system_t *m_sys;$/;"	m	class:multicore_diagnosis_t
m_sys_stat	system.h	/^  sys_stat_t   *m_sys_stat;$/;"	m	class:system_t
m_table	dtlb.h	/^  AddressTranslationMap *m_table;$/;"	m	class:dtlb_t
m_table	ipagemap.h	/^  imapentry_t  **m_table;$/;"	m	class:ipagemap_t
m_table	memstat.h	/^  AddressStatTable  *m_table;$/;"	m	class:mem_stat_t
m_tablebits	ipagemap.h	/^  uint32   m_tablebits;$/;"	m	class:ipagemap_t
m_tablesize	ipagemap.h	/^  uint32   m_tablesize;$/;"	m	class:ipagemap_t
m_tag	ipagemap.h	/^  pa_t          m_tag;$/;"	m	class:imapentry_t
m_tail	chain.h	/^  uint32         m_tail;$/;"	m	class:chain_t
m_tail	mshr.h	/^  Type  *m_head, *m_tail;$/;"	m	class:replacement_manager_t
m_thread_atomic	memstat.h	/^  uint64    m_thread_atomic;$/;"	m	class:cache_line_stat_t
m_thread_count	pseq.h	/^  uint64             m_thread_count;$/;"	m	class:pseq_t
m_thread_count_idle	pseq.h	/^  uint64             m_thread_count_idle;$/;"	m	class:pseq_t
m_thread_histogram	pseq.h	/^  histogram_t       *m_thread_histogram;$/;"	m	class:pseq_t
m_thread_physical_address	pseq.h	/^  pa_t          m_thread_physical_address;$/;"	m	class:pseq_t
m_thread_read	memstat.h	/^  uint64    m_thread_read;$/;"	m	class:cache_line_stat_t
m_thread_stat_table	sysstat.h	/^  ThreadStatTable   *m_thread_stat_table;$/;"	m	class:sys_stat_t
m_thread_timer	pseq.h	/^  stopwatch_t       *m_thread_timer;$/;"	m	class:pseq_t
m_thread_write	memstat.h	/^  uint64    m_thread_write;$/;"	m	class:cache_line_stat_t
m_timeout_clock	rubycache.h	/^  uint64         m_timeout_clock;$/;"	m	class:rubycache_t
m_timing_interface	system.h	/^  timing_model_interface_t  m_timing_interface;$/;"	m	class:system_t
m_tl	memop.h	/^  uint16     m_tl;$/;"	m	class:memory_inst_t
m_tlbfilename	pseq.h	/^  char m_tlbfilename[256];$/;"	m	class:pseq_t
m_tlstack	pseq.h	/^  tlstack_t *m_tlstack;$/;"	m	class:pseq_t
m_tofree_reg	dynamic.h	/^  reg_id_t       m_tofree_reg[SI_MAX_DEST];$/;"	m	class:dynamic_inst_t
m_total_preds	sstat.h	/^  uint32          m_total_preds;$/;"	m	class:static_stat_t
m_total_succs	sstat.h	/^  uint32          m_total_succs;$/;"	m	class:static_stat_t
m_totalcount	histogram.h	/^  int m_totalcount;                \/* total count of Y entries in the table *\/$/;"	m	class:histogram_t
m_trace	system.h	/^  ptrace_t     *m_trace;$/;"	m	class:system_t
m_trace_address	sysstat.h	/^  la_t               m_trace_address;$/;"	m	class:sys_stat_t
m_trace_phys_address	sysstat.h	/^  pa_t               m_trace_phys_address;$/;"	m	class:sys_stat_t
m_tracefp	pseq.h	/^  tracefile_t    *m_tracefp;$/;"	m	class:pseq_t
m_transactions_completed	threadstat.h	/^  int32      m_transactions_completed;$/;"	m	class:thread_stat_t
m_translation_cache	pstate.h	/^  AddressMapping    *m_translation_cache;$/;"	m	class:pstate_t
m_trapstat	pseq.h	/^  uint64             m_trapstat[TRAP_NUM_TRAP_TYPES];$/;"	m	class:pseq_t
m_traptype	dynamic.h	/^  uint16         m_traptype;$/;"	m	class:dynamic_inst_t
m_traptype	flow.h	/^  uint16           m_traptype;$/;"	m	class:flow_inst_t
m_trigger_recovery	pseq.h	/^  bool m_trigger_recovery;$/;"	m	class:pseq_t
m_type	ptrace.h	/^  uint8     m_type;$/;"	m	class:pt_memory_t
m_type	statici.h	/^  byte_t    m_type;$/;"	m	class:static_inst_t
m_unchecked_instr	pseq.h	/^  dynamic_inst_t **m_unchecked_instr;$/;"	m	class:pseq_t
m_unchecked_retire_top	pseq.h	/^  uint32           m_unchecked_retire_top;$/;"	m	class:pseq_t
m_unchecked_retires	pseq.h	/^  uint32           m_unchecked_retires;$/;"	m	class:pseq_t
m_valid	dtlb.h	/^  bool               m_valid;$/;"	m	class:dtlb_entry_t
m_valid_control_reg	pstate.h	/^  bool              *m_valid_control_reg;$/;"	m	class:pstate_t
m_validate_map	regmap.h	/^  bool           *m_validate_map;$/;"	m	class:reg_map_t
m_value_pred	memop.h	/^  bool          m_value_pred;$/;"	m	class:load_inst_t
m_vanilla	regbox.h	/^  char           m_vanilla;$/;"	m	class:reg_id_t
m_victim_hits	mshr.h	/^  uint64    m_victim_hits;$/;"	m	class:mshr_t
m_virtual_address	dynamic.h	/^  la_t           m_virtual_address;$/;"	m	class:dynamic_inst_t
m_virtual_address	flow.h	/^  la_t             m_virtual_address;$/;"	m	class:flow_inst_t
m_virtual_address	lockstat.h	/^  la_t                  m_virtual_address;$/;"	m	class:lock_stat_t
m_virtual_address	memstat.h	/^  la_t      m_virtual_address;$/;"	m	class:cache_line_stat_t
m_vpc	rubycache.h	/^  la_t        m_vpc;$/;"	m	class:ruby_request_t
m_vstate	regbox.h	/^  char           m_vstate;$/;"	m	class:reg_id_t
m_wait_for_request	pseq.h	/^  bool       m_wait_for_request;$/;"	m	class:pseq_t
m_wait_list	mshr.h	/^  wait_list_t     m_wait_list;  \/* things to wakeup when line is brought in *\/$/;"	m	class:miss_t
m_wait_list	rubycache.h	/^  wait_list_t m_wait_list;$/;"	m	class:ruby_request_t
m_waiter_freelist	ptrace.h	/^  list<pt_memory_waiter_t *> m_waiter_freelist;$/;"	m	class:ptrace_t
m_watch	regfile.h	/^		uint16          m_watch;$/;"	m	class:physical_file_t
m_win_size	iwindow.h	/^  uint32    m_win_size;$/;"	m	class:iwindow_t
m_windex	dynamic.h	/^  uint16         m_windex;$/;"	m	class:dynamic_inst_t
m_window	chain.h	/^  flow_inst_t  **m_window;$/;"	m	class:chain_t
m_window	iwindow.h	/^  dynamic_inst_t  **m_window;$/;"	m	class:iwindow_t
m_window_flow_depth	chain.h	/^  int64          m_window_flow_depth;$/;"	m	class:chain_t
m_window_limit	chain.h	/^  uint32         m_window_limit;$/;"	m	class:chain_t
m_window_map	regbox.C	/^byte_t     **reg_box_t::m_window_map;$/;"	m	class:reg_box_t	file:
m_window_map	regbox.h	/^  static byte_t     **m_window_map;$/;"	m	class:reg_box_t
m_window_size	chain.h	/^  uint32         m_window_size;$/;"	m	class:chain_t
m_window_utilization	chain.h	/^  uint32         m_window_utilization;$/;"	m	class:chain_t
m_writes	memstat.h	/^  int32     m_writes;$/;"	m	class:cache_line_stat_t
madr_1	pseq.h	/^    last_etag_write, lfsr, lsu_ctrl, madr_1, madr_2, madr_3, madr_4,$/;"	e	enum:tlb_reg_t
madr_2	pseq.h	/^    last_etag_write, lfsr, lsu_ctrl, madr_1, madr_2, madr_3, madr_4,$/;"	e	enum:tlb_reg_t
madr_3	pseq.h	/^    last_etag_write, lfsr, lsu_ctrl, madr_1, madr_2, madr_3, madr_4,$/;"	e	enum:tlb_reg_t
madr_4	pseq.h	/^    last_etag_write, lfsr, lsu_ctrl, madr_1, madr_2, madr_3, madr_4,$/;"	e	enum:tlb_reg_t
makePrefetch	mf_api.h	/^  void (*makePrefetch)( int cpuNumber, pa_t physicalAddr,$/;"	m	struct:mf_ruby_api
makeRequest	mf_api.h	/^  void (*makeRequest)( int cpuNumber, pa_t physicalAddr,$/;"	m	struct:mf_ruby_api
make_crc_table	crc16.C	/^void make_crc_table( void ) {$/;"	f
malloc	simdist12.C	157;"	d	file:
malloc	simdist12.C	163;"	d	file:
malloc	simdist12.C	169;"	d	file:
manager	mshr.h	/^  replacement_manager_t<miss_t> *manager;$/;"	m	class:miss_t
manager	mshr.h	/^  replacement_manager_t<stream_t> *manager;$/;"	m	class:stream_t
markDataProducers	pseq.C	/^bool pseq_t::markDataProducers(slice_inst *inst)$/;"	f	class:pseq_t
markEvent	dynamic.h	/^  void   markEvent(inst_event_t e) { m_events |= e; }$/;"	f	class:dynamic_inst_t
markEvent	flow.h	/^  void   markEvent(flow_event_t e) { m_events |= e; }$/;"	f	class:flow_inst_t
markProducers	pseq.C	/^bool pseq_t::markProducers(dynamic_inst_t* inst)$/;"	f	class:pseq_t
markProducers	pseq.C	/^bool pseq_t::markProducers(slice_inst* inst)$/;"	f	class:pseq_t
markToDel	pseq.h	/^		void markToDel() { del_mark = 1 ; } $/;"	f	struct:pseq_t::fault
match	rubycache.h	/^  bool match( pa_t other_address ) {$/;"	f	class:ruby_request_t
matchesLoadBuffer	dynamic.h	/^  virtual bool matchesLoadBuffer() { return true; }$/;"	f	class:dynamic_inst_t
matchesLoadBuffer	memop.C	/^bool atomic_inst_t::matchesLoadBuffer()$/;"	f	class:atomic_inst_t
matchesLoadBuffer	memop.C	/^bool load_inst_t::matchesLoadBuffer()$/;"	f	class:load_inst_t
max	diagnosis.C	/^int multicore_diagnosis_t::max( int * num_instr, int n)$/;"	f	class:multicore_diagnosis_t
max_mismatch	diagnosis.h	/^	int max_mismatch;$/;"	m	class:diagnosis_t
mem_address_control	pseq.h	/^    mem_address_control, mem_tmg_1, mem_tmg_2, mem_tmg_3, mem_tmg_4, mem_tmg_5,$/;"	e	enum:tlb_reg_t
mem_arrival	chain.C	/^void chain_t::mem_arrival( pt_memory_t *inst )$/;"	f	class:chain_t
mem_dependence_t	dependence.C	/^mem_dependence_t::mem_dependence_t( )$/;"	f	class:mem_dependence_t
mem_dependence_t	dependence.h	/^class mem_dependence_t {$/;"	c
mem_event_log	pseq.h	/^  vector<mem_event_t> mem_event_log;$/;"	m	class:pseq_t
mem_event_t	pseq.h	/^} mem_event_t;$/;"	t	typeref:struct:__anon24
mem_rec_t	pseq.h	/^} mem_rec_t;$/;"	t	typeref:struct:__anon21
mem_stat_t	memstat.C	/^mem_stat_t::mem_stat_t( )$/;"	f	class:mem_stat_t
mem_stat_t	memstat.h	/^class mem_stat_t {$/;"	c
mem_tmg_1	pseq.h	/^    mem_address_control, mem_tmg_1, mem_tmg_2, mem_tmg_3, mem_tmg_4, mem_tmg_5,$/;"	e	enum:tlb_reg_t
mem_tmg_2	pseq.h	/^    mem_address_control, mem_tmg_1, mem_tmg_2, mem_tmg_3, mem_tmg_4, mem_tmg_5,$/;"	e	enum:tlb_reg_t
mem_tmg_3	pseq.h	/^    mem_address_control, mem_tmg_1, mem_tmg_2, mem_tmg_3, mem_tmg_4, mem_tmg_5,$/;"	e	enum:tlb_reg_t
mem_tmg_4	pseq.h	/^    mem_address_control, mem_tmg_1, mem_tmg_2, mem_tmg_3, mem_tmg_4, mem_tmg_5,$/;"	e	enum:tlb_reg_t
mem_tmg_5	pseq.h	/^    mem_address_control, mem_tmg_1, mem_tmg_2, mem_tmg_3, mem_tmg_4, mem_tmg_5,$/;"	e	enum:tlb_reg_t
mem_trace_cnt	pseq.h	/^  int mem_trace_cnt;$/;"	m	class:pseq_t
memop_getASI	memop.C	/^uint16 memop_getASI( uint32 inst, reg_id_t asi_reg, bool *is_block_load )$/;"	f
memop_menomic	rubycache.C	/^const char *memop_menomic( OpalMemop_t memop ) {$/;"	f
memory_inst_t	memop.C	/^memory_inst_t::memory_inst_t( static_inst_t *s_inst, $/;"	f	class:memory_inst_t
memory_inst_t	memop.h	/^class memory_inst_t : public dynamic_inst_t {$/;"	c
mf_amber_api	amber_api.h	/^typedef struct mf_amber_api {$/;"	s
mf_opal_api	mf_api.h	/^typedef struct mf_opal_api {$/;"	s
mf_opal_api_t	mf_api.h	/^} mf_opal_api_t;$/;"	t	typeref:struct:mf_opal_api
mf_ruby_api	mf_api.h	/^typedef struct mf_ruby_api {$/;"	s
mf_ruby_api_t	mf_api.h	/^} mf_ruby_api_t;$/;"	t	typeref:struct:mf_ruby_api
min	diagnosis.C	/^uint64 multicore_diagnosis_t::min(uint64 *list, int size)$/;"	f	class:multicore_diagnosis_t
minCommittedInstr	system.C	/^uint64 system_t::minCommittedInstr()$/;"	f	class:system_t
mismatch	checkresult.h	/^  reg_mismatch_info_t mismatch;$/;"	m	class:check_result_t
mismatch	diagnosis.h	/^	bool mismatch;$/;"	m	struct:__anon7
mismatch	diagnosis.h	/^    bool mismatch;$/;"	m	struct:__anon6
mismatch_index	diagnosis.h	/^	vector<int>mismatch_index;$/;"	m	class:diagnosis_t
mismatch_instructions	diagnosis.h	/^	vector<instruction_information_t> mismatch_instructions;$/;"	m	class:diagnosis_t
mismatch_loc	diagnosis.h	/^	loc_id_t mismatch_loc;$/;"	m	struct:__anon8
mismatch_regs	diagnosis.h	/^	vector<reg_mismatch_info_t> mismatch_regs;$/;"	m	struct:__anon2
mismatch_since_last_analysis	diagnosis.h	/^	bool mismatch_since_last_analysis;$/;"	m	class:diagnosis_t
mismatch_unit	diagnosis.h	/^	int mismatch_unit;$/;"	m	struct:__anon8
mismatch_unit_num	diagnosis.h	/^	int mismatch_unit_num;$/;"	m	struct:__anon8
miss_state_t	mshr.h	/^enum miss_state_t { QUEUED_STATE,   \/* waiting for bus free or lower level MSHR available *\/$/;"	g
miss_t	mshr.C	/^miss_t::miss_t( void ) {$/;"	f	class:miss_t
miss_t	mshr.h	/^class miss_t : public waiter_t {$/;"	c
missing_addresses_in_core	diagnosis.h	/^		bool *missing_addresses_in_core;$/;"	m	class:multicore_diagnosis_t
mlpExceptionDispatch	ptrace.C	/^void ptrace_t::mlpExceptionDispatch( int id, uint32 exception )$/;"	f	class:ptrace_t
mlpMemopDispatch	ptrace.C	/^int64 ptrace_t::mlpMemopDispatch( int id, memory_transaction_t *mem_op )$/;"	f	class:ptrace_t
mm_free	simdist12.C	/^void mm_free(void * ptr, const char * src_file, int src_line) {$/;"	f
mm_malloc	simdist12.C	/^void *mm_malloc(size_t sz, size_t typesize, const char *type,$/;"	f
mm_mark_ptr_dbg	simdist12.C	/^void mm_mark_ptr_dbg(void ** pptr, const char * src_file, int src_line) {$/;"	f
mm_realloc	simdist12.C	/^void *mm_realloc(void *ptr, size_t size, size_t typesize, const char *type,$/;"	f
mm_register_type	simdist12.C	/^void mm_register_type(void (*mf)(void *), const char *type_name)$/;"	f
mm_strdup	simdist12.C	/^char *mm_strdup(const char *old_str, const char *file, int line) {$/;"	f
mm_unregister_type	simdist12.C	/^void mm_unregister_type(void (*mf)(void *), const char *type_name)$/;"	f
mm_zalloc	simdist12.C	/^void *mm_zalloc(size_t sz, size_t typesize, const char *type,$/;"	f
mmu	diagnosis.h	/^		conf_object_t **mmu;$/;"	m	class:multicore_diagnosis_t
mmuAccess	pseq.C	/^trap_type_t pseq_t::mmuAccess( la_t address, uint16 asi,$/;"	f	class:pseq_t
mmuRegisterAccess	memop.C	/^memory_inst_t::mmuRegisterAccess( bool isaWrite )$/;"	f	class:memory_inst_t
module_install	simdist12.C	/^void module_install(const char *mod_name, int (*mod_info)(void *),$/;"	f
module_uninstall	simdist12.C	/^void module_uninstall(const char *mod_name, void (*fini_local)(void)) {$/;"	f
movetoHead	mshr.C	/^void replacement_manager_t<Type>::movetoHead(Type *t) {$/;"	f	class:replacement_manager_t
movetoTail	mshr.C	/^void replacement_manager_t<Type>::movetoTail(Type *t) {$/;"	f	class:replacement_manager_t
mshr	cache.h	/^  mshr_t      *mshr;$/;"	m	class:cache_t
mshr_priority_t	mshr.h	/^enum mshr_priority_t { DELAYED_PRIORITY,        \/* ??? not used?         *\/$/;"	g
mshr_t	mshr.C	/^mshr_t::mshr_t(const char *n, generic_cache_template<generic_cache_block_t> *c,$/;"	f	class:mshr_t
mshr_t	mshr.h	/^class mshr_t {$/;"	c
mstate_t	checkresult.h	/^  mstate_t( void ) {$/;"	f	class:mstate_t
mstate_t	checkresult.h	/^class mstate_t {$/;"	c
multicore_diagnosis_t	diagnosis.C	/^multicore_diagnosis_t::multicore_diagnosis_t(system_t *sys, pstate_t **pstate, uint32 num_cores) $/;"	f	class:multicore_diagnosis_t
multicore_diagnosis_t	diagnosis.h	/^class multicore_diagnosis_t {$/;"	c
my_register_t	regfile.h	/^typedef union my_register_u my_register_t;$/;"	t	typeref:union:my_register_u
my_register_u	regfile.h	/^union my_register_u {$/;"	u
n_sets	cache.h	/^  uint32 n_sets;$/;"	m	class:generic_cache_template
name	cache.h	/^  const char  *name;$/;"	m	class:cache_t
newAmberChkpt	system.h	/^  void newAmberChkpt() {$/;"	f	class:system_t
newChkpt	amber_api.h	/^	void (*newChkpt)() ;$/;"	m	struct:mf_amber_api
newChkpt	rubycache.C	/^void rubycache_t::newChkpt()$/;"	f	class:rubycache_t
new_dest_physical	dynamic.h	/^  half_t new_dest_physical;$/;"	m	class:dynamic_inst_t
new_inst	decodefault.h	/^		unsigned int new_inst ;$/;"	m	class:DecodeFault
next	histogram.h	/^  struct hash_ent *prev, *next; \/* Link pointers *\/$/;"	m	struct:hash_ent	typeref:struct:hash_ent::
next	wait.h	/^  waiter_t *next;$/;"	m	class:wait_list_t
nextLogicalReader	diagnosis.C	/^void diagnosis_t::nextLogicalReader(reg_loc_t &reg_loc, reg_loc_t &ret_loc)$/;"	f	class:diagnosis_t
nextLogicalWriter	diagnosis.C	/^void diagnosis_t::nextLogicalWriter(reg_loc_t &reg_loc, reg_loc_t &ret_loc)$/;"	f	class:diagnosis_t
nextPC	statici.h	/^  pmf_nextPC          nextPC;  $/;"	m	class:static_inst_t
nextPC_call	dynamic.C	/^void   dynamic_inst_t::nextPC_call( abstract_pc_t *a )$/;"	f	class:dynamic_inst_t
nextPC_cwp	dynamic.C	/^void   dynamic_inst_t::nextPC_cwp( abstract_pc_t *a )$/;"	f	class:dynamic_inst_t
nextPC_execute	dynamic.C	/^void   dynamic_inst_t::nextPC_execute( abstract_pc_t *a )$/;"	f	class:dynamic_inst_t
nextPC_indirect	dynamic.C	/^void   dynamic_inst_t::nextPC_indirect( abstract_pc_t *a )$/;"	f	class:dynamic_inst_t
nextPC_nop	dynamic.C	/^void   dynamic_inst_t::nextPC_nop( abstract_pc_t *a )$/;"	f	class:dynamic_inst_t
nextPC_predicated_branch	dynamic.C	/^void   dynamic_inst_t::nextPC_predicated_branch( abstract_pc_t *a )$/;"	f	class:dynamic_inst_t
nextPC_predict_branch	dynamic.C	/^void   dynamic_inst_t::nextPC_predict_branch( abstract_pc_t *a )$/;"	f	class:dynamic_inst_t
nextPC_priv	dynamic.C	/^void   dynamic_inst_t::nextPC_priv( abstract_pc_t *a )$/;"	f	class:dynamic_inst_t
nextPC_return	dynamic.C	/^void   dynamic_inst_t::nextPC_return( abstract_pc_t *a )$/;"	f	class:dynamic_inst_t
nextPC_taken	dynamic.C	/^void   dynamic_inst_t::nextPC_taken( abstract_pc_t *a )$/;"	f	class:dynamic_inst_t
nextPC_taken_a	dynamic.C	/^void   dynamic_inst_t::nextPC_taken_a( abstract_pc_t *a )$/;"	f	class:dynamic_inst_t
nextPC_trap	dynamic.C	/^void   dynamic_inst_t::nextPC_trap( abstract_pc_t *a )$/;"	f	class:dynamic_inst_t
nextPC_trap_return	dynamic.C	/^void   dynamic_inst_t::nextPC_trap_return( abstract_pc_t *a )$/;"	f	class:dynamic_inst_t
nextPC_untaken_a	dynamic.C	/^void   dynamic_inst_t::nextPC_untaken_a( abstract_pc_t *a )$/;"	f	class:dynamic_inst_t
nextPhysicalWriter	diagnosis.C	/^void diagnosis_t::nextPhysicalWriter(reg_loc_t &reg_loc, reg_loc_t &ret_loc)$/;"	f	class:diagnosis_t
next_event	scheduler.h	/^  event_t *next_event;$/;"	m	class:event_t
noPhysicalAddress	diagnosis.h	/^		void noPhysicalAddress(int core_id) { $/;"	f	class:multicore_diagnosis_t
no_of_inst_to_simulate	pseq.h	/^  uint64 no_of_inst_to_simulate;$/;"	m	class:pseq_t
no_physical_address	diagnosis.h	/^		bool *no_physical_address;$/;"	m	class:multicore_diagnosis_t
no_tmr_after	diagnosis.h	/^		uint64 *no_tmr_after;$/;"	m	class:multicore_diagnosis_t
notReportingSequenceNumber	diagnosis.C	/^void multicore_diagnosis_t::notReportingSequenceNumber(int core_id, uint64 pc)$/;"	f	class:multicore_diagnosis_t
notifyAmberDrainBuffer	system.h	/^  void notifyAmberDrainBuffer() {$/;"	f	class:system_t
notifyAmberRecovery	system.h	/^  void notifyAmberRecovery() {$/;"	f	class:system_t
notifyAmberRollback	pseq.C	/^void pseq_t::notifyAmberRollback()$/;"	f	class:pseq_t
notifyCallback	mf_api.h	/^  void (*notifyCallback)( int status );$/;"	m	struct:mf_opal_api
notifyCallback	mf_api.h	/^  void (*notifyCallback)( int status );$/;"	m	struct:mf_ruby_api
notifySNETLogging	rubycache.C	/^void rubycache_t::notifySNETLogging()$/;"	f	class:rubycache_t
notifySNETRollback	rubycache.C	/^void rubycache_t::notifySNETRollback()$/;"	f	class:rubycache_t
numProcs	diagnosis.h	/^		int numProcs;$/;"	m	class:multicore_diagnosis_t
num_branch_instr	diagnosis.h	/^		int *num_branch_instr;$/;"	m	class:multicore_diagnosis_t
num_candidates	diagnosis.h	/^	int num_candidates;$/;"	m	class:diagnosis_t
num_candidates	diagnosis.h	/^	int num_candidates;$/;"	m	struct:__anon10
num_diagnosis_steps	diagnosis.h	/^		int num_diagnosis_steps;$/;"	m	class:multicore_diagnosis_t
num_inst_to_run	diagnosis.h	/^		int *num_inst_to_run;$/;"	m	class:multicore_diagnosis_t
num_instructions	diagnosis.h	/^		int *num_instructions;$/;"	m	class:multicore_diagnosis_t
num_llb_entries	diagnosis.h	/^		uint64 *num_llb_entries;$/;"	m	class:multicore_diagnosis_t
num_load_instr	diagnosis.h	/^		int *num_load_instr;$/;"	m	class:multicore_diagnosis_t
num_load_instructions	diagnosis.h	/^		uint64 *num_load_instructions;$/;"	m	class:multicore_diagnosis_t
num_logging_phases	diagnosis.h	/^		int num_logging_phases;$/;"	m	class:multicore_diagnosis_t
num_mismatch_ins	diagnosis.h	/^	uint num_mismatch_ins;$/;"	m	struct:__anon10
num_mismatch_instr	diagnosis.h	/^	uint num_mismatch_instr;$/;"	m	class:diagnosis_t
num_ranges	inv-defs.h	/^  int num_ranges;$/;"	m	struct:MulRangeInvariant
num_rollbacks	diagnosis.h	/^	uint num_rollbacks;$/;"	m	class:diagnosis_t
num_squashes	diagnosis.h	/^		uint64 *num_squashes;$/;"	m	class:multicore_diagnosis_t
num_store_instr	diagnosis.h	/^		int *num_store_instr;$/;"	m	class:multicore_diagnosis_t
num_symptom_detected	diagnosis.h	/^		int num_symptom_detected;$/;"	m	class:multicore_diagnosis_t
num_tlb_regs	pseq.h	/^    pa_watchpoint, trace, va_watchpoint, num_tlb_regs$/;"	e	enum:tlb_reg_t
num_values	pseq.h	/^  uint64 num_values;$/;"	m	class:pseq_t
number_list_t	pseq.h	/^	typedef vector<uint64> number_list_t ;$/;"	t	class:pseq_t
number_processors	simdist12.C	/^unsigned number_processors;$/;"	v
observeIOAction	sysstat.C	/^void sys_stat_t::observeIOAction( memory_transaction_t *mem_op )$/;"	f	class:sys_stat_t
observeInstruction	sysstat.C	/^void sys_stat_t::observeInstruction( pseq_t *pseq, dynamic_inst_t *dinstr )$/;"	f	class:sys_stat_t
observeStaticInstruction	sysstat.C	/^void sys_stat_t::observeStaticInstruction( pseq_t *pseq, $/;"	f	class:sys_stat_t
observeThreadSwitch	sysstat.C	/^void sys_stat_t::observeThreadSwitch( int32 id )$/;"	f	class:sys_stat_t
observeTransactionComplete	sysstat.C	/^void sys_stat_t::observeTransactionComplete( int32 id )$/;"	f	class:sys_stat_t
occupied	inv-defs.h	/^  int occupied[MAX_NUM_RANGES] ;$/;"	m	struct:MulRangeInvariant
offset	diagnosis.h	/^	uint8 offset;$/;"	m	struct:llb_queue_entry
oldAddressAligned	memop.h	/^  bool oldAddressAligned() {$/;"	f	class:memory_inst_t
oldSymptomDetected	pseq.C	/^void pseq_t::oldSymptomDetected(int traptype)$/;"	f	class:pseq_t
old_dest_physical	dynamic.h	/^  half_t old_dest_physical;$/;"	m	class:dynamic_inst_t
old_inst	decodefault.h	/^		unsigned int old_inst ;$/;"	m	class:DecodeFault
old_instr_diag_info_t	pseq.h	/^} old_instr_diag_info_t;$/;"	t	typeref:struct:__anon23
old_phys	regmap.h	/^  half_t         old_phys ;$/;"	m	class:reg_map_t
onlineAnalysis	ptrace.C	/^void ptrace_t::onlineAnalysis( pf_consumer_t my_inst_consumer,$/;"	f	class:ptrace_t
onlineMemoryOp	ptrace.C	/^void ptrace_t::onlineMemoryOp( pt_memory_t *mrecord )$/;"	f	class:ptrace_t
opExecuteLatency	decode.C	/^void decode_stat_t::opExecuteLatency( enum i_opcode op, uint16 latency )$/;"	f	class:decode_stat_t
opMemoryLatency	decode.C	/^void decode_stat_t::opMemoryLatency( enum i_opcode op, uint16 latency )$/;"	f	class:decode_stat_t
opcode	diagnosis.h	/^	half_t opcode;$/;"	m	struct:__anon4
opcode	diagnosis.h	/^	half_t opcode;$/;"	m	struct:__anon7
opcode	diagnosis.h	/^    half_t opcode;$/;"	m	struct:__anon2
opcode	pseq.h	/^		half_t opcode ;$/;"	m	struct:pseq_t::slice_inst
opcode	pseq.h	/^    half_t opcode;$/;"	m	struct:__anon23
opcode_to_exec_type	system.h	/^  dyn_execute_type_t *opcode_to_exec_type;$/;"	m	class:system_t
openBranchTrace	pseq.C	/^void pseq_t::openBranchTrace( char *traceFileName )$/;"	f	class:pseq_t
openBranchTrace	system.C	/^void system_t::openBranchTrace( char *tracename )$/;"	f	class:system_t
openFaultLog	system.C	/^void system_t::openFaultLog( char *logname )$/;"	f	class:system_t
openLogfiles	system.C	/^void system_t::openLogfiles( char *logname )$/;"	f	class:system_t
openRegisterType	arf.C	/^void  arf_container_t::openRegisterType( rid_container_t rtype,$/;"	f	class:arf_container_t
openRegisterType	flatarf.C	/^void    flat_container_t::openRegisterType( rid_container_t rtype, int32 numElements )$/;"	f	class:flat_container_t
openTrace	pseq.C	/^void pseq_t::openTrace( char *traceFileName )$/;"	f	class:pseq_t
openTrace	system.C	/^void system_t::openTrace( char *tracename )$/;"	f	class:system_t
operation_mode_t	pseq.h	/^enum operation_mode_t {$/;"	g
operator ()	ddg.h	/^	bool operator() (uint64 A, uint64 B) {$/;"	f	struct:uint64_cmp
operator ()	diagnosis.h	/^	bool operator() ( uint64 a, uint64 b) const {$/;"	f	struct:load_buffer_cmp
operator ()	pseq.h	/^		bool operator() (fault_t *A, fault_t *B) {$/;"	f	struct:pseq_t::fault_cmp
operator ()	pseq.h	/^		bool operator() (half_t A, half_t B) {$/;"	f	struct:pseq_t::half_cmp
operator ()	pseq.h	/^		bool operator() (la_t A, la_t B) {$/;"	f	struct:pseq_t::addr_cmp
operator ()	pseq.h	/^		bool operator() (uint64 A, uint64 B) {$/;"	f	struct:pseq_t::uint64_cmp
operator <<	wait.h	/^extern inline ostream& operator<<(ostream& out, const wait_list_t &obj )$/;"	f
operator delete	controlop.h	/^  void operator delete( void *obj ) {$/;"	f	class:control_inst_t
operator delete	dynamic.h	/^  void operator delete( void *obj ) {$/;"	f	class:dynamic_inst_t
operator delete	flow.h	/^  void operator delete( void *obj ) {$/;"	f	class:flow_inst_t
operator delete	memop.h	/^  void operator delete( void *obj ) {$/;"	f	class:atomic_inst_t
operator delete	memop.h	/^  void operator delete( void *obj ) {$/;"	f	class:load_inst_t
operator delete	memop.h	/^  void operator delete( void *obj ) {$/;"	f	class:prefetch_inst_t
operator delete	memop.h	/^  void operator delete( void *obj ) {$/;"	f	class:store_inst_t
operator delete	rubycache.h	/^  void operator delete( void *obj ) {$/;"	f	class:ruby_request_t
operator new	controlop.h	/^  void *operator new( size_t size ) {$/;"	f	class:control_inst_t
operator new	dynamic.h	/^  void *operator new( size_t size ) {$/;"	f	class:dynamic_inst_t
operator new	flow.h	/^  void *operator new( size_t size ) {$/;"	f	class:flow_inst_t
operator new	memop.h	/^  void *operator new( size_t size ) {$/;"	f	class:atomic_inst_t
operator new	memop.h	/^  void *operator new( size_t size ) {$/;"	f	class:load_inst_t
operator new	memop.h	/^  void *operator new( size_t size ) {$/;"	f	class:prefetch_inst_t
operator new	memop.h	/^  void *operator new( size_t size ) {$/;"	f	class:store_inst_t
operator new	rubycache.h	/^  void *operator new( size_t size ) {$/;"	f	class:ruby_request_t
operator new	statici.h	/^  void *operator new( size_t size ) {$/;"	f	class:static_inst_t
operator new	statici.h	/^  void *operator new( size_t size, static_inst_t *preallocated_p ) {$/;"	f	class:static_inst_t
oraclePredict	pseq.C	/^pseq_fetch_status_t pseq_t::oraclePredict( dynamic_inst_t *d,$/;"	f	class:pseq_t
orig_dest_reg	statici.h	/^  reg_id_t  orig_dest_reg[SI_MAX_DEST];$/;"	m	class:static_inst_t
original	statici.h	/^  static_inst_t* original;$/;"	m	class:static_inst_t
outSymptomInfo	pseq.h	/^  void outSymptomInfo(uint64 cyc, uint64 inst, const char* trap_name, unsigned int tt, la_t tpc, int priv, la_t thpc, int tl, int coreId)$/;"	f	class:pseq_t
outSymptomInfo	pseq.h	/^  void outSymptomInfo(uint64 cyc, uint64 inst, const char* trap_name, unsigned int tt, la_t tpc, int priv, la_t thpc, int tl, int coreId, int InvId)$/;"	f	class:pseq_t
out_fault_log	fault.C	/^void Fault::out_fault_log( const char *fmt, ... ) {$/;"	f	class:Fault
p_address	dtlb.h	/^  pa_t               p_address;$/;"	m	class:dtlb_entry_t
pa_t	mf_api.h	/^typedef physical_address_t pa_t;$/;"	t
pa_watchpoint	pseq.h	/^    pa_watchpoint, trace, va_watchpoint, num_tlb_regs$/;"	e	enum:tlb_reg_t
panicPC	pseq.C	/^la_t pseq_t::panicPC()$/;"	f	class:pseq_t
parents	ddg.h	/^	ddg_node_list_t parents ;$/;"	m	class:ddg_node_t
partialSquash	pseq.C	/^pseq_t::partialSquash(uint32 last_good, abstract_pc_t *fetch_at,$/;"	f	class:pseq_t
patch_dest	checkresult.h	/^  bool patch_dest;$/;"	m	class:check_result_t
patch_store_value	memop.h	/^  bool patch_store_value;$/;"	m	class:atomic_inst_t
patch_store_value	memop.h	/^  bool patch_store_value;$/;"	m	class:store_inst_t
patched	regfile.h	/^		bool           *patched ;$/;"	m	class:physical_file_t
patched_pc	pseq.h	/^  bool     patched_pc;$/;"	m	class:pseq_t
patched_seq_num	pseq.h	/^  uint64   patched_seq_num;$/;"	m	class:pseq_t
pc	ddg.h	/^	uint64 pc ;$/;"	m	class:ddg_node_t
pc	diagnosis.h	/^	uint64 pc;$/;"	m	struct:__anon12
pc	pseq.h	/^		la_t pc ;$/;"	m	struct:pseq_t::slice_inst
peekWindow	iwindow.C	/^dynamic_inst_t *iwindow_t::peekWindow( int &index )$/;"	f	class:iwindow_t
perfect_check	checkresult.h	/^  bool perfect_check;$/;"	m	class:check_result_t
pf_consumer_t	ptrace.h	/^typedef void (*pf_consumer_t)( pt_record_t * );$/;"	t
phy_reg_bin	diagnosis.h	/^	int *phy_reg_bin;$/;"	m	class:diagnosis_t
phys_reg	pseq.h	/^		half_t phys_reg ;$/;"	m	struct:pseq_t::fault
physical_address	diagnosis.h	/^	uint64 physical_address;$/;"	m	struct:load_info
physical_file_t	regfile.C	/^physical_file_t::physical_file_t( uint16 num_physical, pseq_t *seq, fault_stats* fault_stat ) {$/;"	f	class:physical_file_t
physical_file_t	regfile.C	/^physical_file_t::physical_file_t( uint16 num_physical, pseq_t *seq, int rf_type, fault_stats* fault_stat ) {$/;"	f	class:physical_file_t
physical_file_t	regfile.h	/^class physical_file_t {$/;"	c
physical_reg	diagnosis.h	/^    int physical_reg;$/;"	m	struct:__anon1
physical_reg_t	regfile.h	/^class physical_reg_t {$/;"	c
pipepool_t	pipepool.C	/^pipepool_t::pipepool_t( )$/;"	f	class:pipepool_t
pipepool_t	pipepool.h	/^class pipepool_t {$/;"	c
pipestate_t	pipestate.C	/^pipestate_t::pipestate_t( waiter_t *waiter )$/;"	f	class:pipestate_t
pipestate_t	pipestate.h	/^class pipestate_t {$/;"	c
pmf_dynamicExecute	dynamic.h	/^typedef void (dynamic_inst_t::*pmf_dynamicExecute)( void );$/;"	t
pmf_flowExecute	flow.h	/^typedef void (flow_inst_t::*pmf_flowExecute)( void );$/;"	t
pmf_nextPC	statici.h	/^typedef void (dynamic_inst_t::*pmf_nextPC)( abstract_pc_t *a );$/;"	t
pop	diagnosis.C	/^void llb_t::pop()$/;"	f	class:llb_t
postEvent	pseq.C	/^pseq_t::postEvent( waiter_t *waiter, uint32 cyclesInFuture )$/;"	f	class:pseq_t
postException	chain.C	/^void chain_t::postException( uint32 exception )$/;"	f	class:chain_t
postException	pseq.C	/^void pseq_t::postException( uint32 exception )$/;"	f	class:pseq_t
postRollback	pseq.C	/^void pseq_t::postRollback()$/;"	f	class:pseq_t
postRollback	system.C	/^void system_t::postRollback(int core_id) $/;"	f	class:system_t
postedBreakpoint	system.C	/^void system_t::postedBreakpoint( uint32 id, uint32 access )$/;"	f	class:system_t
postedMagicBreak	system.C	/^void system_t::postedMagicBreak( void )$/;"	f	class:system_t
predecessorCount	sstat.C	/^int32 static_stat_t::predecessorCount( void )$/;"	f	class:static_stat_t
prefetch	rubycache.C	/^ruby_status_t rubycache_t::prefetch( pa_t physical_address,$/;"	f	class:rubycache_t
prefetch_inst_t	memop.C	/^prefetch_inst_t::prefetch_inst_t( static_inst_t *s_inst, $/;"	f	class:prefetch_inst_t
prefetch_inst_t	memop.h	/^class prefetch_inst_t : public memory_inst_t {$/;"	c
prefetched	cache.h	/^  bool      prefetched;$/;"	m	class:generic_cache_block_t
prepareRollback	pseq.C	/^void pseq_t::prepareRollback()$/;"	f	class:pseq_t
prepareRollback	system.C	/^void system_t::prepareRollback(int core_id) $/;"	f	class:system_t
present_miss_manager	mshr.h	/^  replacement_manager_t<miss_t>   present_miss_manager;$/;"	m	class:mshr_t
prev	histogram.h	/^  struct hash_ent *prev, *next; \/* Link pointers *\/$/;"	m	struct:hash_ent	typeref:struct:hash_ent::hash_ent
prev	wait.h	/^  wait_list_t *prev;$/;"	m	class:waiter_t
prev_event	scheduler.h	/^  event_t *prev_event;$/;"	m	class:event_t
previous	pseq.h	/^	int32 previous;$/;"	m	class:pseq_t
previous_op	pseq.h	/^	int32 previous_op;$/;"	m	class:pseq_t
previous_os	pseq.h	/^	int32 previous_os;$/;"	m	class:pseq_t
previous_pc	diagnosis.h	/^		uint64 *previous_pc;$/;"	m	class:multicore_diagnosis_t
previous_pc	pseq.h	/^	uint64 previous_pc;$/;"	m	class:pseq_t
previous_trap_level	pseq.h	/^	uint64 previous_trap_level;$/;"	m	class:pseq_t
previous_trap_type	pseq.h	/^	trap_type_t previous_trap_type;$/;"	m	class:pseq_t
previous_value	memop.h	/^  ireg_t previous_value[MEMOP_MAX_SIZE];$/;"	m	class:atomic_inst_t
previous_value	memop.h	/^  ireg_t previous_value[MEMOP_MAX_SIZE];$/;"	m	class:store_inst_t
print	arf.C	/^void    abstract_rf_t::print( reg_id_t &rid )$/;"	f	class:abstract_rf_t
print	arf.C	/^void    arf_container_t::print( reg_id_t &rid )$/;"	f	class:arf_container_t
print	arf.C	/^void    arf_double_t::print( reg_id_t &rid )$/;"	f	class:arf_double_t
print	decode.C	/^void    decode_stat_t::print( out_intf_t *io )$/;"	f	class:decode_stat_t
print	decodefault.C	/^void DecodeFault::print()$/;"	f	class:DecodeFault
print	dynamic.C	/^const char *dynamic_inst_t::print( void ) const$/;"	f	class:dynamic_inst_t
print	flatarf.C	/^void    flat_container_t::print( reg_id_t &rid )$/;"	f	class:flat_container_t
print	flow.C	/^void cfg_list_t::print( void )$/;"	f	class:cfg_list_t
print	flow.C	/^void flow_inst_t::print( void )$/;"	f	class:flow_inst_t
print	histogram.C	/^int histogram_t::print( out_intf_t *stream )$/;"	f	class:histogram_t
print	ipage.C	/^uint32 ipage_t::print( bool verbose )$/;"	f	class:ipage_t
print	ipagemap.C	/^uint32 ipagemap_t::print( bool verbose )$/;"	f	class:ipagemap_t
print	iwindow.C	/^void  iwindow_t::print( void )$/;"	f	class:iwindow_t
print	lockstat.C	/^void lock_stat_t::print( out_intf_t *stream )$/;"	f	class:lock_stat_t
print	pipepool.C	/^void pipepool_t::print( void )$/;"	f	class:pipepool_t
print	pipestate.h	/^  virtual void   print( void ) {$/;"	f	class:pipestate_t
print	pseq.C	/^void pseq_t::print( void )$/;"	f	class:pseq_t
print	pseq.h	/^		void print(char *s) {$/;"	f	struct:pseq_t::fault
print	pseq.h	/^		void print(char *s) {$/;"	f	struct:pseq_t::slice_inst
print	ptrace.C	/^void   pt_memory_t::print( void )$/;"	f	class:pt_memory_t
print	regbox.C	/^void    reg_id_t::print( void )$/;"	f	class:reg_id_t
print	regfile.C	/^physical_file_t::print(uint16 reg_no)$/;"	f	class:physical_file_t
print	regmap.C	/^reg_map_t::print(void) const$/;"	f	class:reg_map_t
print	rubycache.C	/^void ruby_request_t::print( void )$/;"	f	class:ruby_request_t
print	rubycache.C	/^void rubycache_t::print( void )$/;"	f	class:rubycache_t
print	wait.C	/^wait_list_t::print(ostream& out) const {$/;"	f	class:wait_list_t
print	wait.h	/^  void print( void ) {$/;"	f	class:waiter_t
print	wait.h	/^  void print(ostream& out) const {$/;"	f	class:waiter_t
printArchState	pseq.C	/^void pseq_t::printArchState()$/;"	f	class:pseq_t
printArchState	pstate.C	/^void pstate_t::printArchState()$/;"	f	class:pstate_t
printBuildParameters	system.C	/^void system_t::printBuildParameters( void )$/;"	f	class:system_t
printCFG	pseq.C	/^void pseq_t::printCFG( void )$/;"	f	class:pseq_t
printCLBSize	rubycache.C	/^void rubycache_t::printCLBSize()$/;"	f	class:rubycache_t
printControlDis	statici.C	/^int32 static_inst_t::printControlDis( char *str )$/;"	f	class:static_inst_t
printDDG	ddg.C	/^void ddg_node_t::printDDG()$/;"	f	class:ddg_node_t
printDDG	pseq.C	/^void pseq_t::printDDG()$/;"	f	class:pseq_t
printDataSlice	pseq.C	/^void pseq_t::printDataSlice()$/;"	f	class:pseq_t
printDestReg	dynamic.C	/^void dynamic_inst_t::printDestReg()$/;"	f	class:dynamic_inst_t
printDetail	controlop.C	/^control_inst_t::printDetail( void )$/;"	f	class:control_inst_t
printDetail	dynamic.C	/^void dynamic_inst_t::printDetail( void )$/;"	f	class:dynamic_inst_t
printDetail	iwindow.C	/^void  iwindow_t::printDetail( void )$/;"	f	class:iwindow_t
printDetail	memop.C	/^void atomic_inst_t::printDetail( void )$/;"	f	class:atomic_inst_t
printDetail	memop.C	/^void load_inst_t::printDetail( void )$/;"	f	class:load_inst_t
printDetail	memop.C	/^void memory_inst_t::printDetail( void )$/;"	f	class:memory_inst_t
printDetail	memop.C	/^void prefetch_inst_t::printDetail( void )$/;"	f	class:prefetch_inst_t
printDetail	memop.C	/^void store_inst_t::printDetail( void )$/;"	f	class:store_inst_t
printDetail	statici.C	/^void  static_inst_t::printDetail(out_intf_t *io)$/;"	f	class:static_inst_t
printDetectorRanges	pseq.h	/^	void printDetectorRanges() { fault_stat->printDetectorRanges() ; }$/;"	f	class:pseq_t
printDiagnosisResult	diagnosis.C	/^void diagnosis_t::printDiagnosisResult()$/;"	f	class:diagnosis_t
printDisassemble	regbox.C	/^int reg_id_t::printDisassemble( char *str )$/;"	f	class:reg_id_t
printDisassemble	statici.C	/^int static_inst_t::printDisassemble( char *str )$/;"	f	class:static_inst_t
printDistribution	histogram.C	/^int histogram_t::printDistribution( out_intf_t *stream, bool is_weighted )$/;"	f	class:histogram_t
printFaultBits	regfile.h	/^	void printFaultBits() {$/;"	f	class:physical_file_t
printFaultStats	pseq.h	/^  void printFaultStats()$/;"	f	class:pseq_t
printFaultStats	system.C	/^void system_t::printFaultStats( )$/;"	f	class:system_t
printGraph	flow.C	/^void    flow_inst_t::printGraph( uint32 depth )$/;"	f	class:flow_inst_t
printInflight	pseq.C	/^void pseq_t::printInflight( void )$/;"	f	class:pseq_t
printInflight	system.C	/^void system_t::printInflight( void )$/;"	f	class:system_t
printInstrInfo	diagnosis.C	/^void diagnosis_t::printInstrInfo()$/;"	f	class:diagnosis_t
printIpage	pseq.C	/^uint32 pseq_t::printIpage( bool verbose )$/;"	f	class:pseq_t
printLSQ	lsq.h	/^  void printLSQ( void ) {$/;"	f	class:lsq_t
printListSizes	diagnosis.h	/^	void printListSizes() {$/;"	f	class:diagnosis_t
printLogHeader	system.C	/^void system_t::printLogHeader( void )$/;"	f	class:system_t
printMemEvents	pseq.C	/^void pseq_t::printMemEvents()$/;"	f	class:pseq_t
printMemoryDis	statici.C	/^int32 static_inst_t::printMemoryDis( char *str )$/;"	f	class:static_inst_t
printMemoryStats	chain.C	/^void chain_t::printMemoryStats( void )$/;"	f	class:chain_t
printMemoryStats	ipagemap.C	/^void   ipagemap_t::printMemoryStats( out_intf_t *log )$/;"	f	class:ipagemap_t
printMemoryStats	system.C	/^void system_t::printMemoryStats( void )$/;"	f	class:system_t
printMismatchInstr	diagnosis.C	/^void diagnosis_t::printMismatchInstr()$/;"	f	class:diagnosis_t
printMismatchRegs	diagnosis.C	/^void diagnosis_t::printMismatchRegs()$/;"	f	class:diagnosis_t
printNormalDis	statici.C	/^int32 static_inst_t::printNormalDis( char *str )$/;"	f	class:static_inst_t
printPC	pseq.C	/^void pseq_t::printPC( abstract_pc_t *a )$/;"	f	class:pseq_t
printRegs	dynamic.C	/^void dynamic_inst_t::printRegs( bool print_values )$/;"	f	class:dynamic_inst_t
printRetirePCs	pseq.C	/^void pseq_t::printRetirePCs()$/;"	f	class:pseq_t
printRetireString	dynamic.C	/^char* dynamic_inst_t::printRetireString(char *str)$/;"	f	class:dynamic_inst_t
printRetireTrace	dynamic.C	/^void dynamic_inst_t::printRetireTrace(char *str)$/;"	f	class:dynamic_inst_t
printRetiredInstructions	pseq.C	/^void pseq_t::printRetiredInstructions( void )$/;"	f	class:pseq_t
printReverseDDG	ddg.C	/^void ddg_node_t::printReverseDDG()$/;"	f	class:ddg_node_t
printReverseDDG	pseq.C	/^void pseq_t::printReverseDDG()$/;"	f	class:pseq_t
printStage	dynamic.C	/^const char *dynamic_inst_t::printStage( stage_t stage )$/;"	f	class:dynamic_inst_t
printStageAbbr	dynamic.C	/^const char *dynamic_inst_t::printStageAbbr( stage_t stage )$/;"	f	class:dynamic_inst_t
printStats	cache.C	/^void cache_t::printStats( pseq_t *pseq )$/;"	f	class:cache_t
printStats	chain.C	/^void chain_t::printStats( void )$/;"	f	class:chain_t
printStats	diagnosis.C	/^void multicore_diagnosis_t::printStats()$/;"	f	class:multicore_diagnosis_t
printStats	ipagemap.C	/^void   ipagemap_t::printStats( void )$/;"	f	class:ipagemap_t
printStats	memstat.C	/^void mem_stat_t::printStats( int32 num_threads )$/;"	f	class:mem_stat_t
printStats	mshr.C	/^mshr_t::printStats( pseq_t *pseq )$/;"	f	class:mshr_t
printStats	pseq.C	/^void pseq_t::printStats( void )$/;"	f	class:pseq_t
printStats	sysstat.C	/^void sys_stat_t::printStats( void )$/;"	f	class:sys_stat_t
printStats	system.C	/^void system_t::printStats( void )$/;"	f	class:system_t
printTLB	pseq.C	/^void pseq_t::printTLB()$/;"	f	class:pseq_t
printTrace	system.C	/^void system_t::printTrace( void )$/;"	f	class:system_t
printWindow	chain.C	/^void chain_t::printWindow( void )$/;"	f	class:chain_t
print_llb_analysis	pseq.C	/^void pseq_t::print_llb_analysis()$/;"	f	class:pseq_t
print_trace	pseq.h	/^  int print_trace;$/;"	m	class:pseq_t
priority	wait.h	/^  uint64 priority; $/;"	m	class:waiter_t
processMismatchInstr	diagnosis.C	/^void diagnosis_t::processMismatchInstr(int cur_inst)$/;"	f	class:diagnosis_t
processStuckInstr	diagnosis.C	/^void diagnosis_t::processStuckInstr(int cur_inst) $/;"	f	class:diagnosis_t
process_memory_resident	system.C	/^static double process_memory_resident( void )$/;"	f	file:
process_memory_total	system.C	/^static double process_memory_total( void )$/;"	f	file:
producer_t	pseq.h	/^	typedef map<half_t, uint64, half_cmp> producer_t ;$/;"	t	class:pseq_t
propagateFault	dynamic.C	/^dynamic_inst_t::propagateFault()$/;"	f	class:dynamic_inst_t
propagateObjects	dynamic.C	/^void dynamic_inst_t::propagateObjects(int in_trap)$/;"	f	class:dynamic_inst_t
propagateObjects	memop.C	/^void atomic_inst_t::propagateObjects(int in_trap)$/;"	f	class:atomic_inst_t
propagateObjects	memop.C	/^void load_inst_t::propagateObjects(int in_trap)$/;"	f	class:load_inst_t
propagateObjects	memop.C	/^void store_inst_t::propagateObjects(int in_trap)$/;"	f	class:store_inst_t
ps_compare	pstate.C	/^bool ps_compare( core_state_t * ps_1, core_state_t * ps_2 )$/;"	f
ps_print	pstate.C	/^void  ps_print( core_state_t * ps )$/;"	f
ps_silent_compare	pstate.C	/^bool ps_silent_compare( core_state_t * ps_1, core_state_t * ps_2 )$/;"	f
pseq_fault_id	pseq.C	/^uint64 pseq_t::pseq_fault_id ;$/;"	m	class:pseq_t	file:
pseq_fault_id	pseq.h	/^	static uint64 pseq_fault_id ;$/;"	m	class:pseq_t
pseq_fetch_status_t	pseq.h	/^enum pseq_fetch_status_t {$/;"	g
pseq_mmu_reg_handler	pseq.C	/^static void pseq_mmu_reg_handler( void *pseq_obj, void *ptr,$/;"	f	file:
pseq_retire_status_t	pseq.h	/^enum pseq_retire_status_t {$/;"	g
pseq_t	pseq.C	/^pseq_t::pseq_t( int32 id, multicore_diagnosis_t * m_diag ):out_intf_t( id ), m_iwin(IWINDOW_ROB_SIZE, IWINDOW_WIN_SIZE) {$/;"	f	class:pseq_t
pseq_t	pseq.h	/^class pseq_t : public waiter_t, public out_intf_t {$/;"	c
pstateWindowMap	pstate.C	/^int pstate_t::pstateWindowMap( int cwp, unsigned int reg )$/;"	f	class:pstate_t
pstate_breakpoint_handler	pstate.C	/^void pstate_breakpoint_handler( conf_object_t *cpu, void *parameter )$/;"	f
pstate_step_callback	pstate.C	/^void pstate_step_callback( conf_object_t *obj, void *mypstate )$/;"	f
pstate_t	pstate.C	/^pstate_t::pstate_t( int id , multicore_diagnosis_t * m_diag) {$/;"	f	class:pstate_t
pstate_t	pstate.h	/^class pstate_t {$/;"	c
pt_inst_t	ptrace.h	/^class pt_inst_t : public pt_record_t {$/;"	c
pt_memory_flags_t	ptrace.h	/^typedef uint8 pt_memory_flags_t;$/;"	t
pt_memory_t	ptrace.h	/^class pt_memory_t : public pt_record_t {$/;"	c
pt_memory_waiter_t	ptrace.h	/^class pt_memory_waiter_t : public waiter_t, public pt_memory_t {$/;"	c
pt_record_t	ptrace.h	/^class pt_record_t {$/;"	c
pt_token_t	ptrace.h	/^  enum pt_token_t { PT_INST_RECORD, PT_MEMORY_RECORD };$/;"	g	class:ptrace_t
ptrace_mode_t	ptrace.h	/^  enum ptrace_mode_t {$/;"	g	class:ptrace_t
ptrace_t	ptrace.C	/^ptrace_t::ptrace_t( int32 numProcs )$/;"	f	class:ptrace_t
ptrace_t	ptrace.h	/^class ptrace_t {$/;"	c
pushMemoryWaiter	ptrace.C	/^void ptrace_t::pushMemoryWaiter( pt_memory_waiter_t *waiter )$/;"	f	class:ptrace_t
pushPredecessor	sstat.C	/^void static_stat_t::pushPredecessor( static_inst_t *pred )$/;"	f	class:static_stat_t
pushRetiredInstruction	pseq.C	/^void pseq_t::pushRetiredInstruction( dynamic_inst_t *dinstr )$/;"	f	class:pseq_t
pushSuccessor	sstat.C	/^void static_stat_t::pushSuccessor( static_inst_t *pred )$/;"	f	class:static_stat_t
putFuncLog	system.C	/^void system_t::putFuncLog(func_inst_buffer_t func_inst_buf, int core_id) $/;"	f	class:system_t
putLLB	system.C	/^void system_t::putLLB(llb_t* load_buf, int core_id) $/;"	f	class:system_t
putLog	diagnosis.C	/^void multicore_diagnosis_t::putLog(int from, int to)$/;"	f	class:multicore_diagnosis_t
queryInstr	ipagemap.C	/^bool  ipagemap_t::queryInstr( pa_t address, static_inst_t * &s_instr )$/;"	f	class:ipagemap_t
queryInstruction	pseq.C	/^bool pseq_t::queryInstruction( pa_t fetch_ppc, static_inst_t * &s_instr )$/;"	f	class:pseq_t
queryLocation	ipagemap.C	/^imapentry_t *ipagemap_t::queryLocation( pa_t address, uint32 &hash_index )$/;"	f	class:ipagemap_t
queryRubyInterface	system.C	/^void system_t::queryRubyInterface( void )$/;"	f	class:system_t
queueAdvance	scheduler.C	/^scheduler_t::queueAdvance( tick_t localcycle )$/;"	f	class:scheduler_t
queueInsert	scheduler.C	/^scheduler_t::queueInsert(waiter_t *w, tick_t localcycle, tick_t latency)$/;"	f	class:scheduler_t
queued_miss_manager	mshr.h	/^  replacement_manager_t<miss_t>   queued_miss_manager[MAX_PRIORITY];$/;"	m	class:mshr_t
raiseException	pseq.C	/^pseq_t::raiseException(exception_t type, $/;"	f	class:pseq_t
rangeOverlap	iwindow.C	/^bool iwindow_t::rangeOverlap( uint32 lowerNum, uint32 upperNum, uint32 testNum )$/;"	f	class:iwindow_t
rangeSubtract	iwindow.C	/^int32 iwindow_t::rangeSubtract( uint32 index1, uint32 index2 )$/;"	f	class:iwindow_t
read	memstat.C	/^void mem_stat_t::read( int32 thread_id, la_t virtual_address, pa_t address ,$/;"	f	class:mem_stat_t
read16	ptrace.C	/^uint16 ptrace_t::read16( void )$/;"	f	class:ptrace_t
read32	ptrace.C	/^uint32 ptrace_t::read32( void )$/;"	f	class:ptrace_t
read64	ptrace.C	/^uint64 ptrace_t::read64( void )$/;"	f	class:ptrace_t
read8	ptrace.C	/^uint8 ptrace_t::read8( void )$/;"	f	class:ptrace_t
readCheckpoint	pseq.C	/^void  pseq_t::readCheckpoint( char *checkpointName )$/;"	f	class:pseq_t
readConfiguration	system.C	/^void system_t::readConfiguration( char *configurationName )$/;"	f	class:system_t
readDataOnlyValuesList	pseq.h	/^	void readDataOnlyValuesList() { fault_stat->readDataOnlyValuesList() ; }$/;"	f	class:pseq_t
readDecodeMap	arf.C	/^void      arf_cc_t::readDecodeMap( reg_id_t &rid )$/;"	f	class:arf_cc_t
readDecodeMap	arf.C	/^void      arf_int_t::readDecodeMap( reg_id_t &rid )$/;"	f	class:arf_int_t
readDecodeMap	arf.C	/^void      arf_single_t::readDecodeMap( reg_id_t &rid )$/;"	f	class:arf_single_t
readDecodeMap	arf.C	/^void     arf_int_global_t::readDecodeMap( reg_id_t &rid )$/;"	f	class:arf_int_global_t
readDecodeMap	arf.C	/^void    abstract_rf_t::readDecodeMap( reg_id_t &rid )$/;"	f	class:abstract_rf_t
readDecodeMap	arf.C	/^void    arf_container_t::readDecodeMap( reg_id_t &rid )$/;"	f	class:arf_container_t
readDecodeMap	arf.C	/^void    arf_control_t::readDecodeMap( reg_id_t &rid )$/;"	f	class:arf_control_t
readDecodeMap	arf.C	/^void    arf_double_t::readDecodeMap( reg_id_t &rid )$/;"	f	class:arf_double_t
readDecodeMap	arf.h	/^  void    readDecodeMap( reg_id_t &rid ) {}$/;"	f	class:arf_none_t
readDecodeMap	flatarf.C	/^void    flat_rf_t::readDecodeMap( reg_id_t &rid ) {$/;"	f	class:flat_rf_t
readDetectorList	pseq.h	/^	void readDetectorList()    { fault_stat->readDetectorList() ; }$/;"	f	class:pseq_t
readDetectorRanges	pseq.h	/^	void readDetectorRanges()  { fault_stat->readDetectorRanges() ; }$/;"	f	class:pseq_t
readFile	ipagemap.C	/^bool ipagemap_t::readFile( char *infilename )$/;"	f	class:ipagemap_t
readFloat32	arf.C	/^float32 abstract_rf_t::readFloat32( reg_id_t &rid )$/;"	f	class:abstract_rf_t
readFloat32	arf.C	/^float32 arf_single_t::readFloat32( reg_id_t &rid )$/;"	f	class:arf_single_t
readFloat32	flatarf.C	/^float32   flat_single_t::readFloat32( reg_id_t &rid )$/;"	f	class:flat_single_t
readFloat64	arf.C	/^float64 abstract_rf_t::readFloat64( reg_id_t &rid )$/;"	f	class:abstract_rf_t
readFloat64	arf.C	/^float64 arf_double_t::readFloat64( reg_id_t &rid )$/;"	f	class:arf_double_t
readFloat64	flatarf.C	/^float64   flat_double_t::readFloat64( reg_id_t &rid )$/;"	f	class:flat_double_t
readFromPointer	diagnosis.C	/^uint64 llb_t::readFromPointer(int llb_pointer)$/;"	f	class:llb_t
readFront	diagnosis.C	/^uint64 llb_t::readFront()$/;"	f	class:llb_t
readFront	diagnosis.C	/^uint64 llb_t::readFront(int i)$/;"	f	class:llb_t
readFuncSimValue	pseq.C	/^ireg_t pseq_t::readFuncSimValue(reg_id_t&rid) $/;"	f	class:pseq_t
readInstRangesFile	pseq.h	/^	void readInstRangesFile()  { fault_stat->readInstRangesFile() ; }$/;"	f	class:pseq_t
readInstruction	ptrace.C	/^void ptrace_t::readInstruction( pt_inst_t *irecord )$/;"	f	class:ptrace_t
readInstructionMap	system.C	/^void system_t::readInstructionMap( char *baseFilename, char *traceFilename,$/;"	f	class:system_t
readInstructionTable	pseq.C	/^bool pseq_t::readInstructionTable( char *imapFileName, int context )$/;"	f	class:pseq_t
readInt64	arf.C	/^ireg_t    arf_container_t::readInt64( reg_id_t &rid )$/;"	f	class:arf_container_t
readInt64	arf.C	/^ireg_t  abstract_rf_t::readInt64( reg_id_t &rid )$/;"	f	class:abstract_rf_t
readInt64	arf.C	/^ireg_t  arf_control_t::readInt64( reg_id_t &rid )$/;"	f	class:arf_control_t
readInt64	arf.C	/^ireg_t  arf_double_t::readInt64( reg_id_t &rid )$/;"	f	class:arf_double_t
readInt64	arf.h	/^  ireg_t  readInt64( reg_id_t &rid ) { return (0); }$/;"	f	class:arf_none_t
readInt64	flatarf.C	/^ireg_t    flat_double_t::readInt64( reg_id_t &rid )$/;"	f	class:flat_double_t
readInt64	flatarf.C	/^ireg_t  flat_container_t::readInt64( reg_id_t &rid )$/;"	f	class:flat_container_t
readInt64	flatarf.C	/^ireg_t  flat_control_t::readInt64( reg_id_t &rid )$/;"	f	class:flat_control_t
readInt64	flatarf.C	/^ireg_t  flat_rf_t::readInt64( reg_id_t &rid )$/;"	f	class:flat_rf_t
readInvariantsFlag	pseq.h	/^  bool readInvariantsFlag;$/;"	m	class:pseq_t
readMemory	flow.C	/^void flow_inst_t::readMemory( void )$/;"	f	class:flow_inst_t
readMemory	pseq.C	/^void pseq_t::readMemory(ireg_t log_addr, int size, ireg_t *result_reg)$/;"	f	class:pseq_t
readMemory	pstate.C	/^bool pstate_t::readMemory( ireg_t log_addr, int size, bool sign_extend,$/;"	f	class:pstate_t
readMemoryOp	ptrace.C	/^void ptrace_t::readMemoryOp( pt_memory_t *mrecord )$/;"	f	class:ptrace_t
readPage	ipage.C	/^bool ipage_t::readPage( FILE *fp, pa_t tag, uint32 &totalread )$/;"	f	class:ipage_t
readPhysicalMemory	pseq.C	/^bool pseq_t::readPhysicalMemory( pa_t phys_addr, int size, ireg_t *result_reg )$/;"	f	class:pseq_t
readPhysicalMemory	pstate.C	/^bool pstate_t::readPhysicalMemory( pa_t phys_addr, int size,$/;"	f	class:pstate_t
readRegister	arf.C	/^my_register_t abstract_rf_t::readRegister( reg_id_t &rid )$/;"	f	class:abstract_rf_t
readRegister	arf.C	/^my_register_t arf_double_t::readRegister( reg_id_t &rid )$/;"	f	class:arf_double_t
readTrace	ptrace.C	/^void ptrace_t::readTrace( const char *filename )$/;"	f	class:ptrace_t
readTraceStep	pseq.C	/^bool pseq_t::readTraceStep( la_t &vpc, pa_t &ppc, unsigned int &instr )$/;"	f	class:pseq_t
readTranslation	dtlb.C	/^void dtlb_t::readTranslation( FILE *fp )$/;"	f	class:dtlb_t
read_array_as_memory16	rubycache.C	/^void rubycache_t::read_array_as_memory16( int8 *buffer, uint64 *result,$/;"	f	class:rubycache_t
read_array_as_memory32	rubycache.C	/^void rubycache_t::read_array_as_memory32( int8 *buffer, uint64 *result,$/;"	f	class:rubycache_t
read_array_as_memory64	rubycache.C	/^void rubycache_t::read_array_as_memory64( int8 *buffer, uint64 *result,$/;"	f	class:rubycache_t
read_fault	regfile.h	/^		bool           *read_fault ;$/;"	m	class:physical_file_t
read_hit	cache.h	/^  uint64 read_hit;$/;"	m	class:cache_t
read_miss	cache.h	/^  uint64 read_miss;$/;"	m	class:cache_t
read_pointer	diagnosis.h	/^	int read_pointer;$/;"	m	class:llb_t
reads	cache.h	/^  uint64 reads;$/;"	m	class:cache_t
realloc	simdist12.C	181;"	d	file:
reasonForTMR	diagnosis.h	/^		int reasonForTMR() { return reason_for_tmr_phase; }$/;"	f	class:multicore_diagnosis_t
reason_for_logging_phase	diagnosis.h	/^		int reason_for_logging_phase;$/;"	m	class:multicore_diagnosis_t
reason_for_tmr_phase	diagnosis.h	/^		int reason_for_tmr_phase;$/;"	m	class:multicore_diagnosis_t
recover	amber_api.h	/^	void (*recover)() ;$/;"	m	struct:mf_amber_api
recoverReg	pstate.C	/^ireg_t pstate_t::recoverReg( reg_id_t&rid )$/;"	f	class:pstate_t
recoverState	pstate.C	/^void pstate_t::recoverState( core_state_t *a_state )$/;"	f	class:pstate_t
recoverState	pstate.C	/^void pstate_t::recoverState( void )$/;"	f	class:pstate_t
recoverTLB	pseq.C	/^void pseq_t::recoverTLB()$/;"	f	class:pseq_t
recover_peek	pseq.h	/^  int  recover_peek;$/;"	m	class:pseq_t
recovered	checkresult.h	/^  bool recovered;$/;"	m	class:check_result_t
recovered	pseq.h	/^  bool recovered;$/;"	m	class:pseq_t
recoveryModuleExec	pseq.C	/^void pseq_t::recoveryModuleExec()$/;"	f	class:pseq_t
recovery_instr_mem	pseq.h	/^  unsigned int *recovery_instr_mem;$/;"	m	class:pseq_t
recovery_instr_mem_size	pseq.h	/^  unsigned int recovery_instr_mem_size;$/;"	m	class:pseq_t
recovery_instr_ptr	pseq.h	/^  unsigned int  recovery_instr_ptr;$/;"	m	class:pseq_t
reduced_fault_set	pseq.h	/^	fault_set_t reduced_fault_set ;$/;"	m	class:pseq_t
reduced_fault_set_ids	pseq.h	/^	seq_num_set_t reduced_fault_set_ids ;$/;"	m	class:pseq_t
ref_count	regfile.h	/^		int         *ref_count ;$/;"	m	class:physical_file_t
reg	pseq.h	/^		half_t reg ;$/;"	m	struct:pseq_t::fault
reg	pseq.h	/^    attr_value_t reg[num_tlb_regs];$/;"	m	struct:__anon22
regAllocate	regmap.C	/^reg_map_t::regAllocate(uint16 logical_reg)$/;"	f	class:reg_map_t
regFree	regmap.C	/^reg_map_t::regFree(uint16 logical_reg, uint16 physical_reg)$/;"	f	class:reg_map_t
reg_box_t	regbox.C	/^reg_box_t::reg_box_t( )$/;"	f	class:reg_box_t
reg_box_t	regbox.h	/^class reg_box_t {$/;"	c
reg_dependence_t	dependence.C	/^reg_dependence_t::reg_dependence_t( )$/;"	f	class:reg_dependence_t
reg_dependence_t	dependence.h	/^class reg_dependence_t {$/;"	c
reg_file_type	regfile.h	/^        int reg_file_type;$/;"	m	class:physical_file_t
reg_id_t	regbox.C	/^reg_id_t::reg_id_t( void )$/;"	f	class:reg_id_t
reg_id_t	regbox.h	/^class reg_id_t {$/;"	c
reg_idx	diagnosis.h	/^	int reg_idx;$/;"	m	struct:__anon9
reg_index_t	dynamic.h	/^  enum reg_index_t {SOURCE1_INDEX, SOURCE2_INDEX, TO_FREE_INDEX, DEST_INDEX};$/;"	g	class:dynamic_inst_t
reg_list	pseq.h	/^	reg_list_t reg_list ;$/;"	m	class:pseq_t
reg_list_t	pseq.h	/^	typedef vector<half_t> reg_list_t ;$/;"	t	class:pseq_t
reg_loc_t	diagnosis.h	/^} reg_loc_t;$/;"	t	typeref:struct:__anon9
reg_map_t	regmap.C	/^reg_map_t::reg_map_t(physical_file_t *p, int num_logical) {$/;"	f	class:reg_map_t
reg_map_t	regmap.h	/^class reg_map_t {$/;"	c
reg_mismatch	dynamic.h	/^  vector<reg_mismatch_info_t> reg_mismatch;$/;"	m	class:dynamic_inst_t
reg_mismatch_info_t	diagnosis.h	/^} reg_mismatch_info_t ;$/;"	t	typeref:struct:__anon1
reg_mismatch_list	diagnosis.h	/^    vector<reg_mismatch_info_t> reg_mismatch_list;$/;"	m	class:diagnosis_t
reg_type	diagnosis.h	/^    int reg_type;$/;"	m	struct:__anon1
reg_type	pseq.h	/^		int reg_type ;$/;"	m	struct:pseq_t::fault
reg_valid	pseq.h	/^		int reg_valid ;$/;"	m	struct:pseq_t::fault
registerCheckpoint	cache.C	/^int generic_cache_template<BlockType>::registerCheckpoint( confio_t *conf )$/;"	f	class:generic_cache_template
registerCheckpoint	pseq.C	/^void  pseq_t::registerCheckpoint( void )$/;"	f	class:pseq_t
registerInstructionConsumer	ptrace.C	/^void ptrace_t::registerInstructionConsumer( pf_consumer_t myconsumer )$/;"	f	class:ptrace_t
registerMemoryConsumer	ptrace.C	/^void ptrace_t::registerMemoryConsumer( pf_consumer_t myconsumer )$/;"	f	class:ptrace_t
register_cc_t	regfile.h	/^typedef union register_cc_u register_cc_t;$/;"	t	typeref:union:register_cc_u
register_cc_u	regfile.h	/^union register_cc_u {$/;"	u
register_info_t	diagnosis.h	/^} register_info_t;$/;"	t	typeref:struct:__anon6
registersAvailable	regbox.C	/^bool      reg_box_t::registersAvailable( void )$/;"	f	class:reg_box_t
regs	checkresult.h	/^  reg_box_t           regs;$/;"	m	class:mstate_t
regsAvailable	arf.C	/^bool    abstract_rf_t::regsAvailable( void )$/;"	f	class:abstract_rf_t
regsAvailable	arf.C	/^bool    arf_control_t::regsAvailable( void )$/;"	f	class:arf_control_t
regsAvailable	flatarf.C	/^bool    flat_rf_t::regsAvailable( void ) {$/;"	f	class:flat_rf_t
relative_cycle	stopwatch.C	/^int64 stopwatch_t::relative_cycle( void ) {$/;"	f	class:stopwatch_t
relative_time	stopwatch.C	/^int64 stopwatch_t::relative_time( void ) {$/;"	f	class:stopwatch_t
remove	lsq.C	/^void lsq_t::remove( memory_inst_t *memop ) {$/;"	f	class:lsq_t
removeElement	pipepool.C	/^bool         pipepool_t::removeElement( pipestate_t *state )$/;"	f	class:pipepool_t
removeElement	pipestate.C	/^bool    pipestate_t::removeElement( pipestate_t *element )$/;"	f	class:pipestate_t
removeExceptionHandler	system.C	/^void system_t::removeExceptionHandler( void )$/;"	f	class:system_t
removeFakeInstr	diagnosis.C	/^void diagnosis_t::removeFakeInstr() $/;"	f	class:diagnosis_t
removeHapHandlers	system.C	/^void system_t::removeHapHandlers( void )$/;"	f	class:system_t
removeHead	pipepool.C	/^pipestate_t *pipepool_t::removeHead( void )$/;"	f	class:pipepool_t
removeHead	pipestate.C	/^pipestate_t *pipestate_t::removeHead( void )$/;"	f	class:pipestate_t
removeInterfaces	pseq.C	/^void pseq_t::removeInterfaces( void )$/;"	f	class:pseq_t
removeMemoryHierarchy	system.C	/^void system_t::removeMemoryHierarchy( void )$/;"	f	class:system_t
removeMemoryObserver	system.C	/^void system_t::removeMemoryObserver( void )$/;"	f	class:system_t
removeRubyInterface	system.C	/^void system_t::removeRubyInterface( void )$/;"	f	class:system_t
removeall	flow.C	/^void cfg_list_t::removeall( void )$/;"	f	class:cfg_list_t
renameCount	arf.C	/^half_t  arf_control_t::renameCount( reg_id_t &rid )$/;"	f	class:arf_control_t
renameCount	arf.C	/^half_t abstract_rf_t::renameCount( reg_id_t &rid )$/;"	f	class:abstract_rf_t
renameCount	arf.h	/^  half_t  renameCount( reg_id_t &rid ) { return (0); }$/;"	f	class:arf_none_t
renameCount	flatarf.C	/^half_t  flat_rf_t::renameCount( reg_id_t &rid ) {$/;"	f	class:flat_rf_t
replace_next	mshr.h	/^  miss_t *replace_prev, *replace_next;$/;"	m	class:miss_t
replace_next	mshr.h	/^  stream_t *replace_prev, *replace_next;$/;"	m	class:stream_t
replace_prev	mshr.h	/^  miss_t *replace_prev, *replace_next;$/;"	m	class:miss_t
replace_prev	mshr.h	/^  stream_t *replace_prev, *replace_next;$/;"	m	class:stream_t
replacement_manager_t	mshr.h	/^  replacement_manager_t() {$/;"	f	class:replacement_manager_t
replacement_manager_t	mshr.h	/^class replacement_manager_t {$/;"	c
replacements	cache.h	/^  uint64 replacements;$/;"	m	class:cache_t
replay	memop.C	/^atomic_inst_t::replay( void ) {$/;"	f	class:atomic_inst_t
replay	memop.C	/^load_inst_t::replay( void ) {$/;"	f	class:load_inst_t
replayPolicy	diagnosis.C	/^void multicore_diagnosis_t::replayPolicy()$/;"	f	class:multicore_diagnosis_t
reportAddressNotFound	diagnosis.C	/^void multicore_diagnosis_t::reportAddressNotFound(int core_id, uint64 physical_address)$/;"	f	class:multicore_diagnosis_t
reportFuncBufferMiss	diagnosis.C	/^void multicore_diagnosis_t::reportFuncBufferMiss(int core_id)$/;"	f	class:multicore_diagnosis_t
reportInterrupt	diagnosis.C	/^void multicore_diagnosis_t::reportInterrupt(int core_id)$/;"	f	class:multicore_diagnosis_t
reportLoadInstruction	diagnosis.C	/^void multicore_diagnosis_t::reportLoadInstruction(int core_id)$/;"	f	class:multicore_diagnosis_t
reportSequenceNumber	diagnosis.C	/^void multicore_diagnosis_t::reportSequenceNumber(int core_id, uint64 pc)$/;"	f	class:multicore_diagnosis_t
reportSquash	diagnosis.C	/^void multicore_diagnosis_t::reportSquash(int core_id)$/;"	f	class:multicore_diagnosis_t
reportSquashingOnAddress	diagnosis.C	/^void multicore_diagnosis_t::reportSquashingOnAddress(uint64 addr, int core_id)$/;"	f	class:multicore_diagnosis_t
res_bus	diagnosis.h	/^    int res_bus;$/;"	m	struct:__anon2
res_bus	diagnosis.h	/^    int res_bus;$/;"	m	struct:__anon5
res_bus	pseq.h	/^    int res_bus;$/;"	m	struct:__anon23
res_bus_bin	diagnosis.h	/^	int *res_bus_bin;$/;"	m	class:diagnosis_t
reset	regbox.h	/^  inline void       reset( void ) {$/;"	f	class:reg_id_t
reset	stopwatch.C	/^void stopwatch_t::reset( void ) {$/;"	f	class:stopwatch_t
resetInstrTrace	diagnosis.h	/^	void resetInstrTrace() {$/;"	f	class:diagnosis_t
resetNoPhysicalAddress	diagnosis.C	/^void multicore_diagnosis_t::resetNoPhysicalAddress()$/;"	f	class:multicore_diagnosis_t
resetReadPointer	diagnosis.C	/^void llb_t::resetReadPointer()$/;"	f	class:llb_t
resetStartLocalCycle	diagnosis.C	/^void multicore_diagnosis_t::resetStartLocalCycle()$/;"	f	class:multicore_diagnosis_t
resetStartSequenceNumber	diagnosis.C	/^void multicore_diagnosis_t::resetStartSequenceNumber()$/;"	f	class:multicore_diagnosis_t
resetWayCounter	pseq.h	/^  void    resetWayCounter() { way_counter = 0 ; agen_counter=0; fway_counter=8;}$/;"	f	class:pseq_t
restore_func_inst_info	pseq.C	/^void pseq_t::restore_func_inst_info( dynamic_inst_t *dinst )$/;"	f	class:pseq_t
result_list	diagnosis.h	/^	vector<diag_result_t> result_list;$/;"	m	class:diagnosis_t
retireInstruction	iwindow.C	/^dynamic_inst_t *iwindow_t::retireInstruction( void )$/;"	f	class:iwindow_t
retireInstruction	pseq.C	/^void pseq_t::retireInstruction( void )$/;"	f	class:pseq_t
retireRegisters	dynamic.C	/^dynamic_inst_t::retireRegisters() {$/;"	f	class:dynamic_inst_t
retire_menomic	pseq.C	/^const char *pseq_t::retire_menomic( pseq_retire_status_t status )$/;"	f	class:pseq_t
retire_pcs	pseq.h	/^	retire_pcs_t retire_pcs ;$/;"	m	class:pseq_t
retire_pcs_t	pseq.h	/^	typedef map<uint64, int, uint64_cmp> retire_pcs_t ;$/;"	t	class:pseq_t
retry_mismatch	checkresult.h	/^  bool retry_mismatch;$/;"	m	class:check_result_t
rid	diagnosis.h	/^	reg_id_t rid;$/;"	m	struct:__anon3
rid	diagnosis.h	/^	reg_id_t rid;$/;"	m	struct:__anon6
rid_type_menomic	regbox.C	/^const char *reg_id_t::rid_type_menomic( rid_type_t rtype )$/;"	f	class:reg_id_t
rob_bin	diagnosis.h	/^	int *rob_bin;$/;"	m	class:diagnosis_t
rob_head	iwindow.h	/^  uint32     rob_head;$/;"	m	class:iwindow_t
rob_tail	iwindow.h	/^  uint32     rob_tail;$/;"	m	class:iwindow_t
rollbackRecovery	pseq.C	/^pseq_t::rollbackRecovery()$/;"	f	class:pseq_t
rollbackReset	arf.C	/^void abstract_rf_t::rollbackReset()$/;"	f	class:abstract_rf_t
rollbackReset	arf.C	/^void arf_int_t::rollbackReset()$/;"	f	class:arf_int_t
rollbackReset	arf.C	/^void arf_single_t::rollbackReset()$/;"	f	class:arf_single_t
rollbackReset	arf.h	/^  void rollbackReset() {$/;"	f	class:arf_control_t
rubyCompletedRequest	system.C	/^void system_t::rubyCompletedRequest( int cpuNumber,$/;"	f	class:system_t
rubyInstructionQuery	system.C	/^integer_t system_t::rubyInstructionQuery( int cpuNumber )$/;"	f	class:system_t
rubyNotifyRecieve	system.C	/^void system_t::rubyNotifyRecieve( int status )$/;"	f	class:system_t
rubyNotifySend	system.C	/^void system_t::rubyNotifySend( int status )$/;"	f	class:system_t
ruby_request_t	rubycache.C	/^ruby_request_t::ruby_request_t( waiter_t *waiter, pa_t address, $/;"	f	class:ruby_request_t
ruby_request_t	rubycache.h	/^class ruby_request_t : public pipestate_t {$/;"	c
ruby_status_t	rubycache.h	/^enum ruby_status_t { MISS, HIT, NOT_READY };$/;"	g
rubycache_t	rubycache.C	/^rubycache_t::rubycache_t( uint32 id, uint32 block_bits,$/;"	f	class:rubycache_t
rubycache_t	rubycache.h	/^class rubycache_t : public waiter_t {$/;"	c
rule_out_datapath	diagnosis.h	/^	bool rule_out_datapath;$/;"	m	class:diagnosis_t
runMulticoreDiagnosisAlgorithm	diagnosis.C	/^void multicore_diagnosis_t::runMulticoreDiagnosisAlgorithm(int core_id)$/;"	f	class:multicore_diagnosis_t
runOnCpu	threadstat.C	/^void thread_stat_t::runOnCpu( int32 id )$/;"	f	class:thread_stat_t
s	dynamic.h	/^  static_inst_t *s;$/;"	m	class:dynamic_inst_t
s_count_processors	system.C	/^static void s_count_processors( conf_object_t *processor, void *count_i32 )$/;"	f	file:
s_dest	diagnosis.h	/^	reg_id_t s_dest[SI_MAX_DEST];$/;"	m	struct:__anon7
s_inst	decodefault.h	/^		static_inst_t *s_inst ;	\/\/ Faulty static inst$/;"	m	class:DecodeFault
s_max_processor_id	system.C	/^static int32 s_max_processor_id = 0;$/;"	v	file:
s_num_instructions	chain.C	/^uint32 chain_t::s_num_instructions;$/;"	m	class:chain_t	file:
s_num_instructions	chain.h	/^  static uint32 s_num_instructions;$/;"	m	class:chain_t
s_source	diagnosis.h	/^	reg_id_t s_source[SI_MAX_SOURCE];$/;"	m	struct:__anon7
sameFaultyLoc	diagnosis.h	/^	bool sameFaultyLoc(faulty_loc_t &A, faulty_loc_t&B) {$/;"	f	class:diagnosis_t
samePhysical	diagnosis.h	/^	bool samePhysical(reg_loc_t&A, reg_loc_t&B) {$/;"	f	class:diagnosis_t
same_line	cache.h	/^  inline bool same_line(pa_t pc1, pa_t pc2) {$/;"	f	class:generic_cache_template
sanitizeAddr	dynamic.C	/^void dynamic_inst_t::sanitizeAddr(char *in_addr, int length)$/;"	f	class:dynamic_inst_t
saveFile	ipagemap.C	/^bool ipagemap_t::saveFile( char *outfilename )$/;"	f	class:ipagemap_t
saveInstructionMap	system.C	/^void system_t::saveInstructionMap( char *baseFilename, char *traceFilename )$/;"	f	class:system_t
schedule	scheduler.h	/^  void schedule(dynamic_inst_t *d) { $/;"	f	class:scheduler_t
scheduleInstruction	iwindow.C	/^dynamic_inst_t *iwindow_t::scheduleInstruction( void )$/;"	f	class:iwindow_t
scheduleInstruction	pseq.C	/^void pseq_t::scheduleInstruction( void )$/;"	f	class:pseq_t
scheduleWakeup	rubycache.C	/^void rubycache_t::scheduleWakeup( void )$/;"	f	class:rubycache_t
scheduler_t	scheduler.C	/^scheduler_t::scheduler_t( pseq_t *seq ) : $/;"	f	class:scheduler_t
scheduler_t	scheduler.h	/^class scheduler_t : public wait_list_t {$/;"	c
sec_symptom	diagnosis.h	/^	int sec_symptom;$/;"	m	class:diagnosis_t
sec_symptom_inst	diagnosis.h	/^	uint64 sec_symptom_inst;$/;"	m	class:diagnosis_t
seenOp	decode.h	/^  void    seenOp( enum i_opcode op ) {$/;"	f	class:decode_stat_t
seen_fatal_trap	pseq.h	/^  bool     seen_fatal_trap;$/;"	m	class:pseq_t
selectImapFiles	system.C	/^static int selectImapFiles( const struct dirent *d )$/;"	f	file:
seq	ddg.h	/^	uint64 seq ;$/;"	m	class:ddg_node_t
seq	pseq.h	/^		uint64 seq ;$/;"	m	struct:pseq_t::slice_inst
seq_num	diagnosis.h	/^	uint64 seq_num;$/;"	m	struct:__anon7
seq_num	dynamic.h	/^  uint64         seq_num;$/;"	m	class:dynamic_inst_t
seq_num	fault.h	/^		unsigned int seq_num ;	\/\/ Sequence number of the inst with fault$/;"	m	class:Fault
seq_num_set_t	pseq.h	/^	typedef map<uint64, uint64_list_t, uint64_cmp> seq_num_set_t ;$/;"	t	class:pseq_t
server_client_mode	system.h	/^  int server_client_mode;$/;"	m	class:system_t
server_start_num	system.h	/^  int server_start_num;$/;"	m	class:system_t
setARF	regbox.h	/^  inline void       setARF( abstract_rf_t *arf ) {$/;"	f	class:reg_id_t
setASI	memop.C	/^void memory_inst_t::setASI( void )$/;"	f	class:memory_inst_t
setAccessSize	memop.h	/^  void      setAccessSize( byte_t new_size )  {$/;"	f	class:memory_inst_t
setActivateFault	dynamic.h	/^  void setActivateFault() { activate_fault=true ;}$/;"	f	class:dynamic_inst_t
setArchBPS	pseq.h	/^  void setArchBPS(predictor_state_t &new_arch_bpred) {$/;"	f	class:pseq_t
setArchCycle	fault.h	/^		void setArchCycle( tick_t cycle )	{ arch_cycle = cycle ; }$/;"	f	class:Fault
setArchCycle	pseq.h	/^  void setArchCycle()$/;"	f	class:pseq_t
setArchInuseCycle	pseq.h	/^  void setArchInuseCycle()$/;"	f	class:pseq_t
setChangedDest	statici.h	/^  void setChangedDest(bool value) { changed_dest = value; }$/;"	f	class:static_inst_t
setChkptInterval	pstate.h	/^  void setChkptInterval(int i) { m_chkpt_interval = i ; }$/;"	f	class:pstate_t
setChkptInterval	system.C	/^void system_t::setChkptInterval(int interval)$/;"	f	class:system_t
setChkptNum	pstate.h	/^  void setChkptNum(int num) { assert(num<NUM_CHKPTS) ; curr_chkpt = num; }$/;"	f	class:pstate_t
setClock	pseq.h	/^  void setClock(uint64 c)$/;"	f	class:pseq_t
setComparePoint	pseq.h	/^  void setComparePoint(int r)$/;"	f	class:pseq_t
setComparePoint	system.C	/^void  system_t::setComparePoint( int sd )$/;"	f	class:system_t
setControl	pstate.h	/^  void setControl(unsigned int reg, ireg_t value) {$/;"	f	class:pstate_t
setControlFault	dynamic.h	/^  void setControlFault() { m_control_fault = true ; }$/;"	f	class:dynamic_inst_t
setCorrupted	arf.C	/^void abstract_rf_t::setCorrupted( reg_id_t &rid )$/;"	f	class:abstract_rf_t
setCorrupted	arf.C	/^void arf_control_t::setCorrupted( reg_id_t &rid )$/;"	f	class:arf_control_t
setCorrupted	arf.C	/^void arf_double_t::setCorrupted( reg_id_t &rid )$/;"	f	class:arf_double_t
setCorrupted	dynamic.h	/^  void setCorrupted() { corrupted=true;}$/;"	f	class:dynamic_inst_t
setCorrupted	regfile.h	/^	void setCorrupted(uint16 reg_no) {$/;"	f	class:physical_file_t
setCorruptedPair	dynamic.h	/^  void setCorruptedPair(half_t old_reg, half_t new_reg) {$/;"	f	class:dynamic_inst_t
setCurrInst	pseq.h	/^  void setCurrInst(uint64 i)$/;"	f	class:pseq_t
setCycle	pseq.h	/^		void setCycle(tick_t c) { cycle = c ; }$/;"	f	struct:pseq_t::fault
setDepend	memop.h	/^  void          setDepend( store_inst_t *depend ) {$/;"	f	class:atomic_inst_t
setDepend	memop.h	/^  void          setDepend( store_inst_t *depend ) {$/;"	f	class:load_inst_t
setDependence	arf.C	/^void         abstract_rf_t::setDependence( reg_id_t &rid,$/;"	f	class:abstract_rf_t
setDependence	flatarf.C	/^void         flat_container_t::setDependence( reg_id_t &rid,$/;"	f	class:flat_container_t
setDependence	flatarf.C	/^void    flat_double_t::setDependence( reg_id_t &rid, flow_inst_t *inst )$/;"	f	class:flat_double_t
setDependence	flatarf.C	/^void    flat_rf_t::setDependence( reg_id_t &rid, flow_inst_t *inst )$/;"	f	class:flat_rf_t
setDetected	system.h	/^  void setDetected() { m_is_detected = true ; }$/;"	f	class:system_t
setDiagnosis	arf.h	/^  void setDiagnosis(diagnosis_t* diag) $/;"	f	class:abstract_rf_t
setDoFaultInjection	pseq.h	/^  void setDoFaultInjection()$/;"	f	class:pseq_t
setDouble	pstate.h	/^  void setDouble( unsigned int reg, freg_t value ) {$/;"	f	class:pstate_t
setExcludeDatapath	diagnosis.C	/^void diagnosis_t::setExcludeDatapath() {$/;"	f	class:diagnosis_t
setExecUnit	dynamic.h	/^  void setExecUnit( int32 t, byte_t n )	{ exec_unit = t ; exec_unit_num = n ; } $/;"	f	class:dynamic_inst_t
setExitCode	statici.h	/^  void setExitCode(int value) { m_exit_code = value; }$/;"	f	class:static_inst_t
setFault	arf.C	/^void abstract_rf_t::setFault( reg_id_t &rid )$/;"	f	class:abstract_rf_t
setFault	arf.C	/^void arf_control_t::setFault( reg_id_t &rid )$/;"	f	class:arf_control_t
setFault	arf.C	/^void arf_double_t::setFault( reg_id_t &rid )$/;"	f	class:arf_double_t
setFault	dynamic.h	/^  void setFault() { has_fault=true ; corrupted=true ; }$/;"	f	class:dynamic_inst_t
setFault	regfile.h	/^        void setFault( uint16 reg_no ) { $/;"	f	class:physical_file_t
setFault	regmap.h	/^  void setFault( uint16 reg_no ) {$/;"	f	class:reg_map_t
setFault	statici.h	/^  void setFault() { has_fault = true ; }$/;"	f	class:static_inst_t
setFaultBit	pseq.h	/^  void setFaultBit(int t)$/;"	f	class:pseq_t
setFaultBit	system.C	/^void system_t::setFaultBit( int b )$/;"	f	class:system_t
setFaultInjCycle	pseq.h	/^  void setFaultInjCycle(int cycle)$/;"	f	class:pseq_t
setFaultInjInst	pseq.h	/^  void setFaultInjInst(int value)$/;"	f	class:pseq_t
setFaultInjInst	system.C	/^void system_t::setFaultInjInst(int value)$/;"	f	class:system_t
setFaultStat	iwindow.h	/^  void setFaultStat(fault_stats *fault_stat) { m_fs = fault_stat; }$/;"	f	class:iwindow_t
setFaultStuckat	pseq.h	/^  void setFaultStuckat(int t)$/;"	f	class:pseq_t
setFaultStuckat	system.C	/^void  system_t::setFaultStuckat( int s )$/;"	f	class:system_t
setFaultType	pseq.h	/^  void setFaultType(int t)$/;"	f	class:pseq_t
setFaultType	system.C	/^void system_t::setFaultType( int t )$/;"	f	class:system_t
setFaultyCore	system.C	/^void  system_t::setFaultyCore( int c )$/;"	f	class:system_t
setFaultyFanoutId	pseq.h	/^  void  setFaultyFanoutId( int s )$/;"	f	class:pseq_t
setFaultyFanoutId	system.C	/^void  system_t::setFaultyFanoutId( int s )$/;"	f	class:system_t
setFaultyGateId	pseq.h	/^  void  setFaultyGateId( int s )$/;"	f	class:pseq_t
setFaultyGateId	system.C	/^void  system_t::setFaultyGateId( int s )$/;"	f	class:system_t
setFaultyMachine	pseq.h	/^  void  setFaultyMachine( string s )$/;"	f	class:pseq_t
setFaultyMachine	system.C	/^void  system_t::setFaultyMachine( string s )$/;"	f	class:system_t
setFaultyReg	pseq.h	/^  void setFaultyReg(int r)$/;"	f	class:pseq_t
setFaultyReg	system.C	/^void  system_t::setFaultyReg( int r )$/;"	f	class:system_t
setFirstTimeRollback	diagnosis.h	/^		void setFirstTimeRollback() { first_time_rollback = true; }$/;"	f	class:multicore_diagnosis_t
setFlag	ptrace.h	/^  void      setFlag( const pt_memory_flags_t flag, bool value ) {$/;"	f	class:pt_memory_t
setFlag	statici.h	/^  void      setFlag( const byte_t flag, bool value ) {$/;"	f	class:static_inst_t
setFloat	regfile.h	/^        void    setFloat(uint16 reg_no, float32 value) {$/;"	f	class:physical_file_t
setFree	regfile.h	/^        void    setFree(uint16 reg_no, bool value) {$/;"	f	class:physical_file_t
setID	flow.h	/^  void    setID( uint64 id ) {$/;"	f	class:flow_inst_t
setInfLoopCycle	pseq.h	/^  void setInfLoopCycle(uint64 cycle)$/;"	f	class:pseq_t
setInfLoopCycle	system.C	/^void  system_t::setInfLoopCycle( uint64 cycle )$/;"	f	class:system_t
setInjectFault	memop.h	/^  void      setInjectFault() { should_inject_fault = true ; }$/;"	f	class:memory_inst_t
setInjectedCycle	fault.h	/^		void setInjectedCycle( tick_t cycle )	{ inject_cycle = cycle ; }$/;"	f	class:Fault
setInt	regfile.h	/^        void   setInt(uint16 reg_no, uint64 value) {$/;"	f	class:physical_file_t
setIntGlobal	pstate.h	/^  void setIntGlobal( unsigned int reg, int global_set, ireg_t value) {$/;"	f	class:pstate_t
setIntWp	pstate.h	/^  void setIntWp( unsigned int reg, int cwp, ireg_t value) {$/;"	f	class:pstate_t
setLLBReadPointer	dynamic.h	/^  virtual bool setLLBReadPointer(int) { return false;}$/;"	f	class:dynamic_inst_t
setLLBReadPointer	memop.C	/^bool atomic_inst_t::setLLBReadPointer(int read_pointer)$/;"	f	class:atomic_inst_t
setLLBReadPointer	memop.C	/^bool load_inst_t::setLLBReadPointer(int read_pointer)$/;"	f	class:load_inst_t
setLastReplay	diagnosis.h	/^		void setLastReplay() {$/;"	f	class:multicore_diagnosis_t
setLoggingStep	diagnosis.h	/^		void setLoggingStep() {$/;"	f	class:multicore_diagnosis_t
setMSHR	mshr.C	/^stream_t::setMSHR( mshr_t *mshr )$/;"	f	class:stream_t
setMapping	regmap.C	/^reg_map_t::setMapping(uint16 logical_reg, uint16 phys_reg)$/;"	f	class:reg_map_t
setMemCycle	pseq.h	/^  void setMemCycle()$/;"	f	class:pseq_t
setMemDepth	flow.h	/^  void     setMemDepth( int32 mem_depth ) {$/;"	f	class:flow_inst_t
setMemFault	memop.h	/^	  void      setMemFault() { has_mem_fault = true ; }$/;"	f	class:memory_inst_t
setMismatchInfo	diagnosis.C	/^void diagnosis_t::setMismatchInfo(tick_t cycle, uint64 instr) $/;"	f	class:diagnosis_t
setNextPC	statici.C	/^void   static_inst_t::setNextPC( void )$/;"	f	class:static_inst_t
setNonRetTrap	pseq.h	/^  void setNonRetTrap()$/;"	f	class:pseq_t
setOldPhysicalAddress	memop.h	/^  void setOldPhysicalAddress(my_addr_t addr ) { m_old_physical_addr = addr ; }$/;"	f	class:memory_inst_t
setOldReg	regmap.h	/^  void setOldReg( half_t p ) { old_phys = p ; }$/;"	f	class:reg_map_t
setOriginalInstr	statici.C	/^static_inst_t::setOriginalInstr(static_inst_t*orig) {$/;"	f	class:static_inst_t
setOwner	memstat.C	/^void cache_line_stat_t::setOwner( int32 thread_id )$/;"	f	class:cache_line_stat_t
setPC	pstate.h	/^  void setPC(ireg_t value) {$/;"	f	class:pstate_t
setPageAddress	ipage.C	/^void   ipage_t::setPageAddress( pa_t address )$/;"	f	class:ipage_t
setPatched	arf.C	/^void abstract_rf_t::setPatched( reg_id_t &rid )$/;"	f	class:abstract_rf_t
setPatched	arf.C	/^void arf_control_t::setPatched( reg_id_t &rid )$/;"	f	class:arf_control_t
setPatched	arf.C	/^void arf_double_t::setPatched( reg_id_t &rid )$/;"	f	class:arf_double_t
setPatched	regfile.h	/^	void setPatched( uint16 reg_no ) {$/;"	f	class:physical_file_t
setPhysical	regbox.h	/^  inline void       setPhysical( half_t physical ) {$/;"	f	class:reg_id_t
setPhysicalAddress	flow.h	/^  void    setPhysicalAddress( pa_t addr ) {$/;"	f	class:flow_inst_t
setPhysicalAddress	memop.h	/^  void setPhysicalAddress(my_addr_t addr ) {$/;"	f	class:memory_inst_t
setPredictedTarget	controlop.h	/^  void              setPredictedTarget(abstract_pc_t *a) {$/;"	f	class:control_inst_t
setPredictorState	controlop.h	/^  void              setPredictorState(predictor_state_t &p) {$/;"	f	class:control_inst_t
setPriv	pseq.h	/^  void setPriv(int p)$/;"	f	class:pseq_t
setPseq	fault.h	/^		void setPseq( pseq_t *pseq ) 		{ m_pseq = pseq ; }$/;"	f	class:Fault
setRFWakeup	arf.C	/^void abstract_rf_t::setRFWakeup(bool value) {$/;"	f	class:abstract_rf_t
setRFWakeup	regfile.h	/^	void setRFWakeup(bool value) $/;"	f	class:physical_file_t
setReadFault	arf.C	/^void abstract_rf_t::setReadFault( reg_id_t &rid )$/;"	f	class:abstract_rf_t
setReadFault	arf.C	/^void arf_double_t::setReadFault( reg_id_t &rid )$/;"	f	class:arf_double_t
setReadFault	regfile.h	/^	inline void setReadFault( uint16 reg_no ) {$/;"	f	class:physical_file_t
setReadFaults	dynamic.C	/^void dynamic_inst_t::setReadFaults()$/;"	f	class:dynamic_inst_t
setReady	regfile.h	/^	void setReady(uint16 reg_no) {$/;"	f	class:physical_file_t
setRecoveryInfo	diagnosis.C	/^void diagnosis_t::setRecoveryInfo(tick_t cycle, uint64 instr) $/;"	f	class:diagnosis_t
setResponsePipe	pseq.h	/^  void  setResponsePipe( string s )$/;"	f	class:pseq_t
setResponsePipe	system.C	/^void  system_t::setResponsePipe( string s )$/;"	f	class:system_t
setRetInst	pseq.h	/^  void setRetInst(uint64 i)$/;"	f	class:pseq_t
setRetPriv	pseq.h	/^  void setRetPriv(unsigned int i)$/;"	f	class:pseq_t
setRtype	regbox.h	/^  inline void       setRtype( rid_type_t rtype ) {$/;"	f	class:reg_id_t
setSelector	regbox.h	/^  inline void       setSelector( byte_t selected ) {$/;"	f	class:reg_id_t
setSeqNum	fault.h	/^		void setSeqNum( unsigned int num )	{ seq_num = num ; }$/;"	f	class:Fault
setServerClient	system.C	/^void system_t::setServerClient( int mode ) $/;"	f	class:system_t
setSimicsBreakpoint	system.C	/^void system_t::setSimicsBreakpoint( la_t address, breakpoint_kind_t breaktype,$/;"	f	class:system_t
setSimicsBreakpoint	system.C	/^void system_t::setSimicsBreakpoint( la_t address, void *user_data )$/;"	f	class:system_t
setSpecBPS	pseq.h	/^  void setSpecBPS(predictor_state_t &new_arch_bpred) {$/;"	f	class:pseq_t
setSrcDestReg	pseq.h	/^  void setSrcDestReg(int r)$/;"	f	class:pseq_t
setSrcDestReg	system.C	/^void  system_t::setSrcDestReg( int sd )$/;"	f	class:system_t
setStartLogging	pseq.h	/^  void setStartLogging(int r)$/;"	f	class:pseq_t
setStartLogging	system.C	/^void  system_t::setStartLogging( int sd )$/;"	f	class:system_t
setStartPC	pseq.h	/^   void setStartPC() { start_pc = m_fetch_at->pc ; }$/;"	f	class:pseq_t
setStimPipe	pseq.h	/^  void  setStimPipe( string s )$/;"	f	class:pseq_t
setStimPipe	system.C	/^void  system_t::setStimPipe( string s )$/;"	f	class:system_t
setStopPC	pseq.h	/^   void setStopPC() { stop_pc = m_fetch_at->pc ; }$/;"	f	class:pseq_t
setStuck	dynamic.h	/^  void setStuck() { m_is_stuck = true ; }$/;"	f	class:dynamic_inst_t
setStuckSrc	dynamic.h	/^  void setStuckSrc(int value) { stuck_src = value; }$/;"	f	class:dynamic_inst_t
setSymptomCausingCore	diagnosis.C	/^void multicore_diagnosis_t::setSymptomCausingCore(int core_id, uint64 trap_type ) $/;"	f	class:multicore_diagnosis_t
setSyncTarget	arf.C	/^void abstract_rf_t::setSyncTarget(reg_id_t &rid) {$/;"	f	class:abstract_rf_t
setSyncTarget	regfile.h	/^	void setSyncTarget(uint16 phy_reg, uint16 log_reg) {$/;"	f	class:physical_file_t
setTMRPhase	diagnosis.h	/^		void setTMRPhase() { $/;"	f	class:multicore_diagnosis_t
setTMRStopRequest	diagnosis.h	/^		void setTMRStopRequest() {	tmr_stop_requested = true; }$/;"	f	class:multicore_diagnosis_t
setTaken	controlop.h	/^  void              setTaken( bool taken ) {$/;"	f	class:control_inst_t
setTaken	flow.h	/^  void           setTaken( bool taken ) {$/;"	f	class:flow_inst_t
setThreadPhysAddress	pseq.C	/^void pseq_t::setThreadPhysAddress( la_t thread_phys_addr )$/;"	f	class:pseq_t
setTrapType	dynamic.h	/^  void   setTrapType( trap_type_t tt ) {$/;"	f	class:dynamic_inst_t
setTrapType	flow.h	/^  void           setTrapType( trap_type_t tt ) {$/;"	f	class:flow_inst_t
setUnready	regfile.h	/^        void setUnready(uint16 reg_no) {$/;"	f	class:physical_file_t
setValue	regfile.h	/^	void setValue(uint16 reg_no, uint64 value) {$/;"	f	class:physical_file_t
setVanilla	regbox.h	/^  inline void       setVanilla( byte_t vanilla ) {$/;"	f	class:reg_id_t
setVanillaState	regbox.h	/^  inline void       setVanillaState( uint16 cwp, uint16 gset ) {$/;"	f	class:reg_id_t
setWatchpoint	regfile.h	/^        void   setWatchpoint( uint16 reg_no ) {$/;"	f	class:physical_file_t
set_bits	cache.h	/^  uint32 set_bits;$/;"	m	class:generic_cache_template
set_cache_data	cache.C	/^set_error_t generic_cache_template<BlockType>::set_cache_data( void *ptr,$/;"	f	class:generic_cache_template
set_mask	cache.h	/^  uint32 set_mask;$/;"	m	class:generic_cache_template
setupBreakpointDispatch	system.C	/^void system_t::setupBreakpointDispatch( bool symbolTracing )$/;"	f	class:system_t
should_exit	diagnosis.h	/^	bool should_exit;$/;"	m	class:diagnosis_t
should_inject_fault	memop.h	/^  bool       should_inject_fault ;$/;"	m	class:memory_inst_t
showme_op	pstate.h	/^  static int showme_op;$/;"	m	class:pstate_t
si_page_header	statici.h	/^typedef struct si_page_header {$/;"	s
si_page_header_t	statici.h	/^} si_page_header_t;$/;"	t	typeref:struct:si_page_header
sim_last_instr	simdist12.C	/^unsigned sim_last_instr;$/;"	v
sim_last_pc	simdist12.C	/^la_t     sim_last_pc;$/;"	v
sim_status_t	system.h	/^  enum sim_status_t {$/;"	g	class:system_t
simcontinue	pstate.C	/^void  pstate_t::simcontinue( uint32 numsteps )$/;"	f	class:pstate_t
simicsDetection	pseq.C	/^void pseq_t::simicsDetection()$/;"	f	class:pseq_t
simstate_fini	simdist12.C	/^void simstate_fini( void )$/;"	f
simstate_init	simdist12.C	/^void simstate_init( void )$/;"	f
simulate	system.C	/^void system_t::simulate( uint64 instrCount )$/;"	f	class:system_t
size	diagnosis.h	/^		int size() { return llb_queue_size; }$/;"	f	class:llb_t
slice	pseq.C	/^void pseq_t::slice(dynamic_inst_t* inst)$/;"	f	class:pseq_t
slice_inst	pseq.h	/^		slice_inst(dynamic_inst_t *d) {$/;"	f	struct:pseq_t::slice_inst
slice_inst	pseq.h	/^	struct slice_inst {$/;"	s	class:pseq_t
slice_inst_t	pseq.h	/^	typedef struct slice_inst slice_inst_t ;$/;"	t	class:pseq_t	typeref:struct:pseq_t::slice_inst
source	diagnosis.h	/^	func_reg_info_t source[SI_MAX_SOURCE];$/;"	m	struct:__anon4
source	diagnosis.h	/^	register_info_t source[SI_MAX_SOURCE];$/;"	m	struct:__anon7
special_children	ddg.h	/^	ddg_node_list_t special_children ; \/\/ Nodes in subtree that have multiple parents$/;"	m	class:ddg_node_t
squash	iwindow.C	/^void iwindow_t::squash( pseq_t* the_pseq, int32 last_good, int32 &num_decoded )$/;"	f	class:iwindow_t
squashInstruction	rubycache.C	/^void rubycache_t::squashInstruction( dynamic_inst_t *inst )$/;"	f	class:rubycache_t
squashOp	decode.h	/^  void    squashOp( enum i_opcode op ) {$/;"	f	class:decode_stat_t
squash_inst_no	pseq.h	/^  uint64 squash_inst_no;$/;"	m	class:pseq_t
squash_next_instr	pseq.h	/^  bool squash_next_instr;$/;"	m	class:pseq_t
squashing_address	diagnosis.h	/^		uint64 *squashing_address;$/;"	m	class:multicore_diagnosis_t
src_producer_fault	pseq.h	/^		uint64 src_producer_fault[SI_MAX_SOURCE] ;$/;"	m	struct:pseq_t::slice_inst
src_regs	pseq.h	/^		reg_list_t src_regs ;$/;"	m	struct:pseq_t::slice_inst
stage_t	dynamic.h	/^  enum stage_t {$/;"	g	class:dynamic_inst_t
staleDataRequest	mf_api.h	/^  int (*staleDataRequest)( int cpuNumber, pa_t physicalAddr,$/;"	m	struct:mf_ruby_api
staleDataRequest	rubycache.C	/^bool rubycache_t::staleDataRequest( pa_t physical_address, char accessSize,$/;"	f	class:rubycache_t
start	inv-defs.h	/^  uint64 start;$/;"	m	struct:SVAAddr
startCheckpointing	pseq.C	/^void pseq_t::startCheckpointing()$/;"	f	class:pseq_t
startCheckpointing	system.C	/^void system_t::startCheckpointing()$/;"	f	class:system_t
startMulticoreDiagnosis	diagnosis.C	/^void multicore_diagnosis_t::startMulticoreDiagnosis()$/;"	f	class:multicore_diagnosis_t
startTime	pseq.C	/^void pseq_t::startTime( void )$/;"	f	class:pseq_t
startTimer	chain.C	/^void chain_t::startTimer( void )$/;"	f	class:chain_t
start_local_cycle	diagnosis.h	/^		uint64 *start_local_cycle;$/;"	m	class:multicore_diagnosis_t
start_pc	pseq.h	/^  my_addr_t start_pc ;$/;"	m	class:pseq_t
start_sequence_number	diagnosis.h	/^		uint64 *start_sequence_number;$/;"	m	class:multicore_diagnosis_t
stat_coherence_state_t	memstat.h	/^enum stat_coherence_state_t {$/;"	g
stateregMap	regbox.h	/^  static int16   stateregMap( byte_t reg_no, bool isPriv ) {$/;"	f	class:reg_box_t
static_inst_callback	chain.C	/^static bool static_inst_callback( void *chain_ptr, static_inst_t *s )$/;"	f	file:
static_inst_t	statici.C	/^static_inst_t::static_inst_t( pa_t physical_address, unsigned int inst )$/;"	f	class:static_inst_t
static_inst_t	statici.C	/^static_inst_t::static_inst_t( pa_t physical_address, unsigned int inst, int32 id, int core_id, fault_stats *fault_stat )$/;"	f	class:static_inst_t
static_inst_t	statici.h	/^class static_inst_t {$/;"	c
static_stat_t	sstat.C	/^static_stat_t::static_stat_t( )$/;"	f	class:static_stat_t
static_stat_t	sstat.h	/^class static_stat_t {$/;"	c
steady_state	pseq.h	/^  int steady_state;$/;"	m	class:pseq_t
stepFaultId	pseq.h	/^	uint64 stepFaultId() { pseq_fault_id++ ; return pseq_fault_id ;} $/;"	f	class:pseq_t
stepInorder	pseq.C	/^void pseq_t::stepInorder( void )$/;"	f	class:pseq_t
stepInorder	system.C	/^void   system_t::stepInorder( uint64 instrCount )$/;"	f	class:system_t
stepInorderNumber	pseq.h	/^  uint64       stepInorderNumber( void ) {$/;"	f	class:pseq_t
stepSequenceNumber	pseq.h	/^  uint64       stepSequenceNumber( void ) {$/;"	f	class:pseq_t
stepper_breakpoint	hfa.C	/^stepper_breakpoint(void *data, integer_t category, integer_t parameter)$/;"	f	file:
stopCore	diagnosis.C	/^void multicore_diagnosis_t::stopCore( int core_id)$/;"	f	class:multicore_diagnosis_t
stopDiagnosis	diagnosis.h	/^		void stopDiagnosis() { stop_diagnosis = true; }$/;"	f	class:multicore_diagnosis_t
stopTime	pseq.C	/^void pseq_t::stopTime( void )$/;"	f	class:pseq_t
stop_diagnosis	diagnosis.h	/^		bool stop_diagnosis;$/;"	m	class:multicore_diagnosis_t
stop_pc	pseq.h	/^  my_addr_t stop_pc ;$/;"	m	class:pseq_t
stopwatch_t	stopwatch.h	/^  stopwatch_t( int cpuid ) {$/;"	f	class:stopwatch_t
stopwatch_t	stopwatch.h	/^class stopwatch_t {$/;"	c
storeDataToCache	memop.C	/^store_inst_t::storeDataToCache( void ) {$/;"	f	class:store_inst_t
storeDataWakeup	memop.C	/^store_inst_t::storeDataWakeup( void ) {$/;"	f	class:store_inst_t
storeSearch	lsq.C	/^void lsq_t::storeSearch( store_inst_t *memop )$/;"	f	class:lsq_t
store_inst_t	memop.C	/^store_inst_t::store_inst_t( static_inst_t *s_inst, $/;"	f	class:store_inst_t
store_inst_t	memop.h	/^class store_inst_t : public memory_inst_t {$/;"	c
stream_manager	mshr.h	/^  replacement_manager_t<stream_t> stream_manager;$/;"	m	class:mshr_t
stream_t	mshr.C	/^stream_t::stream_t( void ) {$/;"	f	class:stream_t
stream_t	mshr.h	/^class stream_t {$/;"	c
stuckSrc	diagnosis.h	/^	uint16 stuckSrc;$/;"	m	struct:__anon7
stuck_at	fault.h	/^		int stuck_at ;$/;"	m	class:Fault
stuck_src	dynamic.h	/^  int stuck_src;$/;"	m	class:dynamic_inst_t
successOp	decode.h	/^  void    successOp( enum i_opcode op ) {$/;"	f	class:decode_stat_t
successorCount	sstat.C	/^int32 static_stat_t::successorCount( void )$/;"	f	class:static_stat_t
suspect_found	diagnosis.h	/^		int suspect_found;$/;"	m	class:multicore_diagnosis_t
svaAddrMap	pseq.h	/^  SVAAddrMap svaAddrMap;$/;"	m	class:pseq_t
symptomAgain	diagnosis.h	/^	void symptomAgain(uint64 trap_inst, int traptype) {$/;"	f	class:diagnosis_t
symptomDetected	pseq.C	/^void pseq_t::symptomDetected(int traptype)$/;"	f	class:pseq_t
symptomSeen	pseq.h	/^  void symptomSeen() { symptom_seen = true ; }$/;"	f	class:pseq_t
symptom_causing_core	diagnosis.h	/^		int symptom_causing_core;$/;"	m	class:multicore_diagnosis_t
symptom_core_logging_phase	diagnosis.h	/^		int symptom_core_logging_phase;$/;"	m	class:multicore_diagnosis_t
symptom_raised	diagnosis.h	/^		bool *symptom_raised;$/;"	m	class:multicore_diagnosis_t
symptom_raised_last_replay	diagnosis.h	/^		bool symptom_raised_last_replay;$/;"	m	class:multicore_diagnosis_t
symptom_raised_logging	diagnosis.h	/^		bool *symptom_raised_logging;$/;"	m	class:multicore_diagnosis_t
symptom_seen	pseq.h	/^  bool symptom_seen ;$/;"	m	class:pseq_t
sync	arf.C	/^void    abstract_rf_t::sync( reg_id_t &rid, pstate_t *state,$/;"	f	class:abstract_rf_t
sync	arf.C	/^void arf_cc_t::sync( reg_id_t &rid, pstate_t *state,$/;"	f	class:arf_cc_t
sync	arf.C	/^void arf_control_t::sync( reg_id_t &rid, pstate_t *state,$/;"	f	class:arf_control_t
sync	arf.C	/^void arf_double_t::sync( reg_id_t &rid, pstate_t *state,$/;"	f	class:arf_double_t
sync	arf.C	/^void arf_int_global_t::sync( reg_id_t &rid, pstate_t *state,$/;"	f	class:arf_int_global_t
sync	arf.C	/^void arf_int_t::sync( reg_id_t &rid, pstate_t *state,$/;"	f	class:arf_int_t
syncAllState	pseq.C	/^void pseq_t::syncAllState( check_result_t *result, mstate_t *mstate, bool init )$/;"	f	class:pseq_t
sync_target	regfile.h	/^		uint16     *sync_target;$/;"	m	class:physical_file_t
synce	arf.h	/^  void    synce( reg_id_t &rid, pstate_t *state, check_result_t *result, bool init ) {}$/;"	f	class:arf_none_t
sys_stat_t	sysstat.C	/^sys_stat_t::sys_stat_t( int32 numProcs)$/;"	f	class:sys_stat_t
sys_stat_t	sysstat.h	/^class sys_stat_t {$/;"	c
systemExit	system.C	/^void system_t::systemExit( void )$/;"	f	class:system_t
system_break_handler	system.C	/^static void system_break_handler( void *system_obj, uint64 access_type,$/;"	f	file:
system_breakpoint	system.C	/^system_breakpoint( void *data, conf_object_t *cpu, integer_t parameter )$/;"	f	file:
system_exception_handler	system.C	/^static void system_exception_handler( void *obj, conf_object_t *proc,$/;"	f	file:
system_exception_tracer	system.C	/^static void system_exception_tracer( void *obj, conf_object_t *proc,$/;"	f	file:
system_memory_operation_mlp_trace	system.C	/^cycles_t system_memory_operation_mlp_trace( conf_object_t *obj,$/;"	f
system_memory_operation_stats	system.C	/^cycles_t system_memory_operation_stats( conf_object_t *obj,$/;"	f
system_memory_operation_symbol_mode	system.C	/^cycles_t system_memory_operation_symbol_mode( conf_object_t *obj,$/;"	f
system_memory_operation_trace	system.C	/^cycles_t system_memory_operation_trace( conf_object_t *obj,$/;"	f
system_memory_operation_warmup	system.C	/^cycles_t system_memory_operation_warmup( conf_object_t *obj,$/;"	f
system_memory_snoop	system.C	/^cycles_t system_memory_snoop( conf_object_t *obj,$/;"	f
system_mlp_trace_tick	system.C	/^void system_mlp_trace_tick( conf_object_t* obj, lang_void* arg )$/;"	f
system_post_tick	system.C	/^void system_post_tick( void )$/;"	f
system_t	system.C	/^system_t::system_t( const char *configurationFile )$/;"	f	class:system_t
system_t	system.h	/^class system_t {$/;"	c
system_transaction_callback	system.C	/^static void system_transaction_callback( void *system_obj, conf_object_t *cpu,$/;"	f	file:
tail_waiter_t	wait.h	/^  tail_waiter_t(wait_list_t *wl) {$/;"	f	class:tail_waiter_t
tail_waiter_t	wait.h	/^class tail_waiter_t : public waiter_t {$/;"	c
takeCheckpoint	system.C	/^void system_t::takeCheckpoint(int core_id)$/;"	f	class:system_t
takeChkpt	pseq.C	/^void pseq_t::takeChkpt(dynamic_inst_t *instruction)$/;"	f	class:pseq_t
takeProcessorCheckpoint	pseq.C	/^void pseq_t::takeProcessorCheckpoint()$/;"	f	class:pseq_t
takeTrap	pseq.C	/^pseq_t::takeTrap( dynamic_inst_t *instruction, abstract_pc_t *inorder_at,$/;"	f	class:pseq_t
takingInterrupt	pseq.h	/^  void takingInterrupt(int p) { in_interrupt = true ; interrupt_priv = p ; }$/;"	f	class:pseq_t
terminating_instr	diagnosis.h	/^	int terminating_instr;$/;"	m	class:diagnosis_t
testSourceReadiness	dynamic.C	/^dynamic_inst_t::testSourceReadiness() { $/;"	f	class:dynamic_inst_t
threadTableWalker	sysstat.C	/^static void threadTableWalker( histogram_t *h, int PC, int accesses )$/;"	f	file:
thread_stat_t	threadstat.C	/^thread_stat_t::thread_stat_t( la_t address, int32 pid, int32 cpuid )$/;"	f	class:thread_stat_t
thread_stat_t	threadstat.h	/^class thread_stat_t {$/;"	c
time_from_rollback	pseq.h	/^  uint64 time_from_rollback;$/;"	m	class:pseq_t
tlb_data	pseq.h	/^  tlb_data_t *tlb_data[NUM_CHKPTS];$/;"	m	class:pseq_t
tlb_data_t	pseq.h	/^} tlb_data_t;$/;"	t	typeref:struct:__anon22
tlb_reg	diagnosis.h	/^	attr_value_t tlb_reg[49];$/;"	m	struct:__anon11
tlb_reg_t	pseq.h	/^enum tlb_reg_t {$/;"	g
tlb_state	diagnosis.h	/^		tlb_state_t *tlb_state;$/;"	m	class:multicore_diagnosis_t
tlb_state_main	diagnosis.h	/^		tlb_state_t *tlb_state_main;$/;"	m	class:multicore_diagnosis_t
tlb_state_previous	diagnosis.h	/^		tlb_state_t *tlb_state_previous;$/;"	m	class:multicore_diagnosis_t
tlb_state_t	diagnosis.h	/^} tlb_state_t;$/;"	t	typeref:struct:__anon11
tmrPhase	diagnosis.C	/^void multicore_diagnosis_t::tmrPhase(int core_id)$/;"	f	class:multicore_diagnosis_t
tmrPolicy	diagnosis.C	/^void multicore_diagnosis_t::tmrPolicy()$/;"	f	class:multicore_diagnosis_t
tmr_phase	diagnosis.h	/^		bool tmr_phase;$/;"	m	class:multicore_diagnosis_t
tmr_stop_requested	diagnosis.h	/^		bool tmr_stop_requested;$/;"	m	class:multicore_diagnosis_t
total_logging_instructions	diagnosis.h	/^		uint64 *total_logging_instructions;$/;"	m	class:multicore_diagnosis_t
total_logging_latency_cycles	diagnosis.h	/^		uint64 total_logging_latency_cycles;$/;"	m	class:multicore_diagnosis_t
total_num_SVA_access	pseq.h	/^  uint64 total_num_SVA_access;$/;"	m	class:pseq_t
total_num_SVA_access_faulty	pseq.h	/^  uint64 total_num_SVA_access_faulty; $/;"	m	class:pseq_t
total_num_branch_instr	diagnosis.h	/^		int *total_num_branch_instr;$/;"	m	class:multicore_diagnosis_t
total_num_load_instr	diagnosis.h	/^		int *total_num_load_instr;$/;"	m	class:multicore_diagnosis_t
total_num_store_instr	diagnosis.h	/^		int *total_num_store_instr;$/;"	m	class:multicore_diagnosis_t
total_number_processors	simdist12.C	/^unsigned total_number_processors;$/;"	v
touch	histogram.C	/^int histogram_t::touch(histo_x_t X, histo_y_t Y) {$/;"	f	class:histogram_t
trace	pseq.h	/^    pa_watchpoint, trace, va_watchpoint, num_tlb_regs$/;"	e	enum:tlb_reg_t
trace_dec	diagnosis.h	/^	int trace_dec(int index) {$/;"	f	class:diagnosis_t
trace_head_ptr	diagnosis.h	/^	int trace_head_ptr;$/;"	m	class:diagnosis_t
trace_inc	diagnosis.h	/^	int trace_inc(int index) {$/;"	f	class:diagnosis_t
trace_tail_ptr	diagnosis.h	/^	int trace_tail_ptr;$/;"	m	class:diagnosis_t
track	pseq.h	/^	bool track;$/;"	m	class:pseq_t
trackCycle	pseq.h	/^  void trackCycle(uint64 cur_cycle, uint64 seq_num, bool priv, bool isLoopInstr)$/;"	f	class:pseq_t
trans_fault_injected	pseq.h	/^  bool trans_fault_injected;$/;"	m	class:pseq_t
transferMismatchInfo	dynamic.C	/^void dynamic_inst_t::transferMismatchInfo(instr_diag_info_t &i_info)$/;"	f	class:dynamic_inst_t
transferMismatchInfo	dynamic.C	/^void dynamic_inst_t::transferMismatchInfo(instruction_information_t &i_info)$/;"	f	class:dynamic_inst_t
translate	pstate.C	/^bool pstate_t::translate( ireg_t log_addr, int size, pa_t &phys_addr )$/;"	f	class:pstate_t
translateAddress	dtlb.C	/^bool dtlb_t::translateAddress( la_t va, context_id_t context, $/;"	f	class:dtlb_t
translateInstruction	pseq.C	/^bool pseq_t::translateInstruction( ireg_t log_addr, int size, pa_t &phys_addr)$/;"	f	class:pseq_t
translateInstruction	pstate.C	/^bool pstate_t::translateInstruction( ireg_t log_addr, int size,$/;"	f	class:pstate_t
trap_cycle	pseq.h	/^  uint64 trap_cycle;$/;"	m	struct:__anon20
trap_handler_pc	pseq.h	/^  la_t   trap_handler_pc;$/;"	m	struct:__anon20
trap_info	pseq.h	/^} trap_info;$/;"	t	typeref:struct:__anon20
trap_level	pseq.h	/^  ireg_t trap_level;$/;"	m	struct:__anon20
trap_num_menomic	pstate.C	/^const char *pstate_t::trap_num_menomic( trap_type_t traptype ) {$/;"	f	class:pstate_t
trap_type	pseq.h	/^  uint16 trap_type;$/;"	m	struct:__anon20
treatStuckInstr	diagnosis.C	/^void diagnosis_t::treatStuckInstr(dynamic_inst_t *d) $/;"	f	class:diagnosis_t
triggerLastReplay	diagnosis.C	/^void multicore_diagnosis_t::triggerLastReplay()$/;"	f	class:multicore_diagnosis_t
triggerLoggingPhase	diagnosis.C	/^void multicore_diagnosis_t::triggerLoggingPhase()$/;"	f	class:multicore_diagnosis_t
triggerTMRPhase	diagnosis.C	/^void multicore_diagnosis_t::triggerTMRPhase()$/;"	f	class:multicore_diagnosis_t
trigger_logging_step	diagnosis.h	/^		bool *trigger_logging_step;$/;"	m	class:multicore_diagnosis_t
trigger_tmr_step	diagnosis.h	/^		bool *trigger_tmr_step;$/;"	m	class:multicore_diagnosis_t
type	pseq.h	/^		dyn_execute_type_t type ;$/;"	m	struct:pseq_t::slice_inst
uMaskedALU	dynamic.h	/^  bool uMaskedALU;$/;"	m	class:dynamic_inst_t
uarch_info	diagnosis.h	/^	uarch_info_t uarch_info;$/;"	m	struct:__anon7
uarch_info_t	diagnosis.h	/^} uarch_info_t;$/;"	t	typeref:struct:__anon5
uchar	inv-defs.h	/^typedef unsigned char uchar;$/;"	t
uint	inv-defs.h	/^typedef unsigned int uint;$/;"	t
uint64_cmp	ddg.h	/^struct uint64_cmp {$/;"	s
uint64_cmp	pseq.h	/^	struct uint64_cmp {$/;"	s	class:pseq_t
uint64_list_t	pseq.h	/^	typedef vector<uint64> uint64_list_t ;$/;"	t	class:pseq_t
uint64_set_t	pseq.h	/^	typedef set<uint64, uint64_cmp> uint64_set_t ;$/;"	t	class:pseq_t
uint_32	regfile.h	/^    uint32   uint_32;$/;"	m	union:my_register_u
uint_64	regfile.h	/^    uint64   uint_64;$/;"	m	union:my_register_u
ulong	inv-defs.h	/^typedef unsigned long ulong;$/;"	t
ulongChange	inv-defs.h	/^    unsigned long long ulongChange;$/;"	m	union:Invariant::__anon15
ulongChange	inv-defs.h	/^    unsigned long long ulongChange;$/;"	m	union:MulRangeInvariant::__anon18
ulongMax	inv-defs.h	/^    unsigned long long ulongMax;$/;"	m	union:Invariant::__anon14
ulongMax	inv-defs.h	/^    unsigned long long ulongMax[MAX_NUM_RANGES];$/;"	m	union:MulRangeInvariant::__anon17
ulongMin	inv-defs.h	/^    unsigned long long ulongMin;$/;"	m	union:Invariant::__anon13
ulongMin	inv-defs.h	/^    unsigned long long ulongMin[MAX_NUM_RANGES];$/;"	m	union:MulRangeInvariant::__anon16
ulongValue	inv-defs.h	/^  unsigned long long ulongValue;$/;"	m	union:__anon19
unSetCorrupted	arf.C	/^void abstract_rf_t::unSetCorrupted( reg_id_t &rid )$/;"	f	class:abstract_rf_t
unSetCorrupted	arf.C	/^void arf_double_t::unSetCorrupted( reg_id_t &rid )$/;"	f	class:arf_double_t
unSetCorrupted	arf.h	/^  inline void unSetCorrupted( reg_id_t &rid ) $/;"	f	class:arf_control_t
unSetCorrupted	regfile.h	/^	void unSetCorrupted(uint16 reg_no) {$/;"	f	class:physical_file_t
uncheckedPrint	pseq.C	/^void pseq_t::uncheckedPrint( void )$/;"	f	class:pseq_t
uncheckedRetire	pseq.C	/^bool pseq_t::uncheckedRetire( dynamic_inst_t *dinstr )$/;"	f	class:pseq_t
uncheckedValueForward	pseq.C	/^memory_inst_t *pseq_t::uncheckedValueForward( pa_t phys_addr, int my_size )$/;"	f	class:pseq_t
unmarkEvent	dynamic.h	/^  void   unmarkEvent(inst_event_t e) { m_events &= ~e; }$/;"	f	class:dynamic_inst_t
unmarkEvent	flow.h	/^  void   unmarkEvent(flow_event_t e) { m_events &= ~e; }$/;"	f	class:flow_inst_t
unread_addr	pseq.h	/^	addr_list_t unread_addr ;$/;"	m	class:pseq_t
unread_regs	pseq.h	/^	reg_list_t unread_regs ;$/;"	m	class:pseq_t
unseTMRStopRequest	diagnosis.h	/^		void unseTMRStopRequest() {	tmr_stop_requested = false; }$/;"	f	class:multicore_diagnosis_t
unsetLastReplay	diagnosis.h	/^		void unsetLastReplay(){ last_replay = false; }$/;"	f	class:multicore_diagnosis_t
unsetLoggingStep	diagnosis.h	/^		void unsetLoggingStep(){ logging_step = false; }$/;"	f	class:multicore_diagnosis_t
unsetTMRPhase	diagnosis.h	/^		void unsetTMRPhase() { tmr_phase = false; }$/;"	f	class:multicore_diagnosis_t
unstall	pstate.h	/^  void    unstall( void ) {$/;"	f	class:pstate_t
unstallFetch	pseq.C	/^void pseq_t::unstallFetch( void )$/;"	f	class:pseq_t
updateBin	diagnosis.C	/^void diagnosis_t::updateBin(loc_id_t target_bin, int unit, int unit_num) $/;"	f	class:diagnosis_t
updateDDGStats	pseq.C	/^void pseq_t::updateDDGStats(uint64 pc, uint64_list_t &L)$/;"	f	class:pseq_t
updateFutureCulprit	diagnosis.C	/^void diagnosis_t::updateFutureCulprit(reg_loc_t&reg_loc) {$/;"	f	class:diagnosis_t
updateInstrInfo	pseq.C	/^void pseq_t::updateInstrInfo(instruction_information_t&instr_info, dynamic_inst_t*d)$/;"	f	class:pseq_t
updateInstructionState	pseq.C	/^void pseq_t::updateInstructionState( dynamic_inst_t *dinstr, bool init )$/;"	f	class:pseq_t
updateInstructionState	pseq.C	/^void pseq_t::updateInstructionState( flow_inst_t *flow_inst, bool init )$/;"	f	class:pseq_t
updateOnly	dynamic.h	/^  virtual bool updateOnly() { return false; }$/;"	f	class:dynamic_inst_t
updateOnly	memop.h	/^	bool updateOnly() { return update_only;}$/;"	f	class:load_inst_t
updateOnly	memop.h	/^  bool updateOnly() { return update_only;}$/;"	f	class:atomic_inst_t
updateReadPointer	diagnosis.C	/^void llb_t::updateReadPointer(byte_t index)$/;"	f	class:llb_t
updateRegLoc	diagnosis.h	/^	void updateRegLoc(reg_loc_t& reg_loc, int index, bool isSource, int reg_idx) {$/;"	f	class:diagnosis_t
updateSimicsReg	arf.C	/^void    abstract_rf_t::updateSimicsReg( reg_id_t &rid, pstate_t *state, uint64 value)$/;"	f	class:abstract_rf_t
updateSimicsReg	arf.C	/^void    arf_double_t::updateSimicsReg( reg_id_t &rid, pstate_t *state, uint64 value)$/;"	f	class:arf_double_t
updateSimicsReg	arf.C	/^void arf_cc_t::updateSimicsReg(reg_id_t & rid, pstate_t *state, uint64 value)$/;"	f	class:arf_cc_t
updateSimicsReg	arf.C	/^void arf_int_global_t::updateSimicsReg(reg_id_t &rid, pstate_t *state, uint64 value)$/;"	f	class:arf_int_global_t
updateSimicsReg	arf.C	/^void arf_int_t::updateSimicsReg(reg_id_t &rid, pstate_t *state, uint64 value)$/;"	f	class:arf_int_t
updateSimicsReg	arf.C	/^void arf_single_t::updateSimicsReg(reg_id_t &rid, pstate_t *state, uint64 value)$/;"	f	class:arf_single_t
updateSuspects	diagnosis.C	/^bool diagnosis_t::updateSuspects(reg_loc_t&stuck_reg)$/;"	f	class:diagnosis_t
update_only	checkresult.h	/^  bool update_only;$/;"	m	class:check_result_t
update_only	memop.h	/^	bool update_only;$/;"	m	class:atomic_inst_t
update_only	memop.h	/^	bool update_only;$/;"	m	class:load_inst_t
user_data	system.h	/^  void          *user_data;$/;"	m	struct:breakpoint_action
ushort	inv-defs.h	/^typedef unsigned short ushort;$/;"	t
v_address	dtlb.h	/^  la_t               v_address;$/;"	m	class:dtlb_entry_t
va_watchpoint	pseq.h	/^    pa_watchpoint, trace, va_watchpoint, num_tlb_regs$/;"	e	enum:tlb_reg_t
validAccessSize	statici.C	/^static_inst_t::validAccessSize(byte_t access_size) {$/;"	f	class:static_inst_t
validRtype	statici.C	/^static_inst_t::validRtype() {$/;"	f	class:static_inst_t
validTypes	statici.C	/^static_inst_t::validTypes() {$/;"	f	class:static_inst_t
validateMapping	regbox.C	/^reg_box_t::validateMapping( uint32 id, iwindow_t &iwin )$/;"	f	class:reg_box_t
validateRecovery	pseq.C	/^void pseq_t::validateRecovery() $/;"	f	class:pseq_t
validateTrace	pseq.C	/^void pseq_t::validateTrace( void )$/;"	f	class:pseq_t
validateValuePrediction	memop.C	/^bool load_inst_t::validateValuePrediction( void )$/;"	f	class:load_inst_t
value	diagnosis.h	/^	ireg_t value;$/;"	m	struct:__anon3
value	diagnosis.h	/^	ireg_t value;$/;"	m	struct:__anon6
value	diagnosis.h	/^	ireg_t value[SI_MAX_DEST];$/;"	m	struct:func_inst_info
value	diagnosis.h	/^	uint64 value;	$/;"	m	struct:__anon12
value	diagnosis.h	/^	vector <uint64> value;$/;"	m	struct:load_info
value_watch_list	diagnosis.h	/^	set<ireg_t> value_watch_list;$/;"	m	class:diagnosis_t
verbose	checkresult.h	/^  bool verbose;$/;"	m	class:check_result_t
verify	lsq.C	/^void lsq_t::verify(memory_inst_t *lsq_slice, bool halt_on_error) {$/;"	f	class:lsq_t
verifyQueues	lsq.h	/^  void verifyQueues( void ) {$/;"	f	class:lsq_t
vfprintf	simdist12.C	602;"	d	file:
vfprintf	simdist12.C	608;"	d	file:
vfprintf	simdist12.C	614;"	d	file:
vfprintf	simdist12.C	620;"	d	file:
waitResult	arf.C	/^void    abstract_rf_t::waitResult( reg_id_t &rid, dynamic_inst_t *d_instr )$/;"	f	class:abstract_rf_t
waitResult	arf.C	/^void    arf_container_t::waitResult( reg_id_t &rid, dynamic_inst_t *d_instr )$/;"	f	class:arf_container_t
waitResult	arf.C	/^void    arf_control_t::waitResult( reg_id_t &rid, dynamic_inst_t *d_instr )$/;"	f	class:arf_control_t
waitResult	arf.C	/^void    arf_double_t::waitResult( reg_id_t &rid, dynamic_inst_t *d_instr )$/;"	f	class:arf_double_t
waitResult	arf.h	/^  void    waitResult( reg_id_t &rid, dynamic_inst_t *d_instr ) {}$/;"	f	class:arf_none_t
waitResult	flatarf.C	/^void    flat_rf_t::waitResult( reg_id_t &rid, dynamic_inst_t *d_instr ) {$/;"	f	class:flat_rf_t
waitResult	regfile.C	/^physical_file_t::waitResult( uint16 reg_no, dynamic_inst_t *d_instr )$/;"	f	class:physical_file_t
wait_list	regfile.h	/^        wait_list_t wait_list;$/;"	m	class:physical_reg_t
wait_list_t	wait.h	/^  wait_list_t() { wl_reset(); }$/;"	f	class:wait_list_t
wait_list_t	wait.h	/^class wait_list_t {$/;"	c
waiter_t	wait.h	/^  waiter_t() : wait_list_t() { prev = NULL; priority = 0; }$/;"	f	class:waiter_t
waiter_t	wait.h	/^class waiter_t : public wait_list_t {$/;"	c
wakeDependents	arf.C	/^void abstract_rf_t::wakeDependents(reg_id_t &rid) {$/;"	f	class:abstract_rf_t
wakeDependents	arf.C	/^void arf_double_t::wakeDependents(reg_id_t &rid) {$/;"	f	class:arf_double_t
wakeDependents	regfile.h	/^	void wakeDependents (uint16 reg_no) {$/;"	f	class:physical_file_t
wake_dep	regfile.h	/^        bool wake_dep;$/;"	m	class:physical_file_t
wakeupDependentLoads	memop.C	/^store_inst_t::wakeupDependentLoads() {$/;"	f	class:store_inst_t
wakeupOverlapLoads	memop.C	/^store_inst_t::wakeupOverlapLoads() {$/;"	f	class:store_inst_t
walk	histogram.C	/^int histogram_t::walk( void (*f)(histogram_t *, int, int) )$/;"	f	class:histogram_t
walkList	pipepool.C	/^pipestate_t *pipepool_t::walkList( pipestate_t *state )$/;"	f	class:pipepool_t
walkMap	ipage.C	/^bool ipage_t::walkMap( void *user_data, ipage_callback_t si_callback )$/;"	f	class:ipage_t
walkMap	ipagemap.C	/^bool  ipagemap_t::walkMap( void *user_data, ipage_callback_t si_callback )$/;"	f	class:ipagemap_t
warmupCache	pseq.C	/^void pseq_t::warmupCache( memory_transaction_t *mem_op )$/;"	f	class:pseq_t
way_counter	pseq.h	/^  int      way_counter;$/;"	m	class:pseq_t
win_id	diagnosis.h	/^    uint16 win_id;$/;"	m	struct:__anon2
win_id	diagnosis.h	/^    uint16 win_id;$/;"	m	struct:__anon5
win_id	pseq.h	/^    uint16 win_id;$/;"	m	struct:__anon23
wl_reset	wait.h	/^  void wl_reset( void ) { next = NULL; }$/;"	f	class:wait_list_t
write	memstat.C	/^void mem_stat_t::write( int32 thread_id, la_t virtual_address, pa_t address ,$/;"	f	class:mem_stat_t
write16	ptrace.C	/^bool ptrace_t::write16( uint16 data )$/;"	f	class:ptrace_t
write32	ptrace.C	/^bool ptrace_t::write32( uint32 data )$/;"	f	class:ptrace_t
write64	ptrace.C	/^bool ptrace_t::write64( uint64 data )$/;"	f	class:ptrace_t
write8	ptrace.C	/^bool ptrace_t::write8( uint8 data )$/;"	f	class:ptrace_t
writeBackStoreValue	dynamic.h	/^  virtual void writeBackStoreValue() { }$/;"	f	class:dynamic_inst_t
writeBackStoreValue	memop.C	/^void atomic_inst_t::writeBackStoreValue()$/;"	f	class:atomic_inst_t
writeBackStoreValue	memop.C	/^void store_inst_t::writeBackStoreValue()$/;"	f	class:store_inst_t
writeBranchNextFile	pseq.C	/^bool pseq_t::writeBranchNextFile( void )$/;"	f	class:pseq_t
writeBranchNextFile	system.C	/^bool system_t::writeBranchNextFile( void )$/;"	f	class:system_t
writeBranchStep	pseq.C	/^void pseq_t::writeBranchStep( void )$/;"	f	class:pseq_t
writeBranchStep	system.C	/^void system_t::writeBranchStep( void )$/;"	f	class:system_t
writeCheckpoint	pseq.C	/^void  pseq_t::writeCheckpoint( char *checkpointName )$/;"	f	class:pseq_t
writeConfiguration	system.C	/^void system_t::writeConfiguration( char *configurationName )$/;"	f	class:system_t
writeDecodeMap	arf.C	/^void    abstract_rf_t::writeDecodeMap( reg_id_t &rid )$/;"	f	class:abstract_rf_t
writeDecodeMap	arf.C	/^void    arf_container_t::writeDecodeMap( reg_id_t &rid )$/;"	f	class:arf_container_t
writeDecodeMap	arf.C	/^void    arf_control_t::writeDecodeMap( reg_id_t &rid )$/;"	f	class:arf_control_t
writeDecodeMap	arf.C	/^void    arf_double_t::writeDecodeMap( reg_id_t &rid )$/;"	f	class:arf_double_t
writeDecodeMap	arf.h	/^  void    writeDecodeMap( reg_id_t &rid ) {}$/;"	f	class:arf_none_t
writeDecodeMap	flatarf.C	/^void    flat_rf_t::writeDecodeMap( reg_id_t &rid ) {$/;"	f	class:flat_rf_t
writeFloat32	arf.C	/^void    abstract_rf_t::writeFloat32( reg_id_t &rid, float32 value )$/;"	f	class:abstract_rf_t
writeFloat32	arf.C	/^void    arf_single_t::writeFloat32( reg_id_t &rid, float32 value )$/;"	f	class:arf_single_t
writeFloat32	flatarf.C	/^void      flat_single_t::writeFloat32( reg_id_t &rid, float32 value )$/;"	f	class:flat_single_t
writeFloat64	arf.C	/^void    abstract_rf_t::writeFloat64( reg_id_t &rid, float64 value )$/;"	f	class:abstract_rf_t
writeFloat64	arf.C	/^void    arf_double_t::writeFloat64( reg_id_t &rid, float64 value )$/;"	f	class:arf_double_t
writeFloat64	flatarf.C	/^void      flat_double_t::writeFloat64( reg_id_t &rid, float64 value )$/;"	f	class:flat_double_t
writeInstruction	ptrace.C	/^bool ptrace_t::writeInstruction( uint8 pid, uint32 instruction )$/;"	f	class:ptrace_t
writeInstructionTable	pseq.C	/^void pseq_t::writeInstructionTable( char *imapFileName )$/;"	f	class:pseq_t
writeInt64	arf.C	/^void      arf_container_t::writeInt64( reg_id_t &rid, ireg_t value )$/;"	f	class:arf_container_t
writeInt64	arf.C	/^void     arf_int_global_t::writeInt64( reg_id_t &rid, ireg_t value )$/;"	f	class:arf_int_global_t
writeInt64	arf.C	/^void    abstract_rf_t::writeInt64( reg_id_t &rid, ireg_t value )$/;"	f	class:abstract_rf_t
writeInt64	arf.C	/^void    arf_control_t::writeInt64( reg_id_t &rid, ireg_t value )$/;"	f	class:arf_control_t
writeInt64	arf.C	/^void    arf_double_t::writeInt64( reg_id_t &rid, ireg_t value )$/;"	f	class:arf_double_t
writeInt64	arf.h	/^  void    writeInt64( reg_id_t &rid, ireg_t value ) {}$/;"	f	class:arf_none_t
writeInt64	flatarf.C	/^void      flat_double_t::writeInt64( reg_id_t &rid, ireg_t value )$/;"	f	class:flat_double_t
writeInt64	flatarf.C	/^void     flat_int_global_t::writeInt64( reg_id_t &rid, ireg_t value )$/;"	f	class:flat_int_global_t
writeInt64	flatarf.C	/^void    flat_container_t::writeInt64( reg_id_t &rid, ireg_t value )$/;"	f	class:flat_container_t
writeInt64	flatarf.C	/^void    flat_control_t::writeInt64( reg_id_t &rid, ireg_t value )$/;"	f	class:flat_control_t
writeInt64	flatarf.C	/^void    flat_rf_t::writeInt64( reg_id_t &rid, ireg_t value )$/;"	f	class:flat_rf_t
writeMemory	pstate.C	/^bool  pstate_t::writeMemory( ireg_t phys_addr, int size, ireg_t *value )$/;"	f	class:pstate_t
writeMemoryOp	ptrace.C	/^bool ptrace_t::writeMemoryOp( uint8 pid, uint8 req_type, uint64 physical_addr,$/;"	f	class:ptrace_t
writePage	ipage.C	/^bool ipage_t::writePage( FILE *fp )$/;"	f	class:ipage_t
writePhysicalMemory	pseq.C	/^bool pseq_t::writePhysicalMemory( pa_t phys_addr, int size, ireg_t *result_reg )$/;"	f	class:pseq_t
writeRegister	arf.C	/^void abstract_rf_t::writeRegister( reg_id_t &rid, my_register_t value )$/;"	f	class:abstract_rf_t
writeRegister	arf.C	/^void arf_double_t::writeRegister( reg_id_t &rid, my_register_t value )$/;"	f	class:arf_double_t
writeRetireMap	arf.C	/^void    abstract_rf_t::writeRetireMap( reg_id_t &rid )$/;"	f	class:abstract_rf_t
writeRetireMap	arf.C	/^void    arf_container_t::writeRetireMap( reg_id_t &rid )$/;"	f	class:arf_container_t
writeRetireMap	arf.C	/^void    arf_control_t::writeRetireMap( reg_id_t &rid )$/;"	f	class:arf_control_t
writeRetireMap	arf.C	/^void    arf_double_t::writeRetireMap( reg_id_t &rid )$/;"	f	class:arf_double_t
writeRetireMap	arf.h	/^  void    writeRetireMap( reg_id_t &rid ) {}$/;"	f	class:arf_none_t
writeRetireMap	flatarf.C	/^void    flat_rf_t::writeRetireMap( reg_id_t &rid ) {$/;"	f	class:flat_rf_t
writeSkipTraceStep	pseq.C	/^void pseq_t::writeSkipTraceStep( void )$/;"	f	class:pseq_t
writeSkipTraceStep	system.C	/^void system_t::writeSkipTraceStep( void )$/;"	f	class:system_t
writeTrace	ptrace.C	/^void ptrace_t::writeTrace( const char *filename )$/;"	f	class:ptrace_t
writeTraceMemop	pseq.C	/^void pseq_t::writeTraceMemop( transaction_t *trans )$/;"	f	class:pseq_t
writeTraceStep	pseq.C	/^void pseq_t::writeTraceStep( void )$/;"	f	class:pseq_t
writeTraceStep	system.C	/^void system_t::writeTraceStep( void )$/;"	f	class:system_t
writeTransaction	ptrace.C	/^void pt_memory_waiter_t::writeTransaction( void )$/;"	f	class:pt_memory_waiter_t
writeTranslation	dtlb.C	/^void dtlb_t::writeTranslation( FILE *fp )$/;"	f	class:dtlb_t
writeValue	flow.h	/^  void        writeValue( ireg_t value ) {$/;"	f	class:flow_inst_t
writeValue	memop.h	/^  void writeValue( ireg_t value ) {$/;"	f	class:store_inst_t
write_hit	cache.h	/^  uint64 write_hit;$/;"	m	class:cache_t
write_miss	cache.h	/^  uint64 write_miss;$/;"	m	class:cache_t
write_prefetches	cache.h	/^  uint64 write_prefetches;$/;"	m	class:cache_t
writebacks	cache.h	/^  uint64 writebacks;$/;"	m	class:cache_t
writes	cache.h	/^  uint64 writes;$/;"	m	class:cache_t
x	histogram.h	/^  histo_x_t x;           \/* X value *\/$/;"	m	struct:hash_ent
y	histogram.h	/^  histo_y_t y;           \/* Y value *\/$/;"	m	struct:hash_ent
~DecodeFault	decodefault.h	/^		~DecodeFault() {}	$/;"	f	class:DecodeFault
~Fault	fault.h	/^		~Fault() {}$/;"	f	class:Fault
~abstract_rf_t	arf.h	/^  virtual ~abstract_rf_t( void ) {$/;"	f	class:abstract_rf_t
~act_schedule_t	actor.C	/^act_schedule_t::~act_schedule_t( void )$/;"	f	class:act_schedule_t
~actor_t	actor.C	/^actor_t::~actor_t( void )$/;"	f	class:actor_t
~arf_cc_t	arf.h	/^  ~arf_cc_t( void ) { };$/;"	f	class:arf_cc_t
~arf_container_t	arf.C	/^arf_container_t::~arf_container_t( void )$/;"	f	class:arf_container_t
~arf_control_t	arf.h	/^  ~arf_control_t( void ) { };$/;"	f	class:arf_control_t
~arf_double_t	arf.h	/^  ~arf_double_t( void ) { };$/;"	f	class:arf_double_t
~arf_int_global_t	arf.h	/^  ~arf_int_global_t( void ) { };$/;"	f	class:arf_int_global_t
~arf_int_t	arf.h	/^  ~arf_int_t( void ) { };$/;"	f	class:arf_int_t
~arf_none_t	arf.h	/^  ~arf_none_t( void ) { };$/;"	f	class:arf_none_t
~arf_single_t	arf.h	/^  ~arf_single_t( void ) { };$/;"	f	class:arf_single_t
~atomic_inst_t	memop.C	/^atomic_inst_t::~atomic_inst_t() {$/;"	f	class:atomic_inst_t
~cfg_list_t	flow.C	/^cfg_list_t::~cfg_list_t( )$/;"	f	class:cfg_list_t
~chain_t	chain.C	/^chain_t::~chain_t( )$/;"	f	class:chain_t
~control_inst_t	controlop.C	/^control_inst_t::~control_inst_t() {$/;"	f	class:control_inst_t
~ddg_a_stats	pseq.h	/^		~ddg_a_stats() { }$/;"	f	struct:pseq_t::ddg_a_stats
~ddg_node_t	ddg.C	/^ddg_node_t::~ddg_node_t() {$/;"	f	class:ddg_node_t
~decode_stat_t	decode.C	/^decode_stat_t::~decode_stat_t()$/;"	f	class:decode_stat_t
~diagnosis_t	diagnosis.C	/^diagnosis_t::~diagnosis_t()$/;"	f	class:diagnosis_t
~dtlb_t	dtlb.C	/^dtlb_t::~dtlb_t( void )$/;"	f	class:dtlb_t
~dynamic_inst_t	dynamic.C	/^dynamic_inst_t::~dynamic_inst_t()$/;"	f	class:dynamic_inst_t
~fault	pseq.h	/^		~fault() {$/;"	f	struct:pseq_t::fault
~flat_double_t	flatarf.h	/^  ~flat_double_t( void ) {$/;"	f	class:flat_double_t
~flat_rf_t	flatarf.h	/^  ~flat_rf_t( void ) { };$/;"	f	class:flat_rf_t
~flow_inst_t	flow.C	/^flow_inst_t::~flow_inst_t( void )$/;"	f	class:flow_inst_t
~generic_cache_template	cache.C	/^generic_cache_template<BlockType>::~generic_cache_template()$/;"	f	class:generic_cache_template
~histogram_t	histogram.C	/^histogram_t::~histogram_t( void )$/;"	f	class:histogram_t
~imapentry_t	ipagemap.h	/^  ~imapentry_t() { };$/;"	f	class:imapentry_t
~ipage_t	ipage.C	/^ipage_t::~ipage_t( void )$/;"	f	class:ipage_t
~ipagemap_t	ipagemap.C	/^ipagemap_t::~ipagemap_t( )$/;"	f	class:ipagemap_t
~iwindow_t	iwindow.C	/^iwindow_t::~iwindow_t()$/;"	f	class:iwindow_t
~llb_t	diagnosis.C	/^llb_t::~llb_t() $/;"	f	class:llb_t
~load_inst_t	memop.C	/^load_inst_t::~load_inst_t() {$/;"	f	class:load_inst_t
~lock_stat_t	lockstat.C	/^lock_stat_t::~lock_stat_t()$/;"	f	class:lock_stat_t
~mem_dependence_t	dependence.C	/^mem_dependence_t::~mem_dependence_t( )$/;"	f	class:mem_dependence_t
~mem_stat_t	memstat.C	/^mem_stat_t::~mem_stat_t( )$/;"	f	class:mem_stat_t
~memory_inst_t	memop.C	/^memory_inst_t::~memory_inst_t() {$/;"	f	class:memory_inst_t
~mshr_t	mshr.C	/^mshr_t::~mshr_t( void )$/;"	f	class:mshr_t
~multicore_diagnosis_t	diagnosis.C	/^multicore_diagnosis_t::~multicore_diagnosis_t() $/;"	f	class:multicore_diagnosis_t
~physical_file_t	regfile.C	/^physical_file_t::~physical_file_t() {$/;"	f	class:physical_file_t
~pipepool_t	pipepool.C	/^pipepool_t::~pipepool_t( )$/;"	f	class:pipepool_t
~pipestate_t	pipestate.C	/^pipestate_t::~pipestate_t( )$/;"	f	class:pipestate_t
~prefetch_inst_t	memop.C	/^prefetch_inst_t::~prefetch_inst_t() {$/;"	f	class:prefetch_inst_t
~pseq_t	pseq.C	/^	pseq_t::~pseq_t() {$/;"	f	class:pseq_t
~pstate_t	pstate.C	/^pstate_t::~pstate_t() {$/;"	f	class:pstate_t
~ptrace_t	ptrace.C	/^ptrace_t::~ptrace_t( )$/;"	f	class:ptrace_t
~reg_box_t	regbox.C	/^reg_box_t::~reg_box_t( )$/;"	f	class:reg_box_t
~reg_dependence_t	dependence.C	/^reg_dependence_t::~reg_dependence_t( )$/;"	f	class:reg_dependence_t
~reg_id_t	regbox.C	/^reg_id_t::~reg_id_t( void )$/;"	f	class:reg_id_t
~reg_map_t	regmap.C	/^reg_map_t::~reg_map_t() {$/;"	f	class:reg_map_t
~ruby_request_t	rubycache.C	/^ruby_request_t::~ruby_request_t( void )$/;"	f	class:ruby_request_t
~rubycache_t	rubycache.C	/^rubycache_t::~rubycache_t( void )$/;"	f	class:rubycache_t
~slice_inst	pseq.h	/^		~slice_inst() {$/;"	f	struct:pseq_t::slice_inst
~static_inst_t	statici.C	/^static_inst_t::~static_inst_t( )$/;"	f	class:static_inst_t
~static_stat_t	sstat.C	/^static_stat_t::~static_stat_t( )$/;"	f	class:static_stat_t
~store_inst_t	memop.C	/^store_inst_t::~store_inst_t() {$/;"	f	class:store_inst_t
~sys_stat_t	sysstat.C	/^sys_stat_t::~sys_stat_t( )$/;"	f	class:sys_stat_t
~system_t	system.C	/^system_t::~system_t( void )$/;"	f	class:system_t
~thread_stat_t	threadstat.C	/^thread_stat_t::~thread_stat_t( )$/;"	f	class:thread_stat_t
